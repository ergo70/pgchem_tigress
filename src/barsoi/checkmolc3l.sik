/* Output from p2c 1.21alpha-07.Dec.93, the Pascal-to-C translator */
/* From input file "checkmol3l.pas" */


#include <p2c/p2c.h>


#define version         "0.3l"

#define max_atoms       1024
#define max_bonds       1024
#define max_ringsize    128
#define max_rings       1024
#define max_fg          256
#define max_neighbors   16   /* new in v0.2h*/

#define TAB             '\032'

#define max_matchpath_length  256
#define pmCheckMol      1001
#define pmMatchMol      1002

#define rs_sar          2001   /* ring search mode: SAR = set of all rings*/
#define rs_ssr          2002   /*                   SSR = set of small rings*/

#define btopo_any       0   /* bond topology, new in v0.3d*/
#define btopo_ring      1   /**/
#define btopo_chain     2   /**/
#define btopo_always_any  3   /* even in "strict mode"*/
#define btopo_excess_rc  4
    /* bond in query and candidate must have same ring count*/
#define btopo_exact_rc  5
    /* bond in candidate must be included in _more_ rings than*/
/* the matching bond in the query ==> specific search for*/
/* annulated systems*/

#define bstereo_any     0
    /* new in v0.3d, any E/Z isomer matches (for double bonds)*/
#define bstereo_xyz     1
    /* E/Z match is checked by using XYZ coordinates of the atoms*/
#define bstereo_up      11   /* new in v0.3f, flags for single bonds*/
#define bstereo_down    16   /**/

/* Definitions for functional groups:*/
#define fg_cation       1
#define fg_anion        2
#define fg_carbonyl     3
#define fg_aldehyde     4
#define fg_ketone       5
#define fg_thiocarbonyl  6
#define fg_thioaldehyde  7
#define fg_thioketone   8
#define fg_imine        9
#define fg_hydrazone    10
#define fg_semicarbazone  11
#define fg_thiosemicarbazone  12
#define fg_oxime        13
#define fg_oxime_ether  14
#define fg_ketene       15
#define fg_ketene_acetal_deriv  16
#define fg_carbonyl_hydrate  17
#define fg_hemiacetal   18
#define fg_acetal       19
#define fg_hemiaminal   20
#define fg_aminal       21
#define fg_thiohemiaminal  22
#define fg_thioacetal   23
#define fg_enamine      24
#define fg_enol         25
#define fg_enolether    26
#define fg_hydroxy      27
#define fg_alcohol      28
#define fg_prim_alcohol  29
#define fg_sec_alcohol  30
#define fg_tert_alcohol  31
#define fg_1_2_diol     32
#define fg_1_2_aminoalcohol  33
#define fg_phenol       34
#define fg_1_2_diphenol  35
#define fg_enediol      36
#define fg_ether        37
#define fg_dialkylether  38
#define fg_alkylarylether  39
#define fg_diarylether  40
#define fg_thioether    41
#define fg_disulfide    42
#define fg_peroxide     43
#define fg_hydroperoxide  44
#define fg_hydrazine    45
#define fg_hydroxylamine  46
#define fg_amine        47
#define fg_prim_amine   48
#define fg_prim_aliph_amine  49
#define fg_prim_arom_amine  50
#define fg_sec_amine    51
#define fg_sec_aliph_amine  52
#define fg_sec_mixed_amine  53
#define fg_sec_arom_amine  54
#define fg_tert_amine   55
#define fg_tert_aliph_amine  56
#define fg_tert_mixed_amine  57
#define fg_tert_arom_amine  58
#define fg_quart_ammonium  59
#define fg_n_oxide      60
#define fg_halogen_deriv  61
#define fg_alkyl_halide  62
#define fg_alkyl_fluoride  63
#define fg_alkyl_chloride  64
#define fg_alkyl_bromide  65
#define fg_alkyl_iodide  66
#define fg_aryl_halide  67
#define fg_aryl_fluoride  68
#define fg_aryl_chloride  69
#define fg_aryl_bromide  70
#define fg_aryl_iodide  71
#define fg_organometallic  72
#define fg_organolithium  73
#define fg_organomagnesium  74
#define fg_carboxylic_acid_deriv  75
#define fg_carboxylic_acid  76
#define fg_carboxylic_acid_salt  77
#define fg_carboxylic_acid_ester  78
#define fg_lactone      79
#define fg_carboxylic_acid_amide  80
#define fg_carboxylic_acid_prim_amide  81
#define fg_carboxylic_acid_sec_amide  82
#define fg_carboxylic_acid_tert_amide  83
#define fg_lactam       84
#define fg_carboxylic_acid_hydrazide  85
#define fg_carboxylic_acid_azide  86
#define fg_hydroxamic_acid  87
#define fg_carboxylic_acid_amidine  88
#define fg_carboxylic_acid_amidrazone  89
#define fg_nitrile      90
#define fg_acyl_halide  91
#define fg_acyl_fluoride  92
#define fg_acyl_chloride  93
#define fg_acyl_bromide  94
#define fg_acyl_iodide  95
#define fg_acyl_cyanide  96
#define fg_imido_ester  97
#define fg_imidoyl_halide  98
#define fg_thiocarboxylic_acid_deriv  99
#define fg_thiocarboxylic_acid  100
#define fg_thiocarboxylic_acid_ester  101
#define fg_thiolactone  102
#define fg_thiocarboxylic_acid_amide  103
#define fg_thiolactam   104
#define fg_imido_thioester  105
#define fg_oxohetarene  106
#define fg_thioxohetarene  107
#define fg_iminohetarene  108
#define fg_orthocarboxylic_acid_deriv  109
#define fg_carboxylic_acid_orthoester  110
#define fg_carboxylic_acid_amide_acetal  111
#define fg_carboxylic_acid_anhydride  112
#define fg_carboxylic_acid_imide  113
#define fg_carboxylic_acid_unsubst_imide  114
#define fg_carboxylic_acid_subst_imide  115
#define fg_co2_deriv    116
#define fg_carbonic_acid_deriv  117
#define fg_carbonic_acid_monoester  118
#define fg_carbonic_acid_diester  119
#define fg_carbonic_acid_ester_halide  120
#define fg_thiocarbonic_acid_deriv  121
#define fg_thiocarbonic_acid_monoester  122
#define fg_thiocarbonic_acid_diester  123
#define fg_thiocarbonic_acid_ester_halide  124
#define fg_carbamic_acid_deriv  125
#define fg_carbamic_acid  126
#define fg_carbamic_acid_ester  127
#define fg_carbamic_acid_halide  128
#define fg_thiocarbamic_acid_deriv  129
#define fg_thiocarbamic_acid  130
#define fg_thiocarbamic_acid_ester  131
#define fg_thiocarbamic_acid_halide  132
#define fg_urea         133
#define fg_isourea      134
#define fg_thiourea     135
#define fg_isothiourea  136
#define fg_guanidine    137
#define fg_semicarbazide  138
#define fg_thiosemicarbazide  139
#define fg_azide        140
#define fg_azo_compound  141
#define fg_diazonium_salt  142
#define fg_isonitrile   143
#define fg_cyanate      144
#define fg_isocyanate   145
#define fg_thiocyanate  146
#define fg_isothiocyanate  147
#define fg_carbodiimide  148
#define fg_nitroso_compound  149
#define fg_nitro_compound  150
#define fg_nitrite      151
#define fg_nitrate      152
#define fg_sulfuric_acid_deriv  153
#define fg_sulfuric_acid  154
#define fg_sulfuric_acid_monoester  155
#define fg_sulfuric_acid_diester  156
#define fg_sulfuric_acid_amide_ester  157
#define fg_sulfuric_acid_amide  158
#define fg_sulfuric_acid_diamide  159
#define fg_sulfuryl_halide  160
#define fg_sulfonic_acid_deriv  161
#define fg_sulfonic_acid  162
#define fg_sulfonic_acid_ester  163
#define fg_sulfonamide  164
#define fg_sulfonyl_halide  165
#define fg_sulfone      166
#define fg_sulfoxide    167
#define fg_sulfinic_acid_deriv  168
#define fg_sulfinic_acid  169
#define fg_sulfinic_acid_ester  170
#define fg_sulfinic_acid_halide  171
#define fg_sulfinic_acid_amide  172
#define fg_sulfenic_acid_deriv  173
#define fg_sulfenic_acid  174
#define fg_sulfenic_acid_ester  175
#define fg_sulfenic_acid_halide  176
#define fg_sulfenic_acid_amide  177
#define fg_thiol        178
#define fg_alkylthiol   179
#define fg_arylthiol    180
#define fg_phosphoric_acid_deriv  181
#define fg_phosphoric_acid  182
#define fg_phosphoric_acid_ester  183
#define fg_phosphoric_acid_halide  184
#define fg_phosphoric_acid_amide  185
#define fg_thiophosphoric_acid_deriv  186
#define fg_thiophosphoric_acid  187
#define fg_thiophosphoric_acid_ester  188
#define fg_thiophosphoric_acid_halide  189
#define fg_thiophosphoric_acid_amide  190
#define fg_phosphonic_acid_deriv  191
#define fg_phosphonic_acid  192
#define fg_phosphonic_acid_ester  193
#define fg_phosphine    194
#define fg_phosphinoxide  195
#define fg_boronic_acid_deriv  196
#define fg_boronic_acid  197
#define fg_boronic_acid_ester  198
#define fg_alkene       199
#define fg_alkyne       200
#define fg_aromatic     201
#define fg_heterocycle  202
#define fg_alpha_aminoacid  203
#define fg_alpha_hydroxyacid  204


typedef Char str2[3];

typedef Char str3[4];

typedef Char str4[5];

typedef Char str5[6];

typedef Char str8[9];

typedef struct atom_rec {
  str2 element;
  str3 atype;
  float x, y, z;
  short formal_charge;
  float real_charge;
  short Hexp;   /* explicit H count*/
  short Htot;   /* total H count*/
  short neighbor_count, ring_count;
  boolean arom, stereo_care;   /* new in v0.3d*/
  boolean heavy;   /* new in v0.3l*/
  boolean metal;   /* new in v0.3l*/
} atom_rec;

typedef struct bond_rec {
  short a1, a2;
  Char btype;
  short ring_count;
  boolean arom;
  schar topo;   /* new in v0.3d, see MDL file description*/
  schar stereo;   /* new in v0.3d*/
} bond_rec;

typedef short ringpath_type[max_ringsize];
typedef short matchpath_type[max_matchpath_length];

typedef atom_rec atomlist[max_atoms];
typedef bond_rec bondlist[max_bonds];
typedef ringpath_type ringlist[max_rings];
typedef short neighbor_rec[max_neighbors];   /* new in v0.2h*/
typedef boolean fglist[max_fg];

typedef Char molbuftype[max_atoms + max_bonds + 8192][256];

typedef boolean matchmatrix[max_neighbors][max_neighbors];   /* new in v0.2i*/

typedef struct molstat_rec {
  short n_QA, n_QB, n_chg;   /* number of query atoms, query bonds, charges*/
  short n_C1, n_C2, n_C;
      /* number of sp, sp2 hybridized, and total no. of carbons*/
  short n_CHB1p, n_CHB2p, n_CHB3p, n_CHB4;
      /* number of C atoms with at least 1, 2, 3 hetero bonds*/
  short n_O2, n_O3;   /* number of sp2 and sp3 oxygens*/
  short n_N1, n_N2, n_N3;   /* number of sp, sp2, and sp3 nitrogens*/
  short n_S, n_SeTe;
      /* number of sulfur atoms and selenium or tellurium atoms*/
  short n_F, n_Cl, n_Br, n_I;
      /* number of fluorine, chlorine, bromine, iodine atoms*/
  short n_P, n_B;   /* number of phosphorus and boron atoms*/
  short n_Met, n_X;
      /* number of metal and "other" atoms (not listed elsewhere); v0.3l*/
  short n_b1, n_b2, n_b3, n_bar;
      /* number single, double, triple, and aromatic bonds*/
  short n_C1O, n_C2O, n_CN, n_XY;
      /* number of C-O single bonds, C=O double bonds, CN bonds (any type), hetero/hetero bonds*/
  short n_r3, n_r4, n_r5, n_r6, n_r7, n_r8;
      /* number of 3-, 4-, 5-, 6-, 7-, and 8-membered rings*/
  short n_r9, n_r10, n_r11, n_r12, n_r13p;
      /* number of 9-, 10-, 11-, 12-, and 13plus-membered rings*/
  short n_rN, n_rN1, n_rN2, n_rN3p;
      /* number of rings containing N (any number), 1 N, 2 N, and 3 N or more*/
  short n_rO, n_rO1, n_rO2p;
      /* number of rings containing O (any number), 1 O, and 2 O or more*/
  short n_rS, n_rX, n_rAr, n_rBz;
      /* number of rings containing S (any number), any heteroatom (any number), */
  /* number of aromatic rings, number of benzene rings*/
} molstat_rec;

typedef struct ringprop_rec {
  /* new in v0.3*/
  short size;
  boolean arom, envelope;
} ringprop_rec;

typedef ringprop_rec ringprop_type[max_rings];

typedef struct p_3d {
  /* new in v0.3d*/
  double x, y, z;
} p_3d;

typedef short chirpath_type[4];   /* new in v0.3f*/

typedef struct connval_rec {
  /* new in v0.3j*/
  short def;   /* better as longint for large molecules?*/
  short tmp;
} connval_rec;

typedef connval_rec connval_type[max_atoms];   /* new in v0.3j */


Static short progmode;
Static Char progname[256];
Static short i;   /* general purpose index*/
Static long li;
Static boolean opt_none, opt_verbose, opt_text, opt_text_de, opt_code,
	       opt_bin, opt_bitstring, opt_stdin, opt_exact, opt_debug,
	       opt_molout, opt_molstat, opt_molstat_X, opt_xmdlout,
	       opt_strict;
    /* new in v0.2f*/
Static boolean opt_metalrings;   /* new in v0.3*/
Static boolean opt_geom;   /* new in v0.3d*/
Static boolean opt_chiral;   /* new in v0.3f*/
Static short opt_rs;   /* new in v0.3i*/
Static Char filetype[256];
/*molfile : text;*/
Static Char molfilename[256];
Static Char ndl_molfilename[256];
Static Char molname[256];
Static Char ndl_molname[256];
Static Char molcomment[256];
Static short n_atoms, n_bonds, n_rings;
    /* the number of rings we determined ourselves*/
Static short n_cmrings;
    /* the number of rings we read from a (CheckMol-tweaked) MDL molfile*/
Static short n_charges;   /* number of charges*/
Static short n_heavyatoms, n_heavybonds, ndl_n_atoms, ndl_n_bonds,
	     ndl_n_rings, ndl_n_heavyatoms, ndl_n_heavybonds;
/*cm_mdlmolfile  : boolean;*/
Static boolean found_arominfo, found_querymol;

Static atom_rec *atom;
Static bond_rec *bond;
Static ringpath_type *ring;
Static ringprop_rec *ringprop;   /* new in v0.3*/

Static atom_rec *ndl_atom;
Static bond_rec *ndl_bond;
Static ringpath_type *ndl_ring;
Static ringprop_rec *ndl_ringprop;   /* new in v0.3*/
Static short ndl_ref_atom;   /* since v0.3j as a global variable*/

Static boolean matchresult;
Static matchpath_type ndl_matchpath, hst_matchpath;

Static fglist fg;
Static str4 atomtype;
Static str3 newatomtype;

Static Char (*molbuf)[256];
Static short molbufindex;

Static boolean mol_in_queue;
Static long mol_count;

Static molstat_rec molstat, ndl_molstat;

Static short ringsearch_mode, max_vringsize;   /* for SSR ring search*/

Static FILE *rfile;
Static boolean rfile_is_open, mol_OK;   /* new in v0.2i*/

Static short n_ar;   /* new in v0.3*/
Static short prev_n_ar;   /* new in v0.3*/
Static boolean ez_search;   /* new in v0.3d*/
Static boolean rs_search;   /* new in v0.3f*/
Static boolean ez_flag;   /* new in v0.3f*/
Static boolean chir_flag;   /* new in v0.3f*/
Static boolean rs_strict;   /* new in v0.3j*/

Static short n_Ctot, n_Otot, n_Ntot;   /* new in v0.3g*/
Static short ndl_n_Ctot, ndl_n_Otot, ndl_n_Ntot;   /* new in v0.3g*/
Static boolean ether_generic;   /* v0.3j*/
Static boolean amine_generic;   /* v0.3j  */
Static boolean hydroxy_generic;   /* v0.3j*/
Static connval_rec *cv;   /* new in v0.3j*/
Static Char rfile_NAME[_FNSIZE];


/*============================= auxiliary functions & procedures*/

Static void init_globals(void)
{
  short i;

  opt_verbose = false;
  opt_debug = false;
  opt_exact = false;
  opt_stdin = false;
  opt_text = false;
  opt_code = false;
  opt_bin = false;
  opt_bitstring = false;
  opt_molout = false;
  opt_molstat = false;
  opt_molstat_X = false;
  opt_xmdlout = false;
  opt_strict = false;   /* new in v0.2f*/
  opt_metalrings = false;   /* new in v0.3*/
  opt_geom = false;   /* new in v0.3d*/
  opt_chiral = false;   /* new in v0.3f*/
  /*cm_mdlmolfile   := false;*/
  found_arominfo = false;
  found_querymol = false;
  opt_rs = rs_sar;   /* v0.3i*/
  /*ringsearch_mode := rs_sar;*/
  rfile_is_open = false;   /* new in v0.2g*/
  ez_search = false;   /* new in v0.3d*/
  rs_search = false;   /* new in v0.3f*/
  ez_flag = false;   /* new in v0.3f*/
  chir_flag = false;   /* new in v0.3f*/
  rs_strict = false;   /* new in v0.3j*/
  n_Ctot = 0;
  n_Otot = 0;
  n_Ntot = 0;   /* new in v0.3g*/
  ndl_n_Ctot = 0;
  ndl_n_Otot = 0;
  ndl_n_Ntot = 0;   /* new in v0.3g*/
  for (i = 0; i <= max_fg - 1; i++)
    fg[i] = false;
  molbuf = Malloc(sizeof(molbuftype));
  ether_generic = false;   /* v0.3j*/
  amine_generic = false;   /* v0.3j*/
  hydroxy_generic = false;   /* v0.3j*/
}


Static void init_molstat(molstat_rec *mstat)
{
  /*
  with mstat do
    begin
      n_QA := 0; n_QB := 0; n_chg := 0;
      n_C1 := 0; n_C2 := 0; n_C  := 0;
      n_CHB1p := 0; n_CHB2p := 0; n_CHB3p := 0; n_CHB4 := 0;
      n_O2 := 0; n_O3  := 0;
      n_N1 := 0; n_N2 := 0; n_N3 := 0;
      n_S := 0; n_SeTe := 0;
      n_F := 0; n_Cl := 0; n_Br := 0; n_I := 0;
      n_P := 0; n_B := 0;
      n_Met := 0; n_X := 0;
      n_b1 := 0; n_b2 := 0; n_b3 := 0; n_bar := 0;
      n_C1O := 0; n_C2O := 0; n_CN := 0; n_XY := 0;
      n_r3 := 0; n_r4 := 0; n_r5 := 0; n_r6 := 0; n_r7 := 0;
      n_r8 := 0; n_r9 := 0; n_r10 := 0; n_r11 := 0; n_r12 := 0; n_r13p := 0;
      n_rN := 0; n_rN1 := 0; n_rN2 := 0; n_rN3p := 0;
      n_rO := 0; n_rO1 := 0; n_rO2p := 0;
      n_rS := 0; n_rX := 0;
      n_rAr := 0; n_rBz := 0;
    end;
  */
  memset(mstat, 0, sizeof(molstat_rec));   /* v0.3k*/
}


Static void debugoutput(Char *dstr)
{
  if (opt_debug)
    puts(dstr);
}


Static void left_trim(Char *trimstr)
{
  while (*trimstr != '\0' && (trimstr[0] == ' ' || trimstr[0] == TAB))
    strdelete((void *)trimstr, 1, 1);
}


Static short left_int(Char *trimstr)
{
  Char numstr[256];
  Char auxstr[256];
  short auxint = 0;
  short code;
  Char STR1[256];

  strcpy(numstr, "-+0123456789");
  *auxstr = '\0';
  while (*trimstr != '\0' && (trimstr[0] == ' ' || trimstr[0] == TAB))
    strdelete((void *)trimstr, 1, 1);
  while (*trimstr != '\0' &&
	 strpos2(numstr, (sprintf(STR1, "%c", trimstr[0]), STR1), 1) > 0) {
    sprintf(auxstr + strlen(auxstr), "%c", trimstr[0]);
    strdelete((void *)trimstr, 1, 1);
  }
  code = (sscanf(auxstr, "%d", &auxint) == 0);
  return auxint;
}


/*============================= geometry functions ==========================*/

Static double dist3d(p_3d p1, p_3d p2)
{
  double res, TEMP, TEMP1, TEMP2;

  TEMP = p1.x - p2.x;
  TEMP1 = p1.y - p2.y;
  TEMP2 = p1.z - p2.z;
  res = sqrt(TEMP * TEMP + TEMP1 * TEMP1 + TEMP2 * TEMP2);
  return res;
}


/*
function is_cis(p1,p2,p3,p4:p_3d):boolean;  { new in v0.3d}
var                         { just a simple, distance-based estimation}
  total_dist  : double;     { instead of calculating the dihedral angle}
  direct_dist : double;
  res         : boolean;
begin
  res := false;
  total_dist  := dist3d(p1,p2) + dist3d(p2,p3) + dist3d(p3,p4);
  direct_dist := dist3d(p1,p4);
  if (direct_dist < 0.78 * total_dist) then res := true;  { cutoff value of 0.78 was}
  is_cis := res;                                          { experimentally determined}
end;
*/
/* function is_cis was replaced by a new one in v0.3h*/


Static p_3d subtract_3d(p_3d p1, p_3d p2)
{
  p_3d p;

  p.x = p1.x - p2.x;
  p.y = p1.y - p2.y;
  p.z = p1.z - p2.z;
  return p;
}


Static p_3d add_3d(p_3d p1, p_3d p2)
{
  p_3d p;

  p.x = p1.x + p2.x;
  p.y = p1.y + p2.y;
  p.z = p1.z + p2.z;
  return p;
}


Static void vec2origin(p_3d *p1, p_3d *p2)
{
  p_3d p;

  p = subtract_3d(*p2, *p1);
  *p2 = p;
  p1->x = 0.0;
  p1->y = 0.0;
  p1->z = 0.0;
}


Static double scalar_prod(p_3d p1, p_3d p2, p_3d p3)
{
  p_3d p;
  double res;

  p = subtract_3d(p2, p1);
  p2 = p;
  p = subtract_3d(p3, p1);
  p3 = p;
  p1.x = 0.0;
  p1.y = 0.0;
  p1.z = 0.0;
  res = p2.x * p3.x + p2.y * p3.y + p2.z * p3.z;
  return res;
}


Static p_3d cross_prod(p_3d p1, p_3d p2, p_3d p3)
{
  p_3d p, orig_p1;

  orig_p1 = p1;
  p = subtract_3d(p2, p1);
  p2 = p;
  p = subtract_3d(p3, p1);
  p3 = p;
  p.x = p2.y * p3.z - p2.z * p3.y;
  p.y = p2.z * p3.x - p2.x * p3.z;
  p.z = p2.x * p3.y - p2.y * p3.x;
  return (add_3d(orig_p1, p));
}


Static double angle_3d(p_3d p1, p_3d p2, p_3d p3)
{
  p_3d lp1, lp2, lp3, p;
  double res = 0.0;
  double magn_1, magn_2, cos_phi;

  lp1 = p1;
  lp2 = p2;
  lp3 = p3;
  p = subtract_3d(lp2, lp1);
  lp2 = p;
  p = subtract_3d(lp3, lp1);
  lp3 = p;
  lp1.x = 0.0;
  lp1.y = 0.0;
  lp1.z = 0.0;
  magn_1 = dist3d(lp1, lp2);
  magn_2 = dist3d(lp1, lp3);
  if (magn_1 * magn_2 == 0)  /* emergency exit*/
    return M_PI;
  cos_phi = scalar_prod(lp1, lp2, lp3) / (magn_1 * magn_2);
  if (cos_phi < -1)
    cos_phi = -1.0;
  if (cos_phi > 1)
    cos_phi = 1.0;
  res = arccos(cos_phi);
  return res;
}


Static double torsion(p_3d p1, p_3d p2, p_3d p3, p_3d p4)
{
  p_3d lp1, lp2, lp3, lp4, d1, c1, c2;
  double res;
  p_3d c1xc2, c2xc1;
  double dist1, dist2, sign;

  /* copy everything into local variables*/
  lp1 = p1;
  lp2 = p2;
  lp3 = p3;
  lp4 = p4;
  /* get the vector between the two central atoms*/
  d1 = subtract_3d(p3, p2);
  /* shift the first atom parallel to be attached to p3 instead of p2*/
  lp1 = add_3d(p1, d1);
  /* now get the cross product vectors*/
  c1 = cross_prod(lp3, lp2, lp1);
  c2 = cross_prod(lp3, lp2, lp4);
  res = angle_3d(p3, c1, c2);
  /*now check if it is clockwise or anticlockwise:*/
  /*first, make the cross products of the two cross products c1 and c2 (both ways)*/
  c1xc2 = cross_prod(lp3, c1, c2);
  c2xc1 = cross_prod(lp3, c2, c1);
  /*next, get the distances from these points to our refernce point lp2*/
  dist1 = dist3d(lp2, c1xc2);
  dist2 = dist3d(lp2, c2xc1);
  if (dist1 <= dist2)
    sign = 1.0;
  else
    sign = -1.0;
  return (sign * res);
}


Static double ctorsion(p_3d p1, p_3d p2, p_3d p3, p_3d p4)
{
  /* calculates "pseudo-torsion" defined by atoms 3 and 4, being both*/
  /* attached to atom 2, with respect to axis of atoms 1 and 2*/
  p_3d lp1, lp2, lp3, lp4;
  /*d1 : p_3d;*/
  p_3d c1, c2;
  double res;
  p_3d c1xc2, c2xc1;
  double dist1, dist2, sign;

  /* copy everything into local variables*/
  lp1 = p1;
  lp2 = p2;
  lp3 = p3;
  lp4 = p4;
  /* get the cross product vectors*/
  c1 = cross_prod(lp2, lp1, lp3);
  c2 = cross_prod(lp2, lp1, lp4);
  res = angle_3d(p2, c1, c2);
  /*now check if it is clockwise or anticlockwise:*/
  /*first, make the cross products of the two cross products c1 and c2 (both ways)*/
  c1xc2 = cross_prod(lp2, c1, c2);
  c2xc1 = cross_prod(lp2, c2, c1);
  /*next, get the distances from these points to our refernce point lp1*/
  dist1 = dist3d(lp1, c1xc2);
  dist2 = dist3d(lp1, c2xc1);
  if (dist1 <= dist2)
    sign = 1.0;
  else
    sign = -1.0;
  return (sign * res);
}


Static boolean is_cis(p_3d p1, p_3d p2, p_3d p3, p_3d p4)
{
  /* new in v0.3h, uses the dihedral angle*/
  double phi;
  boolean res = false;

  phi = torsion(p1, p2, p3, p4);
  if (fabs(phi) < M_PI / 2)
    res = true;
  return res;
}


/*====================== end of geometry functions ==========================*/

Static void show_usage(void)
{
  if (progmode == pmMatchMol) {
    printf("matchmol version %s  N. Haider, University of Vienna, 2003-2005\n",
	   version);
    printf("Usage: matchmol [options] <needle> <haystack>\n");
    printf(" where <needle> and <haystack> are the two molecules to compare\n");
    printf(" (supported formats: MDL *.mol or *.sdf, Alchemy *.mol, Sybyl *.mol2)\n");
    printf(" options can be:\n");
    printf("    -v  verbose output\n");
    printf("    -x  exact match\n");
    printf(
      "    -s  strict comparison of atom and bond types (including ring check)\n");
	/* new in v0.2f, v0.3d*/
    printf("    -r  force SSR (set of small rings) ring search mode\n");
    printf("    -m  write matching molecule as MDL molfile to standard output\n");
    printf(
      "        (default output: record number + \":T\" for hit  or \":F\" for miss\n");
    printf("    -M  accept metal atoms as ring members\n");
    printf("    -g  check geometry of double bonds (E/Z)\n");
    printf("    -G  check geometry of chiral centers (R/S)\n");
    return;
  }
  printf("checkmol version %s  N. Haider, University of Vienna, 2003-2005\n",
	 version);
  printf("Usage: checkmol [options] <filename>\n");
  printf(" where options can be:\n");
  printf("    -l  print a list of fingerprint codes + explanation and exit\n");
  printf("    -v  verbose output\n");
  printf("    -r  force SSR (set of small rings) ring search mode\n");
  printf("    -M  accept metal atoms as ring members\n");
  printf("  and one of the following:\n");
  printf("    -e  english text (common name of functional group; default)\n");
  printf("    -d  german text (common name of functional group)\n");
  printf("    -c  code (acronym-like code for functional group)\n");
  printf(
    "    -b  binary (a bitstring representing absence or presence of each group)\n");
  printf("    -s  the ASCII representation of the above bitstring, i.e. 0s and 1s)\n");
  printf(
    "    -x  print molecular statistics (number of various atom types, bond types,\n");
  printf("        ring sizes, etc.\n");
  printf(
    "    -X  same as above, listing all records (even if 0) as comma-separated list\n");
  printf(
    "    -m  write MDL molfile (with special encoding for aromatic atoms/bonds)\n");
  printf(" options can be combined like -vc\n");
  printf(" <filename> specifies any file in the formats supported\n");
  printf(
    " (MDL *.mol, Alchemy *.mol, Sybyl *.mol2), the filename \"-\" (without quotes)\n");
  printf(" specifies standard input\n");
  /* the "debug" option (-D) remains undocumented*/
}


Static void list_molstat_codes(void)
{
  printf("n_atoms:     number of heavy atoms\n");
  printf("n_bonds:     number of bonds between non-H atoms\n");
  printf("n_rings:     number of rings\n");
  /*  writeln('n_QA:        number of query atoms');');*/
  /*  writeln('n_QB:        number of query bonds');*/
  printf("n_chg:       number of charges\n");
  printf("n_C1:        number of sp-hybridized carbon atoms\n");
  printf("n_C2:        number of sp2-hybridized carbon atoms\n");
  printf("n_C:         total number of carbon atoms\n");
  printf(
    "n_CHB1p:     number of carbon atoms with at least 1 bond to a hetero atom\n");
  printf(
    "n_CHB2p:     number of carbon atoms with at least 2 bonds to a hetero atom\n");
  printf(
    "n_CHB3p:     number of carbon atoms with at least 3 bonds to a hetero atom\n");
  printf("n_CHB4:      number of carbon atoms with 4 bonds to a hetero atom\n");
  printf("n_O2:        number of sp2-hybridized oxygen atoms\n");
  printf("n_O3:        number of sp3-hybridized oxygen atoms\n");
  printf("n_N1:        number of sp-hybridized nitroen atoms\n");
  printf("n_N2:        number of sp2-hybridized nitroen atoms\n");
  printf("n_N3:        number of sp3-hybridized nitroen atoms\n");
  printf("n_S:         number of sulfur atoms\n");
  printf("n_SeTe:      total number of selenium and tellurium atoms\n");
  printf("n_F:         number of fluorine atoms\n");
  printf("n_Cl:        number of chlorine atoms\n");
  printf("n_Br:        number of bromine atoms\n");
  printf("n_I:         number of iodine atoms\n");
  printf("n_P:         number of phosphorus atoms\n");
  printf("n_B:         number of boron atoms\n");
  printf("n_Met:       total number of metal atoms\n");
  printf("n_X:         total number of \"other\" atoms (not listed above)\n");
  printf("n_b1:        number of single bonds\n");
  printf("n_b2:        number of double bonds\n");
  printf("n_b3:        number of triple bonds\n");
  printf("n_bar:       number of aromatic bonds\n");
  printf("n_C1O:       number of C-O single bonds\n");
  printf("n_C2O:       number of C=O double bonds\n");
  printf("n_CN:        number of C/N bonds (any type)\n");
  printf("n_XY:        number of heteroatom/heteroatom bonds (any type)\n");
  printf("n_r3:        number of 3-membered rings\n");
  printf("n_r4:        number of 4-membered rings\n");
  printf("n_r5:        number of 5-membered rings\n");
  printf("n_r6:        number of 6-membered rings\n");
  printf("n_r7:        number of 7-membered rings\n");
  printf("n_r8:        number of 8-membered rings\n");
  printf("n_r9:        number of 9-membered rings\n");
  printf("n_r10:       number of 10-membered rings\n");
  printf("n_r11:       number of 11-membered rings\n");
  printf("n_r12:       number of 12-membered rings\n");
  printf("n_r13p:      number of 13-membered or larger rings\n");
  printf("n_rN:        number of rings containing nitrogen (any number)\n");
  printf("n_rN1:       number of rings containing 1 nitrogen atom\n");
  printf("n_rN2:       number of rings containing 2 nitrogen atoms\n");
  printf("n_rN3p:      number of rings containing 3 or more nitrogen atoms\n");
  printf("n_rO:        number of rings containing oxygen (any number)\n");
  printf("n_rO1:       number of rings containing 1 oxygen atom\n");
  printf("n_rO2p:      number of rings containing 2 or more oxygen atoms\n");
  printf("n_rS:        number of rings containing sulfur (any number)\n");
  printf("n_rX:        number of heterocycles (any type)\n");
  printf("n_rar:       number of aromatic rings (any type)\n");
  printf("n_rbz:       number of benzene rings\n");
}


Static void parse_args(void)
{
  short p;
  Char parstr[256];
  Char tmpstr[256];
  short l;

  *tmpstr = '\0';
  opt_none = true;
  if (progmode == pmCheckMol) {
    for (p = 1; p <= P_argc - 1; p++) {
      strcpy(parstr, P_argv[p]);
      if (!strcmp(parstr, "-l")) {   /* new in v0.3l*/
	list_molstat_codes();
	_Escape(0);
      }
      if (p < P_argc - 1) {
	if (strpos2(parstr, "-", 1) == 1 && p < P_argc - 1) {
	  strcpy(tmpstr, P_argv[p]);
	  left_trim(tmpstr);
	  l = 0;
	  if (strpos2(tmpstr, "v", 1) > 0)
	    l++;
	  if (strpos2(tmpstr, "D", 1) > 0)
	    l++;
	  if (strpos2(tmpstr, "r", 1) > 0)
	    l++;
	  if (strpos2(tmpstr, "M", 1) > 0)   /* new in v0.3*/
	    l++;
	  if (strlen(tmpstr) > l + 2) {
	    show_usage();
	    _Escape(1);
	  }
	  opt_none = false;
	  if (strpos2(tmpstr, "M", 1) > 0)
	    opt_metalrings = true;
	  if (strpos2(tmpstr, "v", 1) > 0)
	    opt_verbose = true;
	  /*{$IFDEF debug
	  if pos('D',tmpstr)>0 then opt_debug       := true;
	  {$ENDIF*/
	  if (strpos2(tmpstr, "e", 1) > 0)
	    opt_text = true;
	  else {
	    if (strpos2(tmpstr, "d", 1) > 0)
	      opt_text_de = true;
	    else {
	      if (strpos2(tmpstr, "c", 1) > 0)
		opt_code = true;
	      else {
		if (strpos2(tmpstr, "b", 1) > 0)
		  opt_bin = true;
		else {
		  if (strpos2(tmpstr, "s", 1) > 0)
		    opt_bitstring = true;
		}
	      }
	    }
	    if (strpos2(tmpstr, "x", 1) > 0)
	      opt_molstat = true;
	    if (strpos2(tmpstr, "r", 1) > 0)
	      opt_rs = rs_ssr;
	    if (strpos2(tmpstr, "X", 1) > 0) {
	      opt_molstat = true;
	      opt_molstat_X = true;
	    }
	    if (strpos2(tmpstr, "m", 1) > 0) {
	      opt_text = false;
	      opt_text_de = false;
	      opt_bin = false;
	      opt_bitstring = false;
	      opt_code = false;
	      opt_molstat = false;
	      opt_xmdlout = true;
	    }
	  }
	  strcpy(molfilename, tmpstr);
	}
      } else {
	if (strpos2(parstr, "-", 1) == 1) {
	  if (strlen(parstr) > 1) {
	    show_usage();
	    _Escape(1);
	  }
	  opt_stdin = true;
	} else {
	  opt_stdin = false;
	  strcpy(molfilename, parstr);
	}
      }
    }
    if (opt_text == false && opt_text_de == false && opt_code == false &&
	opt_bin == false && opt_bitstring == false && opt_molstat == false &&
	opt_molstat_X == false && opt_xmdlout == false)
      opt_none = true;
  }
  if (progmode == pmMatchMol) {
    *ndl_molfilename = '\0';
    *molfilename = '\0';
    for (p = 1; p <= P_argc - 1; p++) {
      strcpy(parstr, P_argv[p]);
      if (p == 1) {
	if (strpos2(parstr, "-", 1) == 1) {
	  if (strpos2(parstr, "v", 1) > 1)
	    opt_verbose = true;
	  /*{$IFDEF debug
	  if pos('D',parstr)>1 then opt_debug       := true;
	  {$ENDIF*/
	  if (strpos2(parstr, "x", 1) > 1)
	    opt_exact = true;
	  if (strpos2(parstr, "s", 1) > 1)   /* new in v0.2f*/
	    opt_strict = true;
	  if (strpos2(parstr, "m", 1) > 1)
	    opt_molout = true;
	  if (strpos2(parstr, "r", 1) > 1)
	    opt_rs = rs_ssr;
	  if (strpos2(parstr, "M", 1) > 0)   /* new in v0.3*/
	    opt_metalrings = true;
	  if (strpos2(parstr, "g", 1) > 0)   /* new in v0.3d*/
	    opt_geom = true;
	  if (strpos2(parstr, "G", 1) > 0)   /* new in v0.3f*/
	    opt_chiral = true;
	  if (strpos2(parstr, "h", 1) > 1) {
	    show_usage();
	    _Escape(0);
	  }
	} else
	  strcpy(ndl_molfilename, parstr);
      }
      if (p == P_argc - 2) {
	if (strpos2(parstr, "-", 1) != 1)
	  strcpy(ndl_molfilename, parstr);
      }
      if (p == P_argc - 1) {
	if (strcmp(parstr, "-"))
	  strcpy(molfilename, parstr);
	else
	  opt_stdin = true;
      }
    }
    if (opt_geom)   /* v0.3d*/
      ez_search = true;
    if (opt_chiral)   /* v0.3f*/
      rs_search = true;
    if (opt_chiral && opt_strict && opt_exact)   /* new in v0.3j*/
      rs_strict = true;
  }  /* progmode = pmMatchMol*/
  ringsearch_mode = opt_rs;   /* v0.3i*/
}


/*============== input-related functions & procedures =====================*/

Static Char *get_filetype(Char *Result, Char *f)
{
  Char rline[256];
  Char auxstr[256];
  short i;
  boolean mdl1 = false;
  short ri;
  short sepcount = 0;
  Char STR1[256], STR6[256], STR7[256];

  strcpy(auxstr, "unknown");
  i = li;
  ri = li - 1;
  while (ri < molbufindex && sepcount < 1) {
    ri++;
    strcpy(rline, molbuf[ri-1]);
    if (strpos2(rline, "$$$$", 1) > 0)
      sepcount++;
    if (i == li && !strcmp(strsub(STR1, rline, 7, 5), "ATOMS") &&
	!strcmp(strsub(STR6, rline, 20, 5), "BONDS") &&
	!strcmp(strsub(STR7, rline, 33, 7), "CHARGES"))
      strcpy(auxstr, "alchemy");
    if (i == li + 3 && !strcmp(strsub(STR1, rline, 35, 5), "V2000"))
	  /* and (copy(rline,31,3)='999')*/
	    mdl1 = true;
    if (i == li + 1 && !strcmp(strsub(STR1, rline, 3, 6), "-ISIS-"))
      mdl1 = true;
    if (i == li + 1 && !strcmp(strsub(STR1, rline, 3, 8), "WLViewer"))
      mdl1 = true;
    if (i == li + 1 && !strcmp(strsub(STR1, rline, 3, 8), "CheckMol"))
      mdl1 = true;
    if (i == li + 1 && !strcmp(strsub(STR1, rline, 3, 8), "CATALYST")) {
      mdl1 = true;
      strcpy(auxstr, "mdl");
    }
    if (strpos2(rline, "M  END", 1) == 1 || mdl1)
      strcpy(auxstr, "mdl");
    if (strpos2(rline, "@<TRIPOS>MOLECULE", 1) > 0)
      strcpy(auxstr, "sybyl");
    i++;
  }
  /* new in v0.2j: try to identify non-conformant SD-files*/
  if (!strcmp(auxstr, "unknown") && sepcount > 0)
    strcpy(auxstr, "mdl");
  return strcpy(Result, auxstr);
}


Static void zap_molecule(void)
{
  if (atom != NULL) {
    Free(atom);
    atom = NULL;   /* added in v0.3j*/
  }
  if (bond != NULL) {
    Free(bond);
    bond = NULL;   /* added in v0.3j*/
  }
  if (ring != NULL) {
    Free(ring);
    ring = NULL;   /* added in v0.3j*/
  }
  if (ringprop != NULL) {
    Free(ringprop);
    ringprop = NULL;   /* added in v0.3j*/
  }
  n_atoms = 0;
  n_bonds = 0;
  n_rings = 0;
}


Static void zap_needle(void)
{
  if (ndl_atom != NULL) {
    Free(ndl_atom);
    ndl_atom = NULL;   /* added in v0.3j*/
  }
  if (ndl_bond != NULL) {
    Free(ndl_bond);
    ndl_bond = NULL;   /* added in v0.3j*/
  }
  if (ndl_ring != NULL) {
    Free(ndl_ring);
    ndl_ring = NULL;   /* added in v0.3j*/
  }
  if (ndl_ringprop != NULL) {
    Free(ndl_ringprop);   /* fixed in v0.3g*/
    ndl_ringprop = NULL;   /* added in v0.3j*/
  }
  ndl_n_atoms = 0;
  ndl_n_bonds = 0;
  ndl_n_rings = 0;
}


Static boolean is_heavyatom(short id)
{
  boolean r = true;
  str2 el;

  strcpy(el, atom[id-1].element);
  if (!strcmp(el, "H ") || !strcmp(el, "DU") || !strcmp(el, "LP"))
    r = false;
  /*inc(is_heavy_cnt); {Only for timing, can be removed*/
  return r;
}


Static boolean ndl_alkene_C(short ba)
{
  /* new in v0.3f*/
  boolean res = false;
  short i, ba2, FORLIM;

  if (ndl_n_atoms <= 0 || ndl_n_bonds <= 0)
    return false;
  FORLIM = ndl_n_bonds;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (ndl_bond[i].a1 == ba || ndl_bond[i].a2 == ba) {
      if (ndl_bond[i].a1 == ba)
	ba2 = ndl_bond[i].a2;
      else
	ba2 = ndl_bond[i].a1;
      if (!strcmp(ndl_atom[ba-1].atype, "C2 ") &&
	  !strcmp(ndl_atom[ba2-1].atype, "C2 ") &&
	  ndl_bond[i].btype == 'D' && ndl_bond[i].arom == false)
	res = true;
    }
  }
  return res;
}


Static boolean is_metal(short id)
{
  boolean r = false;
  str2 el;

  strcpy(el, atom[id-1].element);
  if (!strcmp(el, "LI") || !strcmp(el, "NA") || !strcmp(el, "K ") ||
      !strcmp(el, "RB") || !strcmp(el, "CS") || !strcmp(el, "BE") ||
      !strcmp(el, "MG") || !strcmp(el, "CA") || !strcmp(el, "SR") ||
      !strcmp(el, "BA") || !strcmp(el, "TI") || !strcmp(el, "ZR") ||
      !strcmp(el, "CR") || !strcmp(el, "MO") || !strcmp(el, "MN") ||
      !strcmp(el, "FE") || !strcmp(el, "CO") || !strcmp(el, "NI") ||
      !strcmp(el, "PD") || !strcmp(el, "PT") || !strcmp(el, "SN") ||
      !strcmp(el, "CU") || !strcmp(el, "AG") || !strcmp(el, "AU") ||
      !strcmp(el, "ZN") || !strcmp(el, "CD") || !strcmp(el, "HG") ||
      !strcmp(el, "AL") || !strcmp(el, "SN") || !strcmp(el, "PB") ||
      !strcmp(el, "SB") || !strcmp(el, "BI"))
/* p2c: checkmol3l.pas, line 1130: 
 * Note: Line breaker spent 0.0 seconds, 5000 tries on line 1179 [251] */
	/* etc. etc.*/
	  r = true;
  return r;
}


Static Char *convert_type(Char *Result, Char *oldtype)
{
  short i;
  str3 newtype;

  sprintf(newtype, "%.3s", oldtype);
/* p2c: checkmol3l.pas, line 1138:
 * Note: Possible string truncation in assignment [145] */
  for (i = 0; i <= 2; i++)
    newtype[i] = toupper(newtype[i]);
  if (newtype[0] == '~')
    strcpy(newtype, "VAL");
  if (newtype[0] == '*')
    strcpy(newtype, "STR");
  return strcpy(Result, newtype);
}


Static Char *convert_sybtype(Char *Result, Char *oldtype)
{
  str3 newtype;

  /*  NewType := Copy(OldType,1,3);*/
  /*  For i := 1 To 3 Do NewType[i] := UpCase(NewType[i]);*/
  /*  If NewType[1] = '~' Then NewType := 'VAL';*/
  /*  If NewType[1] = '*' Then NewType := 'STR';*/
  strcpy(newtype, "DU ");
  if (!strcmp(oldtype, "H    "))
    strcpy(newtype, "H  ");
  if (!strcmp(oldtype, "C.ar "))
    strcpy(newtype, "CAR");
  if (!strcmp(oldtype, "C.2  "))
    strcpy(newtype, "C2 ");
  if (!strcmp(oldtype, "C.3  "))
    strcpy(newtype, "C3 ");
  if (!strcmp(oldtype, "C.1  "))
    strcpy(newtype, "C1 ");
  if (!strcmp(oldtype, "O.2  "))
    strcpy(newtype, "O2 ");
  if (!strcmp(oldtype, "O.3  "))
    strcpy(newtype, "O3 ");
  if (!strcmp(oldtype, "O.co2"))
    strcpy(newtype, "O2 ");
  if (!strcmp(oldtype, "O.spc"))
    strcpy(newtype, "O3 ");
  if (!strcmp(oldtype, "O.t3p"))
    strcpy(newtype, "O3 ");
  if (!strcmp(oldtype, "N.1  "))
    strcpy(newtype, "N1 ");
  if (!strcmp(oldtype, "N.2  "))
    strcpy(newtype, "N2 ");
  if (!strcmp(oldtype, "N.3  "))
    strcpy(newtype, "N3 ");
  if (!strcmp(oldtype, "N.pl3"))
    strcpy(newtype, "NPL");
  if (!strcmp(oldtype, "N.4  "))
    strcpy(newtype, "N3+");
  if (!strcmp(oldtype, "N.am "))
    strcpy(newtype, "NAM");
  if (!strcmp(oldtype, "N.ar "))
    strcpy(newtype, "NAR");
  if (!strcmp(oldtype, "F    "))
    strcpy(newtype, "F  ");
  if (!strcmp(oldtype, "Cl   "))
    strcpy(newtype, "CL ");
  if (!strcmp(oldtype, "Br   "))
    strcpy(newtype, "BR ");
  if (!strcmp(oldtype, "I    "))
    strcpy(newtype, "I  ");
  if (!strcmp(oldtype, "Al   "))
    strcpy(newtype, "AL ");
  if (!strcmp(oldtype, "ANY  "))
    strcpy(newtype, "A  ");
  if (!strcmp(oldtype, "Ca   "))
    strcpy(newtype, "CA ");
  if (!strcmp(oldtype, "Du   "))
    strcpy(newtype, "DU ");
  if (!strcmp(oldtype, "Du.C "))
    strcpy(newtype, "DU ");
  if (!strcmp(oldtype, "H.spc"))
    strcpy(newtype, "H  ");
  if (!strcmp(oldtype, "H.t3p"))
    strcpy(newtype, "H  ");
  if (!strcmp(oldtype, "HAL  "))
    strcpy(newtype, "Cl ");
  if (!strcmp(oldtype, "HET  "))
    strcpy(newtype, "Q  ");
  if (!strcmp(oldtype, "HEV  "))
    strcpy(newtype, "DU ");
  if (!strcmp(oldtype, "K    "))
    strcpy(newtype, "K  ");
  if (!strcmp(oldtype, "Li   "))
    strcpy(newtype, "LI ");
  if (!strcmp(oldtype, "LP   "))
    strcpy(newtype, "LP ");
  if (!strcmp(oldtype, "Na   "))
    strcpy(newtype, "NA ");
  if (!strcmp(oldtype, "P.3  "))
    strcpy(newtype, "P3 ");
  if (!strcmp(oldtype, "S.2  "))
    strcpy(newtype, "S2 ");
  if (!strcmp(oldtype, "S.3  "))
    strcpy(newtype, "S3 ");
  if (!strcmp(oldtype, "S.o  "))
    strcpy(newtype, "SO ");
  if (!strcmp(oldtype, "S.o2 "))
    strcpy(newtype, "SO2");
  if (!strcmp(oldtype, "Si   "))
    strcpy(newtype, "SI ");
  if (!strcmp(oldtype, "P.4  "))
    strcpy(newtype, "P4 ");
  return strcpy(Result, newtype);
}


Static Char *convert_MDLtype(Char *Result, Char *oldtype)
{
  str3 newtype;

  /*  NewType := Copy(OldType,1,3);*/
  /*  For i := 1 To 3 Do NewType[i] := UpCase(NewType[i]);*/
  /*  If NewType[1] = '~' Then NewType := 'VAL';*/
  /*  If NewType[1] = '*' Then NewType := 'STR';*/
  strcpy(newtype, "DU ");
  if (!strcmp(oldtype, "H  "))
    strcpy(newtype, "H  ");
  if (!strcmp(oldtype, "C  "))
    strcpy(newtype, "C3 ");
  if (!strcmp(oldtype, "O  "))
    strcpy(newtype, "O2 ");
  if (!strcmp(oldtype, "N  "))
    strcpy(newtype, "N3 ");
  if (!strcmp(oldtype, "F  "))
    strcpy(newtype, "F  ");
  if (!strcmp(oldtype, "Cl "))
    strcpy(newtype, "CL ");
  if (!strcmp(oldtype, "Br "))
    strcpy(newtype, "BR ");
  if (!strcmp(oldtype, "I  "))
    strcpy(newtype, "I  ");
  if (!strcmp(oldtype, "Al "))
    strcpy(newtype, "AL ");
  if (!strcmp(oldtype, "ANY"))
    strcpy(newtype, "A  ");
  if (!strcmp(oldtype, "Ca "))
    strcpy(newtype, "CA ");
  if (!strcmp(oldtype, "Du "))
    strcpy(newtype, "DU ");
  if (!strcmp(oldtype, "K  "))
    strcpy(newtype, "K  ");
  if (!strcmp(oldtype, "Li "))
    strcpy(newtype, "LI ");
  if (!strcmp(oldtype, "LP "))
    strcpy(newtype, "LP ");
  if (!strcmp(oldtype, "Na "))
    strcpy(newtype, "NA ");
  if (!strcmp(oldtype, "P  "))
    strcpy(newtype, "P3 ");
  if (!strcmp(oldtype, "S  "))
    strcpy(newtype, "S3 ");
  if (!strcmp(oldtype, "Si "))
    strcpy(newtype, "SI ");
  if (!strcmp(oldtype, "P  "))
    strcpy(newtype, "P4 ");
  if (!strcmp(oldtype, "A  "))
    strcpy(newtype, "A  ");
  if (!strcmp(oldtype, "Q  "))
    strcpy(newtype, "Q  ");
  return strcpy(Result, newtype);
}


Static Char *get_element(Char *Result, Char *oldtype)
{
  Char elemstr[256];

  if (!strcmp(oldtype, "H   "))
    strcpy(elemstr, "H ");
  if (!strcmp(oldtype, "CAR "))
    strcpy(elemstr, "C ");
  if (!strcmp(oldtype, "C2  "))
    strcpy(elemstr, "C ");
  if (!strcmp(oldtype, "C3  "))
    strcpy(elemstr, "C ");
  if (!strcmp(oldtype, "C1  "))
    strcpy(elemstr, "C ");
  if (!strcmp(oldtype, "O2  "))
    strcpy(elemstr, "O ");
  if (!strcmp(oldtype, "O3  "))
    strcpy(elemstr, "O ");
  if (!strcmp(oldtype, "O2  "))
    strcpy(elemstr, "O ");
  if (!strcmp(oldtype, "O3  "))
    strcpy(elemstr, "O ");
  if (!strcmp(oldtype, "O3  "))
    strcpy(elemstr, "O ");
  if (!strcmp(oldtype, "N1  "))
    strcpy(elemstr, "N ");
  if (!strcmp(oldtype, "N2  "))
    strcpy(elemstr, "N ");
  if (!strcmp(oldtype, "N3  "))
    strcpy(elemstr, "N ");
  if (!strcmp(oldtype, "NPL "))
    strcpy(elemstr, "N ");
  if (!strcmp(oldtype, "N3+ "))
    strcpy(elemstr, "N ");
  if (!strcmp(oldtype, "NAM "))
    strcpy(elemstr, "N ");
  if (!strcmp(oldtype, "NAR "))
    strcpy(elemstr, "N ");
  if (!strcmp(oldtype, "F   "))
    strcpy(elemstr, "F ");
  if (!strcmp(oldtype, "CL  "))
    strcpy(elemstr, "CL");
  if (!strcmp(oldtype, "BR  "))
    strcpy(elemstr, "BR");
  if (!strcmp(oldtype, "I   "))
    strcpy(elemstr, "I ");
  if (!strcmp(oldtype, "AL  "))
    strcpy(elemstr, "AL");
  if (!strcmp(oldtype, "DU  "))
    strcpy(elemstr, "DU");
  if (!strcmp(oldtype, "CA  "))
    strcpy(elemstr, "CA");
  if (!strcmp(oldtype, "DU  "))
    strcpy(elemstr, "DU");
  if (!strcmp(oldtype, "Cl  "))
    strcpy(elemstr, "CL");
  if (!strcmp(oldtype, "K   "))
    strcpy(elemstr, "K ");
  if (!strcmp(oldtype, "LI  "))
    strcpy(elemstr, "LI");
  if (!strcmp(oldtype, "LP  "))
    strcpy(elemstr, "LP");
  if (!strcmp(oldtype, "NA  "))
    strcpy(elemstr, "NA");
  if (!strcmp(oldtype, "P3  "))
    strcpy(elemstr, "P ");
  if (!strcmp(oldtype, "S2  "))
    strcpy(elemstr, "S ");
  if (!strcmp(oldtype, "S3  "))
    strcpy(elemstr, "S ");
  if (!strcmp(oldtype, "SO  "))
    strcpy(elemstr, "S ");
  if (!strcmp(oldtype, "SO2 "))
    strcpy(elemstr, "S ");
  if (!strcmp(oldtype, "SI  "))
    strcpy(elemstr, "SI");
  if (!strcmp(oldtype, "P4  "))
    strcpy(elemstr, "P ");
  if (!strcmp(oldtype, "A   "))
    strcpy(elemstr, "A ");
  if (!strcmp(oldtype, "Q   "))
    strcpy(elemstr, "Q ");
  return strcpy(Result, elemstr);
/* p2c: checkmol3l.pas, line 1279:
 * Note: Possible string truncation in assignment [145] */
}


Static Char *get_sybelement(Char *Result, Char *oldtype)
{
  short i;
  str2 elemstr;

  if (strpos2(oldtype, ".", 1) < 2) {
    sprintf(elemstr, "%.2s", oldtype);
/* p2c: checkmol3l.pas, line 1290:
 * Note: Possible string truncation in assignment [145] */
  } else {
    sprintf(elemstr, "%.*s", strpos2(oldtype, ".", 1) - 1, oldtype);
/* p2c: checkmol3l.pas, line 1293:
 * Note: Possible string truncation in assignment [145] */
    if (strlen(elemstr) < 2) {
      strcat(elemstr, " ");
/* p2c: checkmol3l.pas, line 1294:
 * Note: Possible string truncation in assignment [145] */
    }
  }
  for (i = 0; i <= 1; i++)
    elemstr[i] = toupper(elemstr[i]);
  return strcpy(Result, elemstr);
}


Static Char *get_MDLelement(Char *Result, Char *oldtype)
{
  short i;
  str2 elemstr;

  sprintf(elemstr, "%.2s", oldtype);
/* p2c: checkmol3l.pas, line 1306:
 * Note: Possible string truncation in assignment [145] */
  for (i = 0; i <= 1; i++)
    elemstr[i] = toupper(elemstr[i]);
  if (elemstr[0] == '~')
    strcpy(elemstr, "??");
  if (elemstr[0] == '*')
    strcpy(elemstr, "??");
  return strcpy(Result, elemstr);
}


Static void read_molfile(Char *mfilename)
{
  /* reads ALCHEMY mol files*/
  short n, code;
  Char rline[256], tmpstr[256];
  Char xstr[256], ystr[256], zstr[256], chgstr[256];
  float xval, yval, zval, chgval;
  Char a1str[256], a2str[256], elemstr[256];
  short a1val, a2val, ri;
  Char STR1[256];
  short FORLIM;
  atom_rec *WITH;
  bond_rec *WITH1;

  if (n_atoms > 0)
    zap_molecule();
  ri = li;
  strcpy(rline, molbuf[ri-1]);
  sprintf(tmpstr, "%.5s", rline);
  code = (sscanf(tmpstr, "%d", &n_atoms) == 0);
  strsub(tmpstr, rline, 14, 5);
  code = (sscanf(tmpstr, "%d", &n_bonds) == 0);
  strsub(molname, rline, 42, strlen(rline) - 42);
  atom = Malloc(n_atoms * sizeof(atom_rec));
  memset(atom, 0, n_atoms * sizeof(atom_rec));
      /* blank out all atom records with 0 at once; v0.3l*/
  bond = Malloc(n_bonds * sizeof(bond_rec));
  ring = Malloc(sizeof(ringlist));
  ringprop = Malloc(sizeof(ringprop_type));
  n_heavyatoms = 0;
  n_heavybonds = 0;
  n_Ctot = 0;   /* v0.3g*/
  n_Otot = 0;   /* v0.3g*/
  n_Ntot = 0;   /* v0.3g*/
  FORLIM = n_atoms;
  for (n = 1; n <= FORLIM; n++) {
    ri++;
    strcpy(rline, molbuf[ri-1]);
    strsub(atomtype, rline, 7, 4);
    sprintf(STR1, "%c", toupper(*atomtype));
    strcpy(atomtype, STR1);   /* fixed in v0.3f*/
    get_element(elemstr, atomtype);
    if (!strcmp(elemstr, "C "))
      n_Ctot++;
    if (!strcmp(elemstr, "O "))
      n_Otot++;
    if (!strcmp(elemstr, "N "))
      n_Ntot++;
    convert_type(newatomtype, atomtype);
    strsub(xstr, rline, 14, 7);
    strsub(ystr, rline, 23, 7);
    strsub(zstr, rline, 32, 7);
    strsub(chgstr, rline, 43, 7);
    code = (sscanf(xstr, "%lg", &xval) == 0);
    code = (sscanf(ystr, "%lg", &yval) == 0);
    code = (sscanf(zstr, "%lg", &zval) == 0);
    code = (sscanf(chgstr, "%lg", &chgval) == 0);
    WITH = &atom[n-1];
    strcpy(WITH->element, elemstr);
/* p2c: checkmol3l.pas, line 1379:
 * Note: Possible string truncation in assignment [145] */
    strcpy(WITH->atype, newatomtype);
    WITH->x = xval;
    WITH->y = yval;
    WITH->z = zval;
    WITH->real_charge = chgval;
    if (is_heavyatom(n)) {
      n_heavyatoms++;
      WITH->heavy = true;
      if (is_metal(n))
	WITH->metal = true;
    }
  }
  /*
  with atom^[n] do
    begin
      x := 0; y := 0; z := 0;  { v0.3g}
      formal_charge  := 0;
      real_charge    := 0;
      Hexp           := 0;
      Htot           := 0;
      neighbor_count := 0;
      ring_count     := 0;
      arom           := false;
      stereo_care    := false;
      heavy          := false;
      metal          := false;
    end;
  */
  FORLIM = n_bonds;
  for (n = 0; n <= FORLIM - 1; n++) {
    ri++;
    strcpy(rline, molbuf[ri-1]);
    strsub(a1str, rline, 9, 3);
    strsub(a2str, rline, 15, 3);
    code = (sscanf(a1str, "%d", &a1val) == 0);
    /*if code <> 0 then beep;*/
    code = (sscanf(a2str, "%d", &a2val) == 0);
    /*if code <> 0 then beep;*/
    WITH1 = &bond[n];
    WITH1->a1 = a1val;
    WITH1->a2 = a2val;
    WITH1->btype = rline[19];
    WITH1->ring_count = 0;
    WITH1->arom = false;
    WITH1->topo = btopo_any;
    WITH1->stereo = bstereo_any;
    if (atom[a1val-1].heavy && atom[a2val-1].heavy)
      n_heavybonds++;
  }
  memset(ring, 0, sizeof(ringlist));
  for (n = 0; n <= max_rings - 1; n++) {   /* new in v0.3*/
    ringprop[n].size = 0;
    ringprop[n].arom = false;
    ringprop[n].envelope = false;
  }
  li = ri + 1;
}


Static void read_mol2file(Char *mfilename)
{
  /* reads SYBYL mol2 files*/
  short n, code;
  Char sybatomtype[6];
  Char tmpstr[256], rline[256];
  Char xstr[256], ystr[256], zstr[256], chgstr[256];
  float xval, yval, zval, chgval;
  Char a1str[256], a2str[256], elemstr[256];
  short a1val, a2val, ri, FORLIM;
  atom_rec *WITH;
  bond_rec *WITH1;

  if (n_atoms > 0)
    zap_molecule();
  *rline = '\0';
  ri = li - 1;
  while (ri < molbufindex && strpos2(rline, "@<TRIPOS>MOLECULE", 1) == 0) {
    ri++;
    strcpy(rline, molbuf[ri-1]);
  }
  if (ri < molbufindex) {
    ri++;
    strcpy(molname, molbuf[ri-1]);
  }
  if (ri < molbufindex) {
    ri++;
    strcpy(rline, molbuf[ri-1]);
  }
  sprintf(tmpstr, "%.5s", rline);
  sscanf(tmpstr, "%d", &n_atoms);
/* p2c: checkmol3l.pas:
 * Note: Eliminated unused assignment statement [338] */
  strsub(tmpstr, rline, 7, 5);
  sscanf(tmpstr, "%d", &n_bonds);
/* p2c: checkmol3l.pas:
 * Note: Eliminated unused assignment statement [338] */
  atom = Malloc(n_atoms * sizeof(atom_rec));
  memset(atom, 0, n_atoms * sizeof(atom_rec));
      /* blank out all atom records with 0 at once; v0.3l*/
  bond = Malloc(n_bonds * sizeof(bond_rec));
  ring = Malloc(sizeof(ringlist));
  ringprop = Malloc(sizeof(ringprop_type));
  n_heavyatoms = 0;
  n_heavybonds = 0;
  n_Ctot = 0;   /* v0.3g*/
  n_Otot = 0;   /* v0.3g*/
  n_Ntot = 0;   /* v0.3g*/
  while (ri < molbufindex && strpos2(rline, "@<TRIPOS>ATOM", 1) == 0) {
    ri++;
    strcpy(rline, molbuf[ri-1]);
  }
  FORLIM = n_atoms;
  for (n = 1; n <= FORLIM; n++) {
    /*
    with atom^[n] do
      begin
        x := 0; y := 0; z := 0;  { v0.3g}
        formal_charge  := 0;
        real_charge    := 0;
        Hexp           := 0;
        Htot           := 0;
        neighbor_count := 0;
        ring_count     := 0;
        arom           := false;
        stereo_care    := false;
        heavy          := false;
        metal          := false;
      end;
    */
    if (ri < molbufindex) {
      ri++;
      strcpy(rline, molbuf[ri-1]);
    }
    strsub(sybatomtype, rline, 48, 5);
    get_sybelement(elemstr, sybatomtype);
    if (!strcmp(elemstr, "C "))
      n_Ctot++;
    if (!strcmp(elemstr, "O "))
      n_Otot++;
    if (!strcmp(elemstr, "N "))
      n_Ntot++;
    convert_sybtype(newatomtype, sybatomtype);
    strsub(xstr, rline, 18, 9);
    strsub(ystr, rline, 28, 9);
    strsub(zstr, rline, 38, 9);
    strsub(chgstr, rline, 70, 9);
/* p2c: checkmol3l.pas:
 * Note: Eliminated unused assignment statement [338] */
/* p2c: checkmol3l.pas:
 * Note: Eliminated unused assignment statement [338] */
    sscanf(xstr, "%lg", &xval);
    sscanf(ystr, "%lg", &yval);
    sscanf(zstr, "%lg", &zval);
    sscanf(chgstr, "%lg", &chgval);
/* p2c: checkmol3l.pas:
 * Note: Eliminated unused assignment statement [338] */
/* p2c: checkmol3l.pas:
 * Note: Eliminated unused assignment statement [338] */
    WITH = &atom[n-1];
    strcpy(WITH->element, elemstr);
/* p2c: checkmol3l.pas, line 1505:
 * Note: Possible string truncation in assignment [145] */
    strcpy(WITH->atype, newatomtype);
    WITH->x = xval;
    WITH->y = yval;
    WITH->z = zval;
    WITH->real_charge = chgval;
    if (is_heavyatom(n)) {
      n_heavyatoms++;
      WITH->heavy = true;
      if (is_metal(n))
	WITH->metal = true;
    }
  }
  while (ri < molbufindex && strpos2(rline, "@<TRIPOS>BOND", 1) == 0) {
    ri++;
    strcpy(rline, molbuf[ri-1]);
  }
  FORLIM = n_bonds;
  for (n = 0; n <= FORLIM - 1; n++) {
    if (ri < molbufindex) {
      ri++;
      strcpy(rline, molbuf[ri-1]);
    }
    strsub(a1str, rline, 9, 3);
    strsub(a2str, rline, 14, 3);
    code = (sscanf(a1str, "%d", &a1val) == 0);
    if (code != 0)
      printf("%s\007\n", rline);
    code = (sscanf(a2str, "%d", &a2val) == 0);
    if (code != 0)
      printf("%s\007\n", rline);
    WITH1 = &bond[n];
    WITH1->a1 = a1val;
    WITH1->a2 = a2val;
    if (rline[17] == '1')
      WITH1->btype = 'S';
    if (rline[17] == '2')
      WITH1->btype = 'D';
    if (rline[17] == '3')
      WITH1->btype = 'T';
    if (rline[17] == 'a')
      WITH1->btype = 'A';
    WITH1->ring_count = 0;
    WITH1->arom = false;
    WITH1->topo = btopo_any;
    WITH1->stereo = bstereo_any;
    if (atom[a1val-1].heavy && atom[a2val-1].heavy)
      n_heavybonds++;
  }
  memset(ring, 0, sizeof(ringlist));
  for (n = 0; n <= max_rings - 1; n++) {   /* new in v0.3*/
    ringprop[n].size = 0;
    ringprop[n].arom = false;
    ringprop[n].envelope = false;
  }
  li = ri + 1;
}


Static void read_charges(Char *chgstring_)
{
  Char chgstring[256];
  short a_id, a_chg, n_chrg;

  /* typical example: a molecule with 2 cations + 1 anion*/
  /* M  CHG  3   8   1  10   1  11  -1*/
  strcpy(chgstring, chgstring_);
  if (strpos2(chgstring, "M  CHG", 1) <= 0)
    return;
  strdelete((void *)chgstring, 1, 6);
  left_trim(chgstring);
  n_chrg = left_int(chgstring);
      /* this assignment must be kept also in non-debug mode!*/
  /*{$IFDEF debug
  if (n_chrg = 0) then debugoutput('strange... M  CHG present, but no charges found');
  $ENDIF*/
  while (*chgstring != '\0') {
    a_id = left_int(chgstring);
    a_chg = left_int(chgstring);
    if (a_id != 0 && a_chg != 0)
      atom[a_id-1].formal_charge = a_chg;
  }
}


Static void read_MDLmolfile(Char *mfilename)
{
  /* reads MDL mol files*/
  short n, v, tmp_n_atoms, tmp_n_bonds, code;   /* v0.3l*/
  Char rline[256], tmpstr[256];
  Char xstr[256], ystr[256], zstr[256], chgstr[256];
  float xval, yval, zval, chgval;
  Char a1str[256], a2str[256], elemstr[256];
  short a1val, a2val, ri, rc, bt, bs;
  short sepcount = 0;
  short i;   /* v0.3j*/
  boolean clearcharges = true;   /* v0.3j*/
  Char STR1[256];
  short FORLIM;
  atom_rec *WITH;
  bond_rec *WITH1;

  /* v0.3j*/
  if (n_atoms > 0)
    zap_molecule();
  /*cm_mdlmolfile := false;*/
  *rline = '\0';
  ri = li;
  strcpy(molname, molbuf[ri-1]);   /* line 1*/
  if (ri < molbufindex)   /* line 2*/
    ri++;
  strcpy(rline, molbuf[ri-1]);
  if (strpos2(rline, "CheckMol", 1) == 3) {
    /*cm_mdlmolfile := true;*/
    found_arominfo = true;
  }
  if (ri < molbufindex)   /* line 3*/
    ri++;
  strcpy(rline, molbuf[ri-1]);
  strcpy(molcomment, rline);
  if (ri < molbufindex)   /* line 4*/
    ri++;
  strcpy(rline, molbuf[ri-1]);
  sprintf(tmpstr, "%.3s", rline);
  sscanf(tmpstr, "%d", &n_atoms);
/* p2c: checkmol3l.pas:
 * Note: Eliminated unused assignment statement [338] */
  strsub(tmpstr, rline, 4, 3);
  sscanf(tmpstr, "%d", &n_bonds);
/* p2c: checkmol3l.pas:
 * Note: Eliminated unused assignment statement [338] */
  strsub(tmpstr, rline, 10, 3);
      /* if it is a CheckMol-tweaked molfile, this is the number of rings*/
  n_cmrings = 0;
  code = (sscanf(tmpstr, "%d", &n_cmrings) == 0);
  if (code != 0)
    n_cmrings = 0;
  /* do some range checking for n_atoms, n_bonds; new in v0.3l*/
  tmp_n_atoms = n_atoms;
  if (n_atoms > max_atoms)
    n_atoms = max_atoms;
  if (n_atoms < 0)
    n_atoms = 0;
  tmp_n_bonds = n_bonds;
  if (n_bonds > max_bonds)
    n_bonds = max_bonds;
  if (n_bonds < 0)
    n_bonds = 0;
  if (n_atoms == 0 && opt_verbose) {   /* v0.3l*/
    printf("WARNING: Possible NoStruct read!\n");
    printf("NoStructs are proprietary, obsolete and dangerous.\n");
  }
  atom = Malloc(n_atoms * sizeof(atom_rec));
  memset(atom, 0, n_atoms * sizeof(atom_rec));
      /* blank out all atom records with 0 at once;*/
  bond = Malloc(n_bonds * sizeof(bond_rec));
      /* this would be only one calloc() in C;  v0.3l*/
  ring = Malloc(sizeof(ringlist));
  ringprop = Malloc(sizeof(ringprop_type));
  /* check for the chirality flag*/
  if (strlen(rline) > 14 && rline[14] == '1')   /* new in v0.3f*/
    chir_flag = true;
  n_heavyatoms = 0;
  n_heavybonds = 0;
  n_Ctot = 0;   /* v0.3g*/
  n_Otot = 0;   /* v0.3g*/
  n_Ntot = 0;   /* v0.3g*/
  if (n_atoms > 0) {   /* v0.3l*/
    for (n = 1; n <= tmp_n_atoms; n++) {
      if (n <= max_atoms)
	v = n;
      else
	v = max_atoms;
      /* just for safety; v0.3l*/
      /*
      with atom^[v] do
        begin
          x := 0; y := 0; z := 0;  { v0.3g}
          formal_charge  := 0;
          real_charge    := 0;
          Hexp           := 0;
          Htot           := 0;
          neighbor_count := 0;
          ring_count     := 0;
          arom           := false;
          stereo_care    := false;
          metal          := false;
          heavy          := false;
        end;
      */
      /* replaced by fillchar() after getmem() (see above); v0.3l*/
      ri++;
      strcpy(rline, molbuf[ri-1]);
      strsub(atomtype, rline, 32, 3);
      get_MDLelement(elemstr, atomtype);
      if (!strcmp(elemstr, "C "))
	n_Ctot++;
      if (!strcmp(elemstr, "O "))
	n_Otot++;
      if (!strcmp(elemstr, "N "))
	n_Ntot++;
      convert_MDLtype(newatomtype, atomtype);
      sprintf(xstr, "%.10s", rline);   /* fixed in v0.3k (was: 2,9 etc.)*/
      strsub(ystr, rline, 11, 10);
      strsub(zstr, rline, 21, 10);
      /*chgstr := '0';*/
      strsub(chgstr, rline, 37, 3);   /* new in v0.3j*/
      sscanf(chgstr, "%lg", &chgval);
/* p2c: checkmol3l.pas:
 * Note: Eliminated unused assignment statement [338] */
      if (chgval != 0) {
	if (chgval >= 1 && chgval <= 7)
	  chgval = 4.0 - chgval;
	else {
	  chgval = 0.0;
/* p2c: checkmol3l.pas:
 * Note: Eliminated unused assignment statement [338] */
	}
      }  /* end (v0.3j)*/
      sscanf(xstr, "%lg", &xval);
      sscanf(ystr, "%lg", &yval);
      sscanf(zstr, "%lg", &zval);
      /* v0.3k: removed superfluous val(chgstr,chgval,code)*/
/* p2c: checkmol3l.pas:
 * Note: Eliminated unused assignment statement [338] */
/* p2c: checkmol3l.pas:
 * Note: Eliminated unused assignment statement [338] */
      WITH = &atom[v-1];
      strcpy(WITH->element, elemstr);
/* p2c: checkmol3l.pas, line 1689:
 * Note: Possible string truncation in assignment [145] */
      if (!strcmp(elemstr, "A ") || !strcmp(elemstr, "Q "))
	found_querymol = true;
      strcpy(WITH->atype, newatomtype);
      WITH->x = xval;
      WITH->y = yval;
      WITH->z = zval;
      WITH->formal_charge = (long)floor(chgval + 0.5);
      WITH->real_charge = 0.0;   /* v0.3j*/
      /* read aromaticity flag from CheckMol-tweaked MDL molfile*/
      if (strlen(rline) > 37 && rline[37] == '0') {
	WITH->arom = true;
	found_arominfo = true;
      }
      /* new in v0.3d: read stereo care flag*/
      if (strlen(rline) > 47 && rline[47] == '1')
	WITH->stereo_care = true;
      if (is_heavyatom(n)) {
	n_heavyatoms++;
	WITH->heavy = true;
	if (is_metal(n))
	  WITH->metal = true;
      }
    }
  }  /* if (n_atoms > 0)...*/
  if (n_bonds > 0) {   /* v0.3l*/
    for (n = 1; n <= tmp_n_bonds; n++) {
      if (n <= max_bonds)
	v = n;
      else
	v = max_bonds;
      /* just for safety; v0.3l*/
      ri++;
      strcpy(rline, molbuf[ri-1]);
      sprintf(a1str, "%.3s", rline);
      strsub(a2str, rline, 4, 3);
      code = (sscanf(a1str, "%d", &a1val) == 0);
      if (code != 0)   /* v0.3l*/
	a1val = 1;
      code = (sscanf(a2str, "%d", &a2val) == 0);
      if (code != 0)   /* v0.3l*/
	a2val = 1;
      WITH1 = &bond[v-1];
      WITH1->a1 = a1val;
      WITH1->a2 = a2val;
      if (rline[8] == '1')   /* single*/
	WITH1->btype = 'S';
      if (rline[8] == '2')   /* double*/
	WITH1->btype = 'D';
      if (rline[8] == '3')   /* triple*/
	WITH1->btype = 'T';
      if (rline[8] == '4')   /* aromatic*/
	WITH1->btype = 'A';
      if (rline[8] == '5')   /* single or double*/
	WITH1->btype = 'l';
      if (rline[8] == '6')   /* single or aromatic*/
	WITH1->btype = 's';
      if (rline[8] == '7')   /* double or aromatic*/
	WITH1->btype = 'd';
      if (rline[8] == '8')   /* any*/
	WITH1->btype = 'a';
      sprintf(STR1, "%c", WITH1->btype);
      if (strpos2("lsda", STR1, 1) > 0)
	found_querymol = true;
      WITH1->arom = false;
      /* read aromaticity flag from CheckMol-tweaked MDL molfile*/
      if (WITH1->btype == 'A' || rline[7] == '0') {
	WITH1->arom = true;
	if (rline[7] == '0')
	  found_arominfo = true;
      }
      strsub(tmpstr, rline, 13, 3);
	  /* new in v0.3d: read ring_count from tweaked molfile*/
      code = (sscanf(tmpstr, "%d", &rc) == 0);
      if (code != 0 || rc < 0 || progmode == pmCheckMol)
	WITH1->ring_count = 0;
      else
	WITH1->ring_count = rc;
      strsub(tmpstr, rline, 16, 3);   /* new in v0.3d: read bond topology;*/
      code = (sscanf(tmpstr, "%d", &bt) == 0);
	  /* extended features are encoded by leading zero*/
      if (code != 0 || (unsigned)bt > 5)
	WITH1->topo = btopo_any;
      else {
	if (tmpstr[1] == '0')
	  WITH1->topo = bt + 3;
	else
	  WITH1->topo = bt;
      }
      /* new in v0.3d: add stereo property from MDL "stereo care" flag in atom block*/
      WITH1->stereo = bstereo_any;
      if (WITH1->btype == 'D') {
	if (atom[WITH1->a1 - 1].stereo_care && atom[WITH1->a2 - 1].stereo_care)
	{  /* this is the MDL-conformant encoding,*/
	  WITH1->stereo = bstereo_xyz;   /* for an alternative see below*/
	  ez_flag = true;   /* v0.3f*/
	} else {   /* this extended feature is encoded by a leading zero*/
	  strsub(tmpstr, rline, 10, 3);
	      /* new in v0.3d: read bond stereo specification;*/
	  code = (sscanf(tmpstr, "%d", &bs) == 0);
	  if (code != 0 || bs <= 0 || bs > 2)
	    WITH1->stereo = bstereo_any;
	  else
	    WITH1->stereo = bstereo_xyz;
	  if (tmpstr[1] == '0')
	    WITH1->stereo = bstereo_xyz;
	}
      }
      /*if stereo <> bstereo_any then ez_search := true;*/
      if (WITH1->stereo != bstereo_any)   /* changed in v0.3f*/
	ez_flag = true;
      if (WITH1->btype == 'S' && strlen(rline) > 11 && rline[11] == '1')
	WITH1->stereo = bstereo_up;
      if (WITH1->btype == 'S' && strlen(rline) > 11 && rline[11] == '6')
	WITH1->stereo = bstereo_down;
      if (atom[a1val-1].heavy && atom[a2val-1].heavy)
	n_heavybonds++;
    }
  }  /* if (n_bonds > 0)...*/
  while (ri < molbufindex && sepcount < 1) {
    ri++;
    strcpy(rline, molbuf[ri-1]);
    if (strpos2(rline, "M  CHG", 1) > 0) {  /* new in v0.3j*/
      if (clearcharges)
      {   /* "M  CHG" supersedes all "old-style" charge values*/
	FORLIM = n_atoms;
	for (i = 0; i <= FORLIM - 1; i++)
	  atom[i].formal_charge = 0;
      }
      read_charges(rline);
      clearcharges = false;
	  /* subsequent "M  CHG" lines must not clear previous values*/
    }
    if (strpos2(rline, "$$$$", 1) > 0) {
      sepcount++;
      if (molbufindex > ri + 2)   /* we assume this is an SDF file*/
	mol_in_queue = true;
    }
  }
  memset(ring, 0, sizeof(ringlist));
  for (n = 0; n <= max_rings - 1; n++) {   /* new in v0.3*/
    ringprop[n].size = 0;
    ringprop[n].arom = false;
    ringprop[n].envelope = false;
  }
  li = ri + 1;
}


Static void lblank(short cols, Char *nstr)
{
  /* inserts leading blanks up to a given number of total characters*/
  Char STR1[256];

  if (strlen(nstr) >= cols)
    return;
  while (strlen(nstr) < cols)
    sprintf(nstr, " %s", strcpy(STR1, nstr));
}


Static void write_MDLmolfile(void)
{
  short i;
  Char tmpstr[256];
  Char wline[256];
  short a_chg;
  Char STR1[256];
  short FORLIM;

  if (strlen(molname) > 80)
    sprintf(molname, "%.80s", strcpy(STR1, molname));
  puts(molname);
  printf("  CheckMol  \n");
  puts(molcomment);
  *wline = '\0';
  *tmpstr = '\0';
  sprintf(tmpstr, "%d", n_atoms);
  lblank(3, tmpstr);
  strcat(wline, tmpstr);
  *tmpstr = '\0';   /* first 3 digits: number of atoms*/
  sprintf(tmpstr, "%d", n_bonds);
  lblank(3, tmpstr);
  strcat(wline, tmpstr);
  *tmpstr = '\0';   /* next 3 digits: number of bonds*/
  strcpy(tmpstr, "  0");
  strcat(wline, tmpstr);
  *tmpstr = '\0';   /* next 3 digits: number of atom lists (not used by us)*/
  sprintf(tmpstr, "%d", n_rings);
  lblank(3, tmpstr);
  strcat(wline, tmpstr);
  *tmpstr = '\0';
      /* officially "obsolete", we use it for the number of rings*/
  strcat(wline, "                  999 V2000");
  puts(wline);
  FORLIM = n_atoms;
  for (i = 0; i <= FORLIM - 1; i++) {
    *wline = '\0';
    sprintf(tmpstr, "%1.4f", atom[i].x);
    lblank(10, tmpstr);
    strcat(wline, tmpstr);
    sprintf(tmpstr, "%1.4f", atom[i].y);
    lblank(10, tmpstr);
    strcat(wline, tmpstr);
    sprintf(tmpstr, "%1.4f", atom[i].z);
    lblank(10, tmpstr);
    strcat(wline, tmpstr);
    strcpy(tmpstr, atom[i].element);
    /*tmpstr := lowercase(tmpstr); FIXME*/
    tmpstr[0] = toupper(tmpstr[0]);
    /*wline := wline + ' '+atom^[i].element+' ';*/
    sprintf(wline + strlen(wline), " %s ", tmpstr);
    strcat(wline, " 0");   /* mass difference (isotopes)*/
    /* now we code aromaticity into the old-style charge column (charges are now in the M  CHG line)*/
    if (atom[i].arom)
      strcpy(tmpstr, " 00");
    else
      strcpy(tmpstr, "  0");
    strcat(wline, tmpstr);
    strcat(wline, "  0  0  0  0  0  0  0  0  0  0");
    puts(wline);
  }
  FORLIM = n_bonds;
  for (i = 0; i <= FORLIM - 1; i++) {
    *wline = '\0';
    sprintf(tmpstr, "%d", bond[i].a1);
    lblank(3, tmpstr);
    strcat(wline, tmpstr);
    sprintf(tmpstr, "%d", bond[i].a2);
    lblank(3, tmpstr);
    strcat(wline, tmpstr);
    if (bond[i].btype == 'S')
      strcpy(tmpstr, "  1");
    if (bond[i].btype == 'D')
      strcpy(tmpstr, "  2");
    if (bond[i].btype == 'T')
      strcpy(tmpstr, "  3");
    if (bond[i].btype == 'A')
      strcpy(tmpstr, "  4");
    if (bond[i].btype == 'l')
      strcpy(tmpstr, "  5");
    if (bond[i].btype == 's')
      strcpy(tmpstr, "  6");
    if (bond[i].btype == 'd')
      strcpy(tmpstr, "  7");
    if (bond[i].btype == 'a')
      strcpy(tmpstr, "  8");
    /* now encode our own aromaticity information*/
    if (bond[i].arom)
      tmpstr[1] = '0';
    strcat(wline, tmpstr);   /* next, encode bond stereo property (v0.3f)*/
    if (bond[i].stereo == bstereo_up)
      strcat(wline, "  1");
    else {
      if (bond[i].stereo == bstereo_down)
	strcat(wline, "  6");
      else
	strcat(wline, "  0");
    }
    *tmpstr = '\0';
    /* now encode the ring_count of this bond (using a field which officially is "not used")*/
    /*tmpstr := inttostr(bond^[i].ring_count); FIXME*/
    while (strlen(tmpstr) < 3)
      sprintf(tmpstr, " %s", strcpy(STR1, tmpstr));
    sprintf(wline + strlen(wline), "%s  0  0", tmpstr);
    puts(wline);
  }
  FORLIM = n_atoms;
  for (i = 1; i <= FORLIM; i++) {
    a_chg = atom[i-1].formal_charge;
    if (a_chg != 0) {
      strcpy(wline, "M  CHG  1 ");
      sprintf(tmpstr, "%d", i);
      lblank(3, tmpstr);
      sprintf(wline + strlen(wline), "%s ", tmpstr);
      sprintf(tmpstr, "%d", a_chg);
      lblank(3, tmpstr);
      strcat(wline, tmpstr);
      puts(wline);
    }
  }
  printf("M  END\n");
}


/*============= chemical processing functions & procedures ============*/

Static short nvalences(Char *a_el)
{
  /* preliminary version; should be extended to element/atomtype*/
  short res = 1;

  if (!strcmp(a_el, "H "))
    res = 1;
  if (!strcmp(a_el, "C "))
    res = 4;
  if (!strcmp(a_el, "N "))
    res = 3;
  if (!strcmp(a_el, "O "))
    res = 2;
  if (!strcmp(a_el, "S "))
    res = 2;
  if (!strcmp(a_el, "SE"))
    res = 2;
  if (!strcmp(a_el, "TE"))
    res = 2;
  if (!strcmp(a_el, "P "))
    res = 3;
  if (!strcmp(a_el, "F "))
    res = 1;
  if (!strcmp(a_el, "CL"))
    res = 1;
  if (!strcmp(a_el, "BR"))
    res = 1;
  if (!strcmp(a_el, "I "))
    res = 1;
  if (!strcmp(a_el, "B "))
    res = 3;
  if (!strcmp(a_el, "LI"))
    res = 1;
  if (!strcmp(a_el, "NA"))
    res = 1;
  if (!strcmp(a_el, "K "))
    res = 1;
  if (!strcmp(a_el, "CA"))
    res = 2;
  if (!strcmp(a_el, "SR"))
    res = 2;
  if (!strcmp(a_el, "MG"))
    res = 2;
  if (!strcmp(a_el, "FE"))
    res = 3;
  if (!strcmp(a_el, "MN"))
    res = 2;
  if (!strcmp(a_el, "HG"))
    res = 2;
  if (!strcmp(a_el, "SI"))
    res = 4;
  if (!strcmp(a_el, "SN"))
    res = 4;
  if (!strcmp(a_el, "ZN"))
    res = 2;
  if (!strcmp(a_el, "CU"))
    res = 2;
  if (!strcmp(a_el, "A "))
    res = 4;
  if (!strcmp(a_el, "Q "))
    res = 4;

  return res;
}


Static boolean is_electroneg(Char *a_el)
{
  /* new in v0.3j*/
  boolean res = false;

  if (!strcmp(a_el, "N "))
    res = true;
  if (!strcmp(a_el, "P "))
    res = true;
  if (!strcmp(a_el, "O "))
    res = true;
  if (!strcmp(a_el, "S "))
    res = true;
  if (!strcmp(a_el, "SE"))
    res = true;
  if (!strcmp(a_el, "TE"))
    res = true;
  if (!strcmp(a_el, "F "))
    res = true;
  if (!strcmp(a_el, "CL"))
    res = true;
  if (!strcmp(a_el, "BR"))
    res = true;
  if (!strcmp(a_el, "I "))
    res = true;
  return res;
}


Static void count_neighbors(void)
{
  /* counts heavy-atom neighbors and explicit hydrogens*/
  short i, FORLIM;

  if (n_atoms < 1 || n_bonds < 1)
    return;
  FORLIM = n_bonds;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (atom[bond[i].a1 - 1].heavy)
      atom[bond[i].a2 - 1].neighbor_count++;
    if (atom[bond[i].a2 - 1].heavy)
      atom[bond[i].a1 - 1].neighbor_count++;
    if (!strcmp(atom[bond[i].a1 - 1].element, "H "))
      atom[bond[i].a2 - 1].Hexp++;
    if (!strcmp(atom[bond[i].a2 - 1].element, "H "))
      atom[bond[i].a1 - 1].Hexp++;
    /* plausibility check (new in v02.i)*/
    if (atom[bond[i].a1 - 1].neighbor_count > max_neighbors ||
	atom[bond[i].a2 - 1].neighbor_count > max_neighbors) {
      mol_OK = false;
      /*writeln('invalid molecule!');*/
    }
  }
}


Static short *get_neighbors(short *Result, short id)
{
  short i;
  neighbor_rec nb_tmp;
  short nb_count = 0;
  short FORLIM;

  memset(nb_tmp, 0, sizeof(neighbor_rec));
  FORLIM = n_bonds;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (bond[i].a1 == id && nb_count < max_neighbors &&
	atom[bond[i].a2 - 1].heavy) {
      nb_count++;
      nb_tmp[nb_count-1] = bond[i].a2;
    }
    if (bond[i].a2 == id && nb_count < max_neighbors &&
	atom[bond[i].a1 - 1].heavy) {
      nb_count++;
      nb_tmp[nb_count-1] = bond[i].a1;
    }
  }
  return memcpy(Result, nb_tmp, sizeof(neighbor_rec));
}


Static short *get_ndl_neighbors(short *Result, short id)
{
  short i;
  neighbor_rec nb_tmp;
  short nb_count = 0;
      /* v0.3i: use max_neighbors instead of a fixed value of 8*/
  short FORLIM;

  memset(nb_tmp, 0, sizeof(neighbor_rec));
  FORLIM = ndl_n_bonds;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (ndl_bond[i].a1 == id && nb_count < max_neighbors &&
	ndl_atom[ndl_bond[i].a2 - 1].heavy) {
      nb_count++;
      nb_tmp[nb_count-1] = ndl_bond[i].a2;
    }
    if (ndl_bond[i].a2 == id && nb_count < max_neighbors &&
	ndl_atom[ndl_bond[i].a1 - 1].heavy) {
      nb_count++;
      nb_tmp[nb_count-1] = ndl_bond[i].a1;
    }
  }
  return memcpy(Result, nb_tmp, sizeof(neighbor_rec));
}


Static short *get_nextneighbors(short *Result, short id, short prev_id)
{
  short i;
  neighbor_rec nb_tmp;
  short nb_count = 0;
  short FORLIM;

  /* gets all neighbors except prev_id (usually the atom where we came from*/
  memset(nb_tmp, 0, sizeof(neighbor_rec));
  FORLIM = n_bonds;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (bond[i].a1 == id && bond[i].a2 != prev_id &&
	nb_count < max_neighbors && atom[bond[i].a2 - 1].heavy) {
      nb_count++;
      nb_tmp[nb_count-1] = bond[i].a2;
    }
    if (bond[i].a2 == id && bond[i].a1 != prev_id &&
	nb_count < max_neighbors && atom[bond[i].a1 - 1].heavy) {
      nb_count++;
      nb_tmp[nb_count-1] = bond[i].a1;
    }
  }
  return memcpy(Result, nb_tmp, sizeof(neighbor_rec));
}


Static short *get_ndl_nextneighbors(short *Result, short id, short prev_id)
{
  short i;
  neighbor_rec nb_tmp;
  short nb_count = 0;
  short FORLIM;

  /* gets all neighbors except prev_id (usually the atom where we came from*/
  memset(nb_tmp, 0, sizeof(neighbor_rec));
  FORLIM = ndl_n_bonds;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (ndl_bond[i].a1 == id && ndl_bond[i].a2 != prev_id &&
	nb_count < max_neighbors && ndl_atom[ndl_bond[i].a2 - 1].heavy) {
      nb_count++;
      nb_tmp[nb_count-1] = ndl_bond[i].a2;
    }
    if (ndl_bond[i].a2 == id && ndl_bond[i].a1 != prev_id &&
	nb_count < max_neighbors && ndl_atom[ndl_bond[i].a1 - 1].heavy) {
      nb_count++;
      nb_tmp[nb_count-1] = ndl_bond[i].a1;
    }
  }
  return memcpy(Result, nb_tmp, sizeof(neighbor_rec));
}


Static short path_pos(short id, short *a_path)
{
  /* new version in v0.3l*/
  short i;
  short pp = 0;

  for (i = 1; i <= max_ringsize; i++) {
    if (a_path[i-1] == id) {
      pp = i;
/* p2c: checkmol3l.pas, line 2095:
 * Warning: Expected a '(', found a semicolon [227] */
/* p2c: checkmol3l.pas, line 2095:
 * Warning: Expected an expression, found a semicolon [227] */
      fflush(0);
      P_ioresult = 0;
    }
  }
  return pp;
}


Static short path_length(short *a_path)
{
  if (a_path[max_ringsize-1] != 0 && path_pos(0, a_path) == 0)
    return max_ringsize;
  else
    return (path_pos(0, a_path) - 1);
}


Static short matchpath_pos(short id, short *a_path)
{
  short i;
  short pp = 0;

  for (i = max_matchpath_length; i >= 1; i--) {
    if (a_path[i-1] == id)
      pp = i;
  }
  return pp;
}


Static short matchpath_length(short *a_path)
{
  if (a_path[max_matchpath_length-1] != 0)
    return max_matchpath_length;
  else
    return (matchpath_pos(0, a_path) - 1);
}


Static short get_bond(short ba1, short ba2)
{
  short i;
  short b_id = 0;
  short FORLIM;

  if (n_bonds <= 0)
    return b_id;
  FORLIM = n_bonds;
  for (i = 1; i <= FORLIM; i++) {
    if (bond[i-1].a1 == ba1 && bond[i-1].a2 == ba2 ||
	bond[i-1].a1 == ba2 && bond[i-1].a2 == ba1)
      b_id = i;
  }
  return b_id;
}


Static short get_ndl_bond(short ba1, short ba2)
{
  short i;
  short b_id = 0;
  short FORLIM;

  if (ndl_n_bonds <= 0)
    return b_id;
  FORLIM = ndl_n_bonds;
  for (i = 1; i <= FORLIM; i++) {
    if (ndl_bond[i-1].a1 == ba1 && ndl_bond[i-1].a2 == ba2 ||
	ndl_bond[i-1].a1 == ba2 && ndl_bond[i-1].a2 == ba1)
      b_id = i;
  }
  return b_id;
}


Static void order_ringpath(short *r_path)
{
  /* order should be: array starts with atom of lowest number, followed by neighbor atom with lower number*/
  short i, pl, a_ref, a_left, a_right, a_tmp;

  pl = path_length(r_path);
  if (pl < 3)
    return;
  a_ref = n_atoms;   /* start with highest possible value for an atom number*/
  for (i = 0; i <= pl - 1; i++) {
    if (r_path[i] < a_ref)   /* find the minimum value ==> reference atom*/
      a_ref = r_path[i];
  }
  if (a_ref < 1)   /* just to be sure*/
    return;
  if (path_pos(a_ref, r_path) < pl)
    a_right = r_path[path_pos(a_ref, r_path)];
  else
    a_right = r_path[0];
  if (path_pos(a_ref, r_path) > 1)
    a_left = r_path[path_pos(a_ref, r_path) - 2];
  else
    a_left = r_path[pl-1];
  if (a_right == a_left)   /* should never happen*/
    return;
  if (a_right < a_left) {
	/* correct ring numbering direction, only shift of the reference atom to the left end required*/
	  while (path_pos(a_ref, r_path) > 1) {
      a_tmp = r_path[0];
      for (i = 1; i <= pl - 1; i++)
	r_path[i-1] = r_path[i];
      r_path[pl-1] = a_tmp;
    }
    return;
  }
  while (path_pos(a_ref, r_path) < pl) {
	/* step one: create "mirrored" ring path with reference atom at right end*/
	  a_tmp = r_path[pl-1];
    for (i = pl; i >= 2; i--)
      r_path[i-1] = r_path[i-2];
    r_path[0] = a_tmp;
  }
  for (i = 1; i <= pl / 2; i++) {  /* one more mirroring*/
    a_tmp = r_path[i-1];
    r_path[i-1] = r_path[pl - i];
    r_path[pl - i] = a_tmp;
    /* wrong ring numbering direction, two steps required*/
  }
}


Static short ringcompare(short *rp1, short *rp2)
{
  short i, j;
  short rc = 0;
  short rs1, rs2;
  short n_common = 0;
  short max_cra;

  rs1 = path_length(rp1);
  rs2 = path_length(rp2);
  if (rs1 < rs2)
    max_cra = rs1;
  else
    max_cra = rs2;
  for (i = 0; i <= rs1 - 1; i++) {
    for (j = 0; j <= rs2 - 1; j++) {
      if (rp1[i] == rp2[j])
	n_common++;
    }
  }
  if (rs1 == rs2 && n_common == max_cra) {
    rc = 0;
    return rc;
  }
  if (n_common == 0)
    rc += 8;
  if (n_common < max_cra) {
    rc += 4;
    return rc;
  }
  if (rs1 < rs2)
    rc++;
  else
    rc += 2;
  return rc;
}


Static boolean rc_identical(short rc_int)
{
  if (rc_int == 0)
    return true;
  else
    return false;
}


Static boolean rc_1in2(short rc_int)
{
  if (rc_int & 1)
    return true;
  else
    return false;
}


Static boolean rc_2in1(short rc_int)
{
  rc_int /= 2;
  if (rc_int & 1)
    return true;
  else
    return false;
}


Static boolean rc_different(short rc_int)
{
  rc_int /= 4;
  if (rc_int & 1)
    return true;
  else
    return false;
}


Static boolean rc_independent(short rc_int)
{
  rc_int /= 8;
  if (rc_int & 1)
    return true;
  else
    return false;
}


Static boolean is_newring(short *n_path)
{
  short i, j;
  boolean nr = true;
  boolean same_ring;
  ringpath_type tmp_path;
  short rc_result;
  boolean found_ring;
  short pl;   /* new in v0.3*/
  short FORLIM;

  pl = path_length(n_path);   /* new in v0.3*/
  if (n_rings <= 0)
    return true;
  switch (ringsearch_mode) {

  case rs_sar:
    found_ring = false;
    i = 0;
    while (i < n_rings && !found_ring) {
      i++;
      if (pl != ringprop[i-1].size)   /* compare only rings of same size*/
	continue;
      same_ring = true;
      for (j = 0; j <= max_ringsize - 1; j++) {
	if (ring[i-1][j] != n_path[j])
	  same_ring = false;
      }
      if (same_ring) {
	nr = false;
	found_ring = true;
      }
    }
    break;

  case rs_ssr:
    FORLIM = n_rings;
    for (i = 0; i <= FORLIM - 1; i++) {
      for (j = 0; j <= max_ringsize - 1; j++)
	tmp_path[j] = ring[i][j];
      rc_result = ringcompare(n_path, tmp_path);
      if (rc_identical(rc_result))
	nr = false;
      if (rc_1in2(rc_result)) {
	/* exchange existing ring by smaller one*/
	for (j = 0; j <= max_ringsize - 1; j++)
	  ring[i][j] = n_path[j];
	/* update ring property record (new in v0.3)*/
	ringprop[i].size = pl;
	nr = false;
	/*{$IFDEF debug
	debugoutput('replacing ring '+inttostr(i)+' by smaller one (ringsize: '+inttostr(path_length(n_path))+')');
	$ENDIF*/
      }
      if (rc_2in1(rc_result)) {
	/* new ring contains existing one, but is larger ==> discard*/
	nr = false;
      }
    }
    break;
  }
  return nr;
}


Static void add_ring(short *n_path)
{
  /* new in v0.3: store rings in an ordered way (with ascending ring size)*/
  short i;
  short j = 0;
  short k, s, pl, FORLIM;

  /*{$IFDEF debug
  dstr : string;
  $ENDIF*/
  pl = path_length(n_path);
  if (pl < 1)
    return;
  if (n_rings >= max_rings)
    return;
  n_rings++;
  /*{$IFDEF debug
  dstr := '';
  for j := 1 to pl do dstr := dstr + inttostr((n_path[j])) + ' ';
  debugoutput('adding ring '+inttostr(n_rings)+':  '+dstr);
  $ENDIF*/
  if (n_rings > 1) {
    FORLIM = n_rings;
    for (i = 1; i <= FORLIM - 1; i++) {
      s = ringprop[i-1].size;
      if (pl >= s)
	j = i;
    }
  }
  j++;   /* the next position is ours*/
  if (j < n_rings) {  /* push up the remaining rings by one position*/
    for (k = n_rings; k >= j + 1; k--) {
      ringprop[k-1].size = ringprop[k-2].size;
      /*ringprop^[k].arom := ringprop^[(k-1)].arom;*/
      for (i = 0; i <= max_ringsize - 1; i++)
	ring[k-1][i] = ring[k-2][i];
    }
  }
  ringprop[j-1].size = pl;
  for (i = 0; i <= max_ringsize - 1; i++) {
    ring[j-1][i] = n_path[i];
    /*inc(atom^[(n_path[i])].ring_count);*/
    /*{$IFDEF debug
    debugoutput('max_rings exceeded!');
    {$ENDIF*/
  }
}


Static boolean is_ringpath(short *s_path)
{
  boolean Result;
  short i, j;
  neighbor_rec nb;
  boolean rp = false;
  boolean new_atom;
  short a_last, pl;
  ringpath_type l_path;
  short FORLIM;

/* p2c: checkmol3l.pas:
 * Note: Eliminated unused assignment statement [338] */
  memset(nb, 0, sizeof(neighbor_rec));
  memset(l_path, 0, sizeof(ringpath_type));
  pl = path_length(s_path);
  if (pl < 1)
    return Result;
  /*{$IFDEF debug
  debugoutput('Oops! Got zero-length s_path!');
  {$ENDIF*/
  for (i = 0; i <= pl - 1; i++)
    l_path[i] = s_path[i];
  /* check if the last atom is a metal and stop if opt_metalrings is not set (v0.3)*/
  if (opt_metalrings == false) {
    if (atom[l_path[pl-1] - 1].metal) {
      /*{$IFDEF debug
      debugoutput('skipping metal in ring search');
      {$ENDIF*/
      return false;
    }
  }
  /* check if ring is already closed*/
  if (pl > 2 && l_path[pl-1] == l_path[0]) {
    l_path[pl-1] = 0;   /* remove last entry (redundant!)*/
    order_ringpath(l_path);
    if (is_newring(l_path)) {
      if (n_rings >= max_rings) {
	/*{$IFDEF debug
	debugoutput('maximum number of rings exceeded!');
	$ENDIF*/
	return false;
      }
      add_ring(l_path);
    }
/* p2c: checkmol3l.pas:
 * Note: Eliminated unused assignment statement [338] */
    return true;
  }
  /* any other case: ring is not (yet) closed*/
  a_last = l_path[pl-1];
  get_neighbors(nb, a_last);
  if (atom[a_last-1].neighbor_count <= 1)
    return false;
  if (n_rings >= max_rings)
      /* added in v0.2: check if max_rings is reached*/
      {  /* if ring is not closed, continue searching*/
    return false;
  }
  FORLIM = atom[a_last-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    new_atom = true;
    for (j = 1; j <= pl - 1; j++) {
      if (nb[i] == l_path[j]) {  /* v0.3k*/
	new_atom = false;
/* p2c: checkmol3l.pas, line 2457:
 * Warning: Expected a '(', found a semicolon [227] */
/* p2c: checkmol3l.pas, line 2457:
 * Warning: Expected an expression, found a semicolon [227] */
	fflush(0);
	P_ioresult = 0;   /* v0.3k*/
      }
    }
    /* added in v0.1a: check if max_rings not yet reached*/
    /* added in v0.2:  limit ring size to max_vringsize instead of max_ringsize*/
    if (new_atom && pl < max_vringsize && n_rings < max_rings) {
      l_path[pl] = nb[i];
      if (pl < max_ringsize - 1)   /* just to be sure*/
	l_path[pl+1] = 0;
      if (is_ringpath(l_path))
	rp = true;
    }
  }
  return rp;
}


Static boolean is_ringbond(short b_id)
{
  short i, ra1, ra2;
  neighbor_rec nb;
  ringpath_type search_path;
  boolean rb = false;
  short FORLIM;

  ra1 = bond[b_id-1].a1;
  ra2 = bond[b_id-1].a2;
  memset(nb, 0, sizeof(neighbor_rec));
  memset(search_path, 0, sizeof(ringpath_type));
  get_neighbors(nb, ra2);
  if (atom[ra2-1].neighbor_count <= 1 || atom[ra1-1].neighbor_count <= 1)
    return false;
  search_path[0] = ra1;
  search_path[1] = ra2;
  FORLIM = atom[ra2-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (nb[i] != ra1 && atom[nb[i] - 1].heavy) {
      search_path[2] = nb[i];
      if (is_ringpath(search_path))
	rb = true;
    }
  }
  return rb;
}


Static void chk_ringbonds(void)
{
  short i, a1rc, a2rc, FORLIM;

  if (n_bonds < 1)
    return;
  FORLIM = n_bonds;
  for (i = 1; i <= FORLIM; i++) {
    a1rc = atom[bond[i-1].a1 - 1].ring_count;
    a2rc = atom[bond[i-1].a2 - 1].ring_count;
    if (n_rings == 0 || a1rc < n_rings && a2rc < n_rings) {
      is_ringbond(i);
      /*inc(bond^[i].ring_count);*/
    }
  }
}


/* v0.3d: moved procedure update_ringcount a bit down */


Static short raw_hetbond_count(short a)
{
  /* new in v0.2j, ignores bond order*/
  short i;
  neighbor_rec nb;
  str2 nb_el;
  short hbc = 0;
  short FORLIM;

  if (a <= 0 || a > n_atoms)
    return hbc;
  memset(nb, 0, sizeof(neighbor_rec));
  get_neighbors(nb, a);
  if (atom[a-1].neighbor_count <= 0)
    return hbc;
  FORLIM = atom[a-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    strcpy(nb_el, atom[nb[i] - 1].element);
    if (strcmp(nb_el, "C ") && strcmp(nb_el, "A ") && strcmp(nb_el, "H ") &&
	strcmp(nb_el, "LP") && strcmp(nb_el, "DU"))
      hbc++;
  }
  return hbc;
}


Static short hetbond_count(short a)
{
  short i;
  neighbor_rec nb;
  str2 nb_el;
  float hbc = 0.0;
  short FORLIM;

  if (a <= 0 || a > n_atoms)
    return ((long)floor(hbc + 0.5));
  memset(nb, 0, sizeof(neighbor_rec));
  get_neighbors(nb, a);
  if (atom[a-1].neighbor_count <= 0)
    return ((long)floor(hbc + 0.5));
  FORLIM = atom[a-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    strcpy(nb_el, atom[nb[i] - 1].element);
    if (strcmp(nb_el, "C ") && strcmp(nb_el, "A ") && strcmp(nb_el, "H ") &&
	strcmp(nb_el, "LP") && strcmp(nb_el, "DU")) {
      if (bond[get_bond(a, nb[i]) - 1].btype == 'S')
	hbc += 1.0;
      if (bond[get_bond(a, nb[i]) - 1].btype == 'A')
	hbc += 1.5;
      if (bond[get_bond(a, nb[i]) - 1].btype == 'D')
	hbc += 2.0;
      if (bond[get_bond(a, nb[i]) - 1].btype == 'T')
	hbc += 3.0;
    }
  }
  return ((long)floor(hbc + 0.5));
}


Static short hetatom_count(short a)
{
  short i;
  neighbor_rec nb;
  str2 nb_el;
  short hac = 0;
  short FORLIM;

  if (a <= 0 || a > n_atoms)
    return hac;
  memset(nb, 0, sizeof(neighbor_rec));
  get_neighbors(nb, a);
  if (atom[a-1].neighbor_count <= 0)
    return hac;
  FORLIM = atom[a-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    strcpy(nb_el, atom[nb[i] - 1].element);
    if (strcmp(nb_el, "C ") && strcmp(nb_el, "H ") && strcmp(nb_el, "LP") &&
	strcmp(nb_el, "DU"))
      hac++;
  }
  return hac;
}


Static short ndl_hetbond_count(short a)
{
  short i;
  neighbor_rec nb;
  str2 nb_el;
  float hbc = 0.0;
  short FORLIM;

  if (a <= 0 || a > n_atoms)
    return ((long)floor(hbc + 0.5));
  memset(nb, 0, sizeof(neighbor_rec));
  get_ndl_neighbors(nb, a);
  if (ndl_atom[a-1].neighbor_count <= 0)
    return ((long)floor(hbc + 0.5));
  FORLIM = ndl_atom[a-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    strcpy(nb_el, ndl_atom[nb[i] - 1].element);
    if (strcmp(nb_el, "C ") && strcmp(nb_el, "H ") && strcmp(nb_el, "LP") &&
	strcmp(nb_el, "DU")) {
      if (ndl_bond[get_ndl_bond(a, nb[i]) - 1].btype == 'S')
	hbc += 1.0;
      if (ndl_bond[get_ndl_bond(a, nb[i]) - 1].btype == 'A')
	hbc += 1.5;
      if (ndl_bond[get_ndl_bond(a, nb[i]) - 1].btype == 'D')
	hbc += 2.0;
      if (ndl_bond[get_ndl_bond(a, nb[i]) - 1].btype == 'T')
	hbc += 3.0;
    }
  }
  return ((long)floor(hbc + 0.5));
}


Static short ndl_hetatom_count(short a)
{
  short i;
  neighbor_rec nb;
  str2 nb_el;
  short hac = 0;
  short FORLIM;

  if (a <= 0 || a > ndl_n_atoms)
    return hac;
  memset(nb, 0, sizeof(neighbor_rec));
  get_ndl_neighbors(nb, a);
  if (ndl_atom[a-1].neighbor_count <= 0)
    return hac;
  FORLIM = ndl_atom[a-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++)
  {  /* note: query atoms like 'A' should be present only in the needle*/
    strcpy(nb_el, ndl_atom[nb[i] - 1].element);
    if (strcmp(nb_el, "C ") && strcmp(nb_el, "A ") && strcmp(nb_el, "H ") &&
	strcmp(nb_el, "LP") && strcmp(nb_el, "DU"))
      hac++;
  }
  return hac;
}


Static boolean is_oxo_C(short id)
{
  boolean Result;
  short i;
  boolean r = false;
  neighbor_rec nb;
  short FORLIM;

  memset(nb, 0, sizeof(neighbor_rec));
  if (id < 1 || id > n_atoms)
    return Result;
  get_neighbors(nb, id);
  if (strcmp(atom[id-1].element, "C ") || atom[id-1].neighbor_count <= 0)
    return false;
  FORLIM = atom[id-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (bond[get_bond(id, nb[i]) - 1].btype == 'D' &&
	!strcmp(atom[nb[i] - 1].element, "O "))
	  /* no N, amidines are different...*/
	    r = true;
    /*or
      (atom^[(nb[i])].element = 'S ')  or
      (atom^[(nb[i])].element = 'SE') */
  }
  return r;
}


Static boolean is_thioxo_C(short id)
{
  boolean Result;
  short i;
  boolean r = false;
  neighbor_rec nb;
  short FORLIM;

  memset(nb, 0, sizeof(neighbor_rec));
  if (id < 1 || id > n_atoms)
    return Result;
  get_neighbors(nb, id);
  if (strcmp(atom[id-1].element, "C ") || atom[id-1].neighbor_count <= 0)
    return false;
  FORLIM = atom[id-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (bond[get_bond(id, nb[i]) - 1].btype == 'D' &&
	(!strcmp(atom[nb[i] - 1].element, "S ") ||
	 !strcmp(atom[nb[i] - 1].element, "SE")))
	  /* no N, amidines are different...*/
	    r = true;
  }
  return r;
}


Static boolean is_imino_C(short id)
{
  boolean Result;
  short i;
  boolean r = false;
  neighbor_rec nb;
  short FORLIM;

  memset(nb, 0, sizeof(neighbor_rec));
  if (id < 1 || id > n_atoms)
    return Result;
  get_neighbors(nb, id);
  if (strcmp(atom[id-1].element, "C ") || atom[id-1].neighbor_count <= 0)
    return false;
  FORLIM = atom[id-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (bond[get_bond(id, nb[i]) - 1].btype == 'D' &&
	!strcmp(atom[nb[i] - 1].element, "N "))
      r = true;
  }
  return r;
}


Static boolean is_true_imino_C(short id)
{
  boolean Result;
  short i;
  boolean r = true;
  neighbor_rec nb;
  str2 nb_el;
  short a_n = 0;
  short b;   /* v0.3j*/
  short FORLIM;

/* p2c: checkmol3l.pas:
 * Note: Eliminated unused assignment statement [338] */
  memset(nb, 0, sizeof(neighbor_rec));
  if (id < 1 || id > n_atoms)
    return Result;
  get_neighbors(nb, id);
  if (strcmp(atom[id-1].element, "C ") || atom[id-1].neighbor_count <= 0)
    return false;
  FORLIM = atom[id-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    b = get_bond(id, nb[i]);   /* v0.3j*/
    if (bond[b-1].btype == 'D' && bond[b-1].arom == false &&
	!strcmp(atom[nb[i] - 1].element, "N "))
	  /* v0.3j*/
	    a_n = nb[i];
  }
  if (a_n <= 0)
    return false;
  memset(nb, 0, sizeof(neighbor_rec));
  get_neighbors(nb, a_n);
  FORLIM = atom[a_n-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    strcpy(nb_el, atom[nb[i] - 1].element);
    if (strcmp(nb_el, "C ") && strcmp(nb_el, "H "))
      r = false;
  }
  return r;
}


Static boolean is_true_exocyclic_imino_C(short id, short r_id)
{
  /* v0.3j*/
  boolean Result;
  short i, j;
  boolean r = false;
  neighbor_rec nb;
  ringpath_type testring;
  short ring_size, b, FORLIM;

  memset(nb, 0, sizeof(neighbor_rec));
  if (id < 1 || id > n_atoms)
    return Result;
  get_neighbors(nb, id);
  memset(testring, 0, sizeof(ringpath_type));
  ring_size = ringprop[r_id-1].size;   /* v0.3j*/
  for (j = 0; j <= ring_size - 1; j++)   /* v0.3j*/
    testring[j] = ring[r_id-1][j];
  if (strcmp(atom[id-1].element, "C ") || atom[id-1].neighbor_count <= 0)
    return false;
  FORLIM = atom[id-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    b = get_bond(id, nb[i]);
    if (bond[b-1].btype == 'D' && bond[b-1].arom == false &&
	!strcmp(atom[nb[i] - 1].element, "N ")) {
      r = true;
      for (j = 0; j <= ring_size - 1; j++) {
	if (nb[i] == ring[r_id-1][j])
	  r = false;
      }
    }
  }
  return r;
}


Static boolean is_exocyclic_imino_C(short id, short r_id)
{
  boolean Result;
  short i, j;
  boolean r = false;
  neighbor_rec nb;
  ringpath_type testring;
  short ring_size, FORLIM;

  memset(nb, 0, sizeof(neighbor_rec));
  if (id < 1 || id > n_atoms)
    return Result;
  get_neighbors(nb, id);
  memset(testring, 0, sizeof(ringpath_type));
  ring_size = ringprop[r_id-1].size;   /* v0.3j*/
  for (j = 0; j <= ring_size - 1; j++)   /* v0.3j*/
    testring[j] = ring[r_id-1][j];
  if (strcmp(atom[id-1].element, "C ") || atom[id-1].neighbor_count <= 0)
    return false;
  FORLIM = atom[id-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (bond[get_bond(id, nb[i]) - 1].btype == 'D' &&
	!strcmp(atom[nb[i] - 1].element, "N ")) {
      r = true;
      for (j = 0; j <= ring_size - 1; j++) {
	if (nb[i] == ring[r_id-1][j])
	  r = false;
      }
    }
  }
  return r;
}


Static short find_exocyclic_methylene_C(short id, short r_id)
{
  /* renamed and rewritten in v0.3j*/
  short i, j;
  short r = 0;
  neighbor_rec nb;
  ringpath_type testring;
  short ring_size, FORLIM;

  memset(nb, 0, sizeof(neighbor_rec));
  if (id < 1 || id > n_atoms)
    return 0;
  get_neighbors(nb, id);
  memset(testring, 0, sizeof(ringpath_type));
  ring_size = ringprop[r_id-1].size;   /* v0.3j*/
  for (j = 0; j <= ring_size - 1; j++)   /* v0.3j*/
    testring[j] = ring[r_id-1][j];
  if (strcmp(atom[id-1].element, "C ") || atom[id-1].neighbor_count <= 0)
    return r;
  FORLIM = atom[id-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (bond[get_bond(id, nb[i]) - 1].btype == 'D' &&
	!strcmp(atom[nb[i] - 1].element, "C ")) {
      r = nb[i];
      for (j = 0; j <= ring_size - 1; j++) {
	if (nb[i] == ring[r_id-1][j])
	  r = 0;
      }
    }
  }
  return r;
}


Static boolean is_hydroxy(short a_view, short a_ref)
{
  boolean r = false;

  if (atom[a_view-1].heavy && bond[get_bond(a_view, a_ref) - 1].btype == 'S') {
    if (!strcmp(atom[a_ref-1].atype, "O3 ") &&
	atom[a_ref-1].neighbor_count == 1)
      r = true;
  }
  return r;
}


Static boolean is_sulfanyl(short a_view, short a_ref)
{
  boolean r = false;

  if (atom[a_view-1].heavy && bond[get_bond(a_view, a_ref) - 1].btype == 'S') {
    if (!strcmp(atom[a_ref-1].atype, "S3 ") &&
	atom[a_ref-1].neighbor_count == 1)
      r = true;
  }
  return r;
}


Static boolean is_amino(short a_view, short a_ref)
{
  boolean r = false;

  if (atom[a_view-1].heavy && bond[get_bond(a_view, a_ref) - 1].btype == 'S') {
    if ((!strcmp(atom[a_ref-1].atype, "N3 ") ||
	 !strcmp(atom[a_ref-1].atype, "N3+")) &&
	atom[a_ref-1].neighbor_count == 1)
      r = true;
  }
  return r;
}


Static boolean is_alkyl(short a_view, short a_ref)
{
  short i;
  boolean r = false;
  neighbor_rec nb;
  str2 nb_el;
  short het_count = 0;
  short FORLIM;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S') ||
      strcmp(atom[a_ref-1].atype, "C3 ") || atom[a_ref-1].arom != false)
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  FORLIM = atom[a_ref-1].neighbor_count - 2;
  for (i = 0; i <= FORLIM; i++) {
    strcpy(nb_el, atom[nb[i] - 1].element);
    if (strcmp(nb_el, "C ") && strcmp(nb_el, "H ") && strcmp(nb_el, "DU") &&
	strcmp(nb_el, "LP"))
      het_count++;
  }
  if (het_count <= 1)   /* we consider (e.g.) alkoxyalkyl groups as alkyl*/
    r = true;
  return r;
}


Static boolean is_true_alkyl(short a_view, short a_ref)
{
  short i;
  boolean r = false;
  neighbor_rec nb;
  str2 nb_el;
  short het_count = 0;
  short FORLIM;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S') ||
      strcmp(atom[a_ref-1].atype, "C3 ") || atom[a_ref-1].arom != false)
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  FORLIM = atom[a_ref-1].neighbor_count - 2;
  for (i = 0; i <= FORLIM; i++) {
    strcpy(nb_el, atom[nb[i] - 1].element);
    if (strcmp(nb_el, "C ") && strcmp(nb_el, "H ") && strcmp(nb_el, "DU"))
      het_count++;
  }
  if (het_count == 0)   /**/
    r = true;
  return r;
}


Static boolean is_alkenyl(short a_view, short a_ref)
{
  /* new in v0.3j*/
  short i;
  boolean r = false;
  neighbor_rec nb;
  str2 nb_el;
  str3 nb_at;
  short c2_count = 0, het_count = 0;
  short FORLIM;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S') ||
      strcmp(atom[a_ref-1].atype, "C2 ") || atom[a_ref-1].arom != false) {
    return false;
  }  /* v0.3k: changed c2_count = 1 into c2_count >= 1*/
  get_nextneighbors(nb, a_ref, a_view);
  FORLIM = atom[a_ref-1].neighbor_count - 2;
  for (i = 0; i <= FORLIM; i++) {
    strcpy(nb_el, atom[nb[i] - 1].element);
    strcpy(nb_at, atom[nb[i] - 1].atype);
    if (strcmp(nb_el, "C ") && strcmp(nb_el, "H ") && strcmp(nb_el, "DU") &&
	strcmp(nb_el, "LP"))
      het_count++;
    if (!strcmp(nb_at, "C2 "))
      c2_count++;
  }
  if (c2_count >= 1 && het_count <= 1)
	/* we consider (e.g.) alkoxyalkenyl groups as alkenyl*/
	  r = true;
  return r;
}


Static boolean is_alkynyl(short a_view, short a_ref)
{
  /* new in v0.3j*/
  short i;
  boolean r = false;
  neighbor_rec nb;
  str3 nb_at;
  short c1_count = 0;
  short FORLIM;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S') ||
      strcmp(atom[a_ref-1].atype, "C1 ") || atom[a_ref-1].arom != false)
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  FORLIM = atom[a_ref-1].neighbor_count - 2;
  for (i = 0; i <= FORLIM; i++) {
    strcpy(nb_at, atom[nb[i] - 1].atype);
    if (!strcmp(nb_at, "C1 "))
      c1_count++;
  }
  if (c1_count == 1)
    r = true;
  return r;
}


Static boolean is_aryl(short a_view, short a_ref)
{
  boolean r = false;

  if (atom[a_view-1].heavy &&
      bond[get_bond(a_view, a_ref) - 1].btype == 'S' &&
      !strcmp(atom[a_ref-1].element, "C ") && atom[a_ref-1].arom == true)
    r = true;
  return r;
}


Static boolean is_alkoxy(short a_view, short a_ref)
{
  boolean r = false;
  neighbor_rec nb;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (strcmp(atom[a_ref-1].atype, "O3 ") || atom[a_ref-1].neighbor_count != 2)
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  if (is_alkyl(a_ref, nb[0]))
    r = true;
  return r;
}


Static boolean is_siloxy(short a_view, short a_ref)
{
  boolean r = false;
  neighbor_rec nb;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (strcmp(atom[a_ref-1].atype, "O3 ") || atom[a_ref-1].neighbor_count != 2)
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  if (!strcmp(atom[nb[0] - 1].element, "SI"))
    r = true;
  return r;
}


Static boolean is_true_alkoxy(short a_view, short a_ref)
{
  boolean r = false;
  neighbor_rec nb;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (strcmp(atom[a_ref-1].atype, "O3 ") || atom[a_ref-1].neighbor_count != 2)
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  if (is_true_alkyl(a_ref, nb[0]))
    r = true;
  return r;
}


Static boolean is_aryloxy(short a_view, short a_ref)
{
  boolean r = false;
  neighbor_rec nb;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (strcmp(atom[a_ref-1].atype, "O3 ") || atom[a_ref-1].neighbor_count != 2)
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  if (is_aryl(a_ref, nb[0]))
    r = true;
  return r;
}


Static boolean is_alkenyloxy(short a_view, short a_ref)
{
  /* v0.3j*/
  boolean r = false;
  neighbor_rec nb;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (strcmp(atom[a_ref-1].atype, "O3 ") || atom[a_ref-1].neighbor_count != 2)
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  if (is_alkenyl(a_ref, nb[0]))
    r = true;
  return r;
}


Static boolean is_alkynyloxy(short a_view, short a_ref)
{
  /* v0.3j*/
  boolean r = false;
  neighbor_rec nb;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (strcmp(atom[a_ref-1].atype, "O3 ") || atom[a_ref-1].neighbor_count != 2)
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  if (is_alkynyl(a_ref, nb[0]))
    r = true;
  return r;
}


Static boolean is_alkylsulfanyl(short a_view, short a_ref)
{
  boolean r = false;
  neighbor_rec nb;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (strcmp(atom[a_ref-1].atype, "S3 ") || atom[a_ref-1].neighbor_count != 2)
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  if (is_alkyl(a_ref, nb[0]))
    r = true;
  return r;
}


Static boolean is_true_alkylsulfanyl(short a_view, short a_ref)
{
  boolean r = false;
  neighbor_rec nb;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (strcmp(atom[a_ref-1].atype, "S3 ") || atom[a_ref-1].neighbor_count != 2)
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  if (is_true_alkyl(a_ref, nb[0]))
    r = true;
  return r;
}


Static boolean is_arylsulfanyl(short a_view, short a_ref)
{
  boolean r = false;
  neighbor_rec nb;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (strcmp(atom[a_ref-1].atype, "S3 ") || atom[a_ref-1].neighbor_count != 2)
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  if (is_aryl(a_ref, nb[0]))
    r = true;
  return r;
}


Static boolean is_alkenylsulfanyl(short a_view, short a_ref)
{
  /* v0.3j*/
  boolean r = false;
  neighbor_rec nb;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (strcmp(atom[a_ref-1].atype, "S3 ") || atom[a_ref-1].neighbor_count != 2)
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  if (is_alkenyl(a_ref, nb[0]))
    r = true;
  return r;
}


Static boolean is_alkynylsulfanyl(short a_view, short a_ref)
{
  /* v0.3j*/
  boolean r = false;
  neighbor_rec nb;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (strcmp(atom[a_ref-1].atype, "S3 ") || atom[a_ref-1].neighbor_count != 2)
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  if (is_alkynyl(a_ref, nb[0]))
    r = true;
  return r;
}


Static boolean is_alkylamino(short a_view, short a_ref)
{
  boolean r = false;
  neighbor_rec nb;
  short alkyl_count = 0;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (strcmp(atom[a_ref-1].element, "N ") || atom[a_ref-1].neighbor_count != 2)
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  if (is_alkyl(a_ref, nb[0]))
    alkyl_count++;
  if (alkyl_count == 1)
    r = true;
  return r;
}


Static boolean is_dialkylamino(short a_view, short a_ref)
{
  short i;
  boolean r = false;
  neighbor_rec nb;
  short alkyl_count = 0;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (strcmp(atom[a_ref-1].element, "N ") || atom[a_ref-1].neighbor_count != 3)
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  for (i = 0; i <= 1; i++) {
    if (is_alkyl(a_ref, nb[i]))
      alkyl_count++;
  }
  if (alkyl_count == 2)
    r = true;
  return r;
}


Static boolean is_arylamino(short a_view, short a_ref)
{
  boolean r = false;
  neighbor_rec nb;
  short aryl_count = 0;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (strcmp(atom[a_ref-1].element, "N ") || atom[a_ref-1].neighbor_count != 2)
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  if (is_aryl(a_ref, nb[0]))
    aryl_count++;
  if (aryl_count == 1)
    r = true;
  return r;
}


Static boolean is_diarylamino(short a_view, short a_ref)
{
  short i;
  boolean r = false;
  neighbor_rec nb;
  short aryl_count = 0;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (strcmp(atom[a_ref-1].element, "N ") || atom[a_ref-1].neighbor_count != 3)
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  for (i = 0; i <= 1; i++) {
    if (is_aryl(a_ref, nb[i]))
      aryl_count++;
  }
  if (aryl_count == 2)
    r = true;
  return r;
}


Static boolean is_alkylarylamino(short a_view, short a_ref)
{
  short i;
  boolean r = false;
  neighbor_rec nb;
  short alkyl_count = 0, aryl_count = 0;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (strcmp(atom[a_ref-1].element, "N ") || atom[a_ref-1].neighbor_count != 3)
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  for (i = 0; i <= 1; i++) {
    if (is_alkyl(a_ref, nb[i]))
      alkyl_count++;
    if (is_aryl(a_ref, nb[i]))
      aryl_count++;
  }
  if (alkyl_count == 1 && aryl_count == 1)
    r = true;
  return r;
}


Static boolean is_C_monosubst_amino(short a_view, short a_ref)
{
  /* new in v0.3j*/
  boolean r = false;
  neighbor_rec nb;
  short c_count = 0;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (strcmp(atom[a_ref-1].atype, "N3 ") && strcmp(atom[a_ref-1].atype, "NAM") ||
      atom[a_ref-1].neighbor_count != 2)
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  if (!strcmp(atom[nb[0] - 1].element, "C "))
    c_count++;
  if (c_count == 1)
    r = true;
  return r;
}


Static boolean is_C_disubst_amino(short a_view, short a_ref)
{
  /* new in v0.3j*/
  short i;
  boolean r = false;
  neighbor_rec nb;
  short b;
  short c_count = 0;

  b = get_bond(a_view, a_ref);
  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy && bond[b-1].btype == 'S' &&
	bond[b-1].arom == false))
    return false;
  if (strcmp(atom[a_ref-1].atype, "N3 ") && strcmp(atom[a_ref-1].atype, "NAM") ||
      atom[a_ref-1].neighbor_count != 3)
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  for (i = 0; i <= 1; i++) {
    if (!strcmp(atom[nb[i] - 1].element, "C "))
      c_count++;
  }
  if (c_count == 2)
    r = true;
  return r;
}


Static boolean is_subst_amino(short a_view, short a_ref)
{
  boolean r = false;

  if (is_amino(a_view, a_ref) || is_alkylamino(a_view, a_ref) ||
      is_arylamino(a_view, a_ref) || is_dialkylamino(a_view, a_ref) ||
      is_alkylarylamino(a_view, a_ref) || is_diarylamino(a_view, a_ref))
    r = true;
  return r;
}


Static boolean is_true_alkylamino(short a_view, short a_ref)
{
  boolean r = false;
  neighbor_rec nb;
  short alkyl_count = 0;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (strcmp(atom[a_ref-1].atype, "N3 ") && strcmp(atom[a_ref-1].atype, "N3+") ||
      atom[a_ref-1].neighbor_count != 2)
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  if (is_true_alkyl(a_ref, nb[0]))
    alkyl_count++;
  if (alkyl_count == 1)
    r = true;
  return r;
}


Static boolean is_true_dialkylamino(short a_view, short a_ref)
{
  short i;
  boolean r = false;
  neighbor_rec nb;
  short alkyl_count = 0;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (strcmp(atom[a_ref-1].atype, "N3 ") && strcmp(atom[a_ref-1].atype, "N3+") ||
      atom[a_ref-1].neighbor_count != 3)
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  for (i = 0; i <= 1; i++) {
    if (is_true_alkyl(a_ref, nb[i]))
      alkyl_count++;
  }
  if (alkyl_count == 2)
    r = true;
  return r;
}


Static boolean is_true_alkylarylamino(short a_view, short a_ref)
{
  short i;
  boolean r = false;
  neighbor_rec nb;
  short alkyl_count = 0, aryl_count = 0;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (strcmp(atom[a_ref-1].atype, "N3 ") && strcmp(atom[a_ref-1].atype, "N3+") ||
      atom[a_ref-1].neighbor_count != 3)
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  for (i = 0; i <= 1; i++) {
    if (is_true_alkyl(a_ref, nb[i]))
      alkyl_count++;
    if (is_aryl(a_ref, nb[i]))
      aryl_count++;
  }
  if (alkyl_count == 1 && aryl_count == 1)
    r = true;
  return r;
}


Static boolean is_hydroxylamino(short a_view, short a_ref)
{
  short i;
  boolean r = false;
  neighbor_rec nb;
  short oh_count = 0, het_count = 0;   /* v0.3k*/
  str2 nb_el;   /* v0.3k*/
  short FORLIM;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (strcmp(atom[a_ref-1].element, "N ") || atom[a_ref-1].neighbor_count < 2)
	/* v0.3c*/
	  return false;
  get_nextneighbors(nb, a_ref, a_view);
  FORLIM = atom[a_ref-1].neighbor_count - 2;
  for (i = 0; i <= FORLIM; i++) {   /* v0.3c*/
    if (is_hydroxy(a_ref, nb[i]))
      oh_count++;
    strcpy(nb_el, atom[nb[i] - 1].element);   /* v0.3k*/
    if (strcmp(nb_el, "C ") && strcmp(nb_el, "H ") && strcmp(nb_el, "DU") &&
	strcmp(nb_el, "LP"))
	  /* v0.3k*/
	    het_count++;
  }
  if (oh_count == 1 && het_count == 1)
    r = true;
  return r;
}


Static boolean is_nitro(short a_view, short a_ref)
{
  short i;
  boolean r = false;
  neighbor_rec nb;
  short o_count = 0, bond_count = 0;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (strcmp(atom[a_ref-1].element, "N ") || atom[a_ref-1].neighbor_count != 3)
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  for (i = 0; i <= 1; i++) {
    if (!strcmp(atom[nb[i] - 1].element, "O "))
      o_count++;
    if (bond[get_bond(a_ref, nb[i]) - 1].btype == 'S')
      bond_count++;
    if (bond[get_bond(a_ref, nb[i]) - 1].btype == 'D')
      bond_count += 2;
  }
  if (o_count == 2 && bond_count >= 3)
    r = true;
  return r;
}


Static boolean is_azido(short a_view, short a_ref)
{
  boolean r = false;
  neighbor_rec nb;
  short bond_count = 0, n1 = 0, n2 = 0, n3 = 0;

  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (strcmp(atom[a_ref-1].element, "N ") || atom[a_ref-1].neighbor_count != 2)
    return false;
  n1 = a_ref;
  memset(nb, 0, sizeof(neighbor_rec));
  get_nextneighbors(nb, n1, a_view);
  if (!strcmp(atom[nb[0] - 1].element, "N ")) {
    n2 = nb[0];
    if (bond[get_bond(n1, n2) - 1].btype == 'S')
      bond_count++;
    if (bond[get_bond(n1, n2) - 1].btype == 'D')
      bond_count += 2;
    if (bond[get_bond(n1, n2) - 1].btype == 'T')
      bond_count += 3;
  }
  if (n2 > 0 && atom[n2-1].neighbor_count == 2) {
    memset(nb, 0, sizeof(neighbor_rec));
    get_nextneighbors(nb, n2, n1);
    if (!strcmp(atom[nb[0] - 1].element, "N ")) {
      n3 = nb[0];
      if (bond[get_bond(n2, n3) - 1].btype == 'S')
	bond_count++;
      if (bond[get_bond(n2, n3) - 1].btype == 'D')
	bond_count += 2;
      if (bond[get_bond(n2, n3) - 1].btype == 'T')
	bond_count += 3;
    }
  }
  if (n1 > 0 && n2 > 0 && n3 > 0 && atom[n3-1].neighbor_count == 1 &&
      bond_count > 3)
    r = true;
  return r;
}


Static boolean is_diazonium(short a_view, short a_ref)
{
  boolean r = false;
  neighbor_rec nb;
  short bond_count = 0, chg_count = 0, n1 = 0, n2 = 0;

  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (strcmp(atom[a_ref-1].element, "N ") || atom[a_ref-1].neighbor_count != 2)
    return false;
  n1 = a_ref;
  chg_count = atom[n1-1].formal_charge;
  memset(nb, 0, sizeof(neighbor_rec));
  get_nextneighbors(nb, n1, a_view);
  if (!strcmp(atom[nb[0] - 1].element, "N ")) {
    n2 = nb[0];
    chg_count += atom[n2-1].formal_charge;
    if (bond[get_bond(n1, n2) - 1].btype == 'S')
      bond_count++;
    if (bond[get_bond(n1, n2) - 1].btype == 'D')
      bond_count += 2;
    if (bond[get_bond(n1, n2) - 1].btype == 'T')
      bond_count += 3;
  }
  if (n1 > 0 && n2 > 0 && atom[n2-1].neighbor_count == 1 && bond_count >= 2 &&
      chg_count > 0)
    r = true;
  return r;
}


Static boolean is_hydroximino_C(short id)
{
  boolean Result;
  short i;
  boolean r = false;
  neighbor_rec nb;
  short a_het = 0;
  short FORLIM;

  memset(nb, 0, sizeof(neighbor_rec));
  if (id < 1 || id > n_atoms)
    return Result;
  get_neighbors(nb, id);
  if (strcmp(atom[id-1].element, "C ") || atom[id-1].neighbor_count <= 0)
    return false;
  FORLIM = atom[id-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (bond[get_bond(id, nb[i]) - 1].btype == 'D' &&
	!strcmp(atom[nb[i] - 1].element, "N ") && hetbond_count(nb[i]) == 3)
      a_het = nb[i];
  }
  if (a_het <= 0)
    return false;
  memset(nb, 0, sizeof(neighbor_rec));
  get_neighbors(nb, a_het);
  if (strcmp(atom[a_het-1].element, "N ") || atom[a_het-1].neighbor_count <= 0)
    return false;
  FORLIM = atom[a_het-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (is_hydroxy(a_het, nb[i]))
      r = true;
  }
  return r;
}


Static boolean is_hydrazono_C(short id)
{
  boolean Result;
  short i;
  boolean r = false;
  neighbor_rec nb;
  short a_het = 0;
  short FORLIM;

  memset(nb, 0, sizeof(neighbor_rec));
  if (id < 1 || id > n_atoms)
    return Result;
  get_neighbors(nb, id);
  if (strcmp(atom[id-1].element, "C ") || atom[id-1].neighbor_count <= 0)
    return false;
  FORLIM = atom[id-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (bond[get_bond(id, nb[i]) - 1].btype == 'D' &&
	!strcmp(atom[nb[i] - 1].element, "N ")) {
      /* and
      (hetbond_count(nb[i]) = 3)  */
      a_het = nb[i];
    }
  }
  if (a_het <= 0)
    return false;
  memset(nb, 0, sizeof(neighbor_rec));
  get_neighbors(nb, a_het);
  if (strcmp(atom[a_het-1].element, "N ") || atom[a_het-1].neighbor_count <= 0)
    return false;
  FORLIM = atom[a_het-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (is_amino(a_het, nb[i]) || is_alkylamino(a_het, nb[i]) ||
	is_alkylarylamino(a_het, nb[i]) || is_arylamino(a_het, nb[i]) ||
	is_dialkylamino(a_het, nb[i]) || is_diarylamino(a_het, nb[i]))
      r = true;
  }
  return r;
}


Static boolean is_alkoxycarbonyl(short a_view, short a_ref)
{
  short i;
  boolean r = false;
  neighbor_rec nb;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (!(is_oxo_C(a_ref) && atom[a_ref-1].neighbor_count == 3))
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  for (i = 0; i <= 1; i++) {
    if (is_alkoxy(a_ref, nb[i]))
      r = true;
  }
  return r;
}


Static boolean is_aryloxycarbonyl(short a_view, short a_ref)
{
  short i;
  boolean r = false;
  neighbor_rec nb;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (!(is_oxo_C(a_ref) && atom[a_ref-1].neighbor_count == 3))
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  for (i = 0; i <= 1; i++) {
    if (is_aryloxy(a_ref, nb[i]))
      r = true;
  }
  return r;
}


Static boolean is_carbamoyl(short a_view, short a_ref)
{
  short i;
  boolean r = false;
  neighbor_rec nb;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (!(is_oxo_C(a_ref) && atom[a_ref-1].neighbor_count == 3))
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  for (i = 0; i <= 1; i++) {
    if (!strcmp(atom[nb[i] - 1].atype, "N3 ") ||
	!strcmp(atom[nb[i] - 1].atype, "NAM"))
      r = true;
  }
  return r;
}


Static boolean is_alkoxythiocarbonyl(short a_view, short a_ref)
{
  short i;
  boolean r = false;
  neighbor_rec nb;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (!(is_thioxo_C(a_ref) && atom[a_ref-1].neighbor_count == 3))
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  for (i = 0; i <= 1; i++) {
    if (is_alkoxy(a_ref, nb[i]))
      r = true;
  }
  return r;
}


Static boolean is_aryloxythiocarbonyl(short a_view, short a_ref)
{
  short i;
  boolean r = false;
  neighbor_rec nb;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (!(is_thioxo_C(a_ref) && atom[a_ref-1].neighbor_count == 3))
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  for (i = 0; i <= 1; i++) {
    if (is_aryloxy(a_ref, nb[i]))
      r = true;
  }
  return r;
}


Static boolean is_thiocarbamoyl(short a_view, short a_ref)
{
  short i;
  boolean r = false;
  neighbor_rec nb;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (!(is_thioxo_C(a_ref) && atom[a_ref-1].neighbor_count == 3))
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  for (i = 0; i <= 1; i++) {
    if (!strcmp(atom[nb[i] - 1].atype, "N3 ") ||
	!strcmp(atom[nb[i] - 1].atype, "NAM"))
      r = true;
  }
  return r;
}


Static boolean is_alkanoyl(short a_view, short a_ref)
{
  short i;
  boolean r = false;
  neighbor_rec nb;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (!(is_oxo_C(a_ref) && atom[a_ref-1].neighbor_count == 3))
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  for (i = 0; i <= 1; i++) {
    if (is_alkyl(a_ref, nb[i]))
      r = true;
  }
  return r;
}


Static boolean is_aroyl(short a_view, short a_ref)
{
  short i;
  boolean r = false;
  neighbor_rec nb;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (!(is_oxo_C(a_ref) && atom[a_ref-1].neighbor_count == 3))
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  for (i = 0; i <= 1; i++) {
    if (is_aryl(a_ref, nb[i]))
      r = true;
  }
  return r;
}


Static boolean is_acyl(short a_view, short a_ref)
{
  boolean r = false;

  if (is_alkanoyl(a_view, a_ref) || is_aroyl(a_view, a_ref))
    r = true;
  return r;
}


Static boolean is_acyl_gen(short a_view, short a_ref)
{
  /* new in v0.3j*/
  boolean r = false;

  if (is_oxo_C(a_ref))
    r = true;
  return r;
}


Static boolean is_acylamino(short a_view, short a_ref)
{
  boolean r = false;
  neighbor_rec nb;
  short acyl_count = 0;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (strcmp(atom[a_ref-1].element, "N ") || atom[a_ref-1].neighbor_count != 2)
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  if (is_acyl(a_ref, nb[0]))
    acyl_count++;
  if (acyl_count == 1)
    r = true;
  return r;
}


Static boolean is_subst_acylamino(short a_view, short a_ref)
{
  /* may be substituted _or_ unsubstituted acylamino group!*/
  short i;
  boolean r = false;
  neighbor_rec nb;
  short acyl_count = 0;
  short FORLIM;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (strcmp(atom[a_ref-1].element, "N ") || atom[a_ref-1].neighbor_count < 2)
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  FORLIM = atom[a_ref-1].neighbor_count - 2;
  for (i = 0; i <= FORLIM; i++) {
    if (is_acyl_gen(a_ref, nb[i]))   /* v0.3j*/
      acyl_count++;
  }
  if (acyl_count > 0)
    r = true;
  return r;
}


Static boolean is_hydrazino(short a_view, short a_ref)
{
  short i;
  boolean r = false;
  neighbor_rec nb;
  short nr_count = 0;
  short FORLIM;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (strcmp(atom[a_ref-1].element, "N ") || atom[a_ref-1].neighbor_count < 2)
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  FORLIM = atom[a_ref-1].neighbor_count - 2;
  for (i = 0; i <= FORLIM; i++) {   /* fixed in v0.3c*/
    if (is_amino(a_ref, nb[i]) || is_subst_amino(a_ref, nb[i]))
      nr_count++;
  }
  if (nr_count == 1)
    r = true;
  return r;
}


Static boolean is_nitroso(short a_view, short a_ref)
{
  /* new in v0.3j*/
  boolean r = false;
  neighbor_rec nb;
  short o_count = 0;
  short a2;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (strcmp(atom[a_ref-1].element, "N ") || atom[a_ref-1].neighbor_count != 2)
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  a2 = nb[0];
  if (!strcmp(atom[a2-1].element, "O ") &&
      bond[get_bond(a_ref, a2) - 1].btype == 'D')
    o_count++;
  if (o_count == 1)
    r = true;
  return r;
}


Static boolean is_subst_hydrazino(short a_view, short a_ref)
{
  short i;
  boolean r = false;
  neighbor_rec nb;
  short nr_count = 0;
  short a2, FORLIM;

  memset(nb, 0, sizeof(neighbor_rec));
  if (!(atom[a_view-1].heavy &&
	bond[get_bond(a_view, a_ref) - 1].btype == 'S'))
    return false;
  if (strcmp(atom[a_ref-1].element, "N ") || atom[a_ref-1].neighbor_count < 2)
    return false;
  get_nextneighbors(nb, a_ref, a_view);
  FORLIM = atom[a_ref-1].neighbor_count - 2;
  for (i = 0; i <= FORLIM; i++) {
    a2 = nb[i];
    if (!strcmp(atom[a2-1].element, "N ") && !is_nitroso(a_ref, a2))
	  /* v0.3j*/
	    nr_count++;
  }
  if (nr_count == 1)
    r = true;
  return r;
}


Static boolean is_cyano(short a_view, short a_ref)
{
  boolean r = false;

  if (!strcmp(atom[a_view-1].atype, "C1 ") &&
      bond[get_bond(a_view, a_ref) - 1].btype == 'T' &&
      !strcmp(atom[a_ref-1].atype, "N1 ") &&
      atom[a_ref-1].neighbor_count == 1)
    r = true;
  return r;
}


Static boolean is_cyano_c(short a_ref)
{
  short i;
  boolean r = false;
  neighbor_rec nb;
  short FORLIM;

  memset(nb, 0, sizeof(neighbor_rec));
  if (strcmp(atom[a_ref-1].atype, "C1 ") || atom[a_ref-1].neighbor_count <= 0)
    return false;
  get_neighbors(nb, a_ref);
  FORLIM = atom[a_ref-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (is_cyano(a_ref, nb[i]))
      r = true;
  }
  return r;
}


Static boolean is_nitrile(short a_view, short a_ref)
{
  boolean r = false;
  neighbor_rec nb;
  str2 nb_el;

  if (!is_cyano(a_view, a_ref))
    return false;
  if (atom[a_view-1].neighbor_count == 1 && atom[a_view-1].formal_charge == 0)
    return true;
/* p2c: checkmol3l.pas:
 * Note: Eliminated unused assignment statement [338] */
  get_nextneighbors(nb, a_view, a_ref);
  strcpy(nb_el, atom[nb[0] - 1].element);
  if (!strcmp(nb_el, "C ") || !strcmp(nb_el, "H "))
    r = true;
  /* HCN is also a nitrile!*/
  return r;
}


Static boolean is_isonitrile(short a_view, short a_ref)
{
  /* only recognized with CN triple bond!*/
  boolean r = false;

  if (!strcmp(atom[a_view-1].atype, "C1 ") &&
      bond[get_bond(a_view, a_ref) - 1].btype == 'T' &&
      !strcmp(atom[a_ref-1].atype, "N1 ") &&
      atom[a_ref-1].neighbor_count == 2 && atom[a_view-1].neighbor_count == 1)
    r = true;
  return r;
}


Static boolean is_cyanate(short a_view, short a_ref)
{
  boolean r = false;
  neighbor_rec nb;

  if (!is_cyano(a_view, a_ref))
    return false;
  if (atom[a_view-1].neighbor_count != 2)
    return false;
  get_nextneighbors(nb, a_view, a_ref);
  if (is_alkoxy(a_view, nb[0]) || is_aryloxy(a_view, nb[0]))
    r = true;
  return r;
}


Static boolean is_thiocyanate(short a_view, short a_ref)
{
  boolean r = false;
  neighbor_rec nb;

  if (!is_cyano(a_view, a_ref))
    return false;
  if (atom[a_view-1].neighbor_count != 2)
    return false;
  get_nextneighbors(nb, a_view, a_ref);
  if (is_alkylsulfanyl(a_view, nb[0]) || is_arylsulfanyl(a_view, nb[0]))
    r = true;
  return r;
}


Static void update_Htotal(void)
{
  short i, j, b_id;
  neighbor_rec nb;
  short single_count, double_count, triple_count, arom_count, total_bonds,
	Htotal, nval;
      /* new in v0.3*/
  boolean diazon = false;   /* new in v0.3j*/
  neighbor_rec nb2;   /* new in v0.3j*/
  short a1, a2, a3;   /* new in v0.3j*/
  short FORLIM, FORLIM1;

  if (n_atoms < 1)
    return;
  memset(nb, 0, sizeof(neighbor_rec));
  FORLIM = n_atoms;
  for (i = 1; i <= FORLIM; i++) {
    single_count = 0;
    double_count = 0;
    triple_count = 0;
    arom_count = 0;
    total_bonds = 0;
    Htotal = 0;
    get_neighbors(nb, i);
    if (atom[i-1].neighbor_count > 0) {
	  /* count single, double, triple, and aromatic bonds to all neighbor atoms*/
	    FORLIM1 = atom[i-1].neighbor_count;
      for (j = 0; j <= FORLIM1 - 1; j++) {
	b_id = get_bond(i, nb[j]);
	if (b_id > 0) {
	  if (bond[b_id-1].btype == 'S')
	    single_count++;
	  if (bond[b_id-1].btype == 'D')
	    double_count++;
	  if (bond[b_id-1].btype == 'T')
	    triple_count++;
	  if (bond[b_id-1].btype == 'A')
	    arom_count++;
	}
      }
      /*check for diazonium salts*/
      a1 = i;
      a2 = nb[0];
      if (!strcmp(atom[a1-1].element, "N ") &&
	  !strcmp(atom[a2-1].element, "N ")) {
	if (atom[a2-1].neighbor_count == 2) {
	  get_nextneighbors(nb2, a2, a1);
	  a3 = nb2[0];
	  if (!strcmp(atom[a3-1].element, "C ") && is_diazonium(a3, a2))
	    diazon = true;
	}
      }
    }
    total_bonds = single_count + double_count * 2 + triple_count * 3 +
		  (long)(1.5 * arom_count);
    /* calculate number of total hydrogens per atom*/
    nval = nvalences(atom[i-1].element);   /* new in v0.3*/
    if (!strcmp(atom[i-1].element, "P ")) {
      if (total_bonds > 3)   /* this will need some refinement...*/
	nval = 5;
    }  /* */
    if (!strcmp(atom[i-1].element, "S ")) {   /* v0.3h*/
      if (total_bonds > 2 && atom[i-1].formal_charge < 1)
	    /* updated in v0.3j*/
	      nval = 4;
      if (total_bonds > 4)   /* this will need some refinement...*/
	nval = 6;
    }  /* */
    Htotal = nval - total_bonds + atom[i-1].formal_charge;
    if (diazon)   /* v0.3j*/
      Htotal = 0;
    if (Htotal < 0)   /* e.g., N in nitro group*/
      Htotal = 0;
    atom[i-1].Htot = Htotal;
  }
}


Static void update_atypes(void)
{
  short i, j, b_id;
  neighbor_rec nb;
  short single_count, double_count, triple_count, arom_count, acyl_count,
	C_count, O_count, total_bonds, NdO_count, NdC_count, Htotal, FORLIM,
	FORLIM1;

  if (n_atoms < 1)
    return;
  memset(nb, 0, sizeof(neighbor_rec));
  FORLIM = n_atoms;
  for (i = 0; i <= FORLIM - 1; i++) {
    single_count = 0;
    double_count = 0;
    triple_count = 0;
    arom_count = 0;
    total_bonds = 0;
    acyl_count = 0;
    C_count = 0;
    O_count = 0;
    NdO_count = 0;
    NdC_count = 0;
    Htotal = 0;
    get_neighbors(nb, i + 1);
    if (atom[i].neighbor_count > 0) {
	  /* count single, double, triple, and aromatic bonds to all neighbor atoms*/
	    FORLIM1 = atom[i].neighbor_count;
      for (j = 0; j <= FORLIM1 - 1; j++) {
	if (is_oxo_C(nb[j]) || is_thioxo_C(nb[j]))
	  acyl_count++;
	if (!strcmp(atom[nb[j] - 1].element, "C "))
	  C_count++;
	if (!strcmp(atom[nb[j] - 1].element, "O "))
	  O_count++;
	b_id = get_bond(i + 1, nb[j]);
	if (b_id > 0) {
	  if (bond[b_id-1].btype == 'S')
	    single_count++;
	  if (bond[b_id-1].btype == 'D')
	    double_count++;
	  if (bond[b_id-1].btype == 'T')
	    triple_count++;
	  if (bond[b_id-1].btype == 'A')
	    arom_count++;
	  if ((!strcmp(atom[i].element, "N ") &&
	       !strcmp(atom[nb[j] - 1].element, "O ")) ||
	      (!strcmp(atom[i].element, "O ") &&
	       !strcmp(atom[nb[j] - 1].element, "N "))) {
	    /* check if it is an N-oxide drawn with a double bond ==> should be N3*/
	    if (bond[b_id-1].btype == 'D')
	      NdO_count++;
	  }
	  if ((!strcmp(atom[i].element, "N ") &&
	       !strcmp(atom[nb[j] - 1].element, "C ")) ||
	      (!strcmp(atom[i].element, "C ") &&
	       !strcmp(atom[nb[j] - 1].element, "N "))) {
	    if (bond[b_id-1].btype == 'D')
	      NdC_count++;
	  }
	}
      }
      total_bonds = single_count + double_count * 2 + triple_count * 3 +
		    (long)(1.5 * arom_count);
      /* calculate number of total hydrogens per atom*/
      Htotal = nvalences(atom[i].element) - total_bonds + atom[i].formal_charge;
      if (Htotal < 0)   /* e.g., N in nitro group*/
	Htotal = 0;
      atom[i].Htot = Htotal;
      /* refine atom types, based on bond types*/
      if (!strcmp(atom[i].element, "C ")) {
	if (arom_count > 1)
	  strcpy(atom[i].atype, "CAR");
	if (triple_count == 1 || double_count == 2)
	  strcpy(atom[i].atype, "C1 ");
	if (double_count == 1)
	  strcpy(atom[i].atype, "C2 ");
	if (triple_count == 0 && double_count == 0 && arom_count < 2)
	  strcpy(atom[i].atype, "C3 ");
      }
      if (!strcmp(atom[i].element, "O ")) {
	if (double_count == 1)
	  strcpy(atom[i].atype, "O2 ");
	if (double_count == 0)
	  strcpy(atom[i].atype, "O3 ");
      }
      if (!strcmp(atom[i].element, "N ")) {
	if (total_bonds > 3) {
	  if (O_count == 0) {
	    if (single_count > 3 ||
		single_count == 2 && double_count == 1 && C_count >= 2)
	      atom[i].formal_charge = 1;
	  }
	}
	/* could be an N-oxide -> should be found elsewhere */
	/* left empty, so far....*/
	if (triple_count == 1 || double_count == 2)
	  strcpy(atom[i].atype, "N1 ");
	if (double_count == 1) {
	  /*if NdC_count > 0 then atom^[i].atype := 'N2 ';*/
	  if (NdC_count == 0 && NdO_count > 0 && C_count >= 2)
	    strcpy(atom[i].atype, "N3 ");
		/* N-oxide is N3 except in hetarene etc.*/
	  else
	    strcpy(atom[i].atype, "N2 ");
	}
	/* fallback, added in v0.3g */
	if (arom_count > 1)
	  strcpy(atom[i].atype, "NAR");
	if (triple_count == 0 && double_count == 0) {
	  if (atom[i].formal_charge == 0) {
	    if (acyl_count == 0)
	      strcpy(atom[i].atype, "N3 ");
	    if (acyl_count > 0)
	      strcpy(atom[i].atype, "NAM");
	  }
	  if (atom[i].formal_charge == 1)
	    strcpy(atom[i].atype, "N3+");
	}
      }
      if (!strcmp(atom[i].element, "P ")) {
	if (single_count > 4)
	  strcpy(atom[i].atype, "P4 ");
	if (single_count <= 4 && double_count == 0)
	  strcpy(atom[i].atype, "P3 ");
	if (double_count == 2)
	  strcpy(atom[i].atype, "P3D");
      }
      if (!strcmp(atom[i].element, "S ")) {
	if (double_count == 1 && single_count == 0)
	  strcpy(atom[i].atype, "S2 ");
	if (double_count == 0)
	  strcpy(atom[i].atype, "S3 ");
	if (double_count == 1 && single_count > 0)
	  strcpy(atom[i].atype, "SO ");
	if (double_count == 2 && single_count > 0)
	  strcpy(atom[i].atype, "SO2");
      }
      /* further atom types should go here*/
    }
  }
}


Static void chk_arom(void)
{
  short i, j, pi_count, ring_size;
  ringpath_type testring;
  short a_ref, a_prev, a_next, b_bk, b_fw, b_exo;
  Char bt_bk, bt_fw;
  boolean ar_bk, ar_fw, ar_exo;   /* new in v0.3*/
  boolean conj_intr, ko, aromatic;
  short n_db, n_sb, n_ar;
  boolean cumul;
  short exo_mC;   /* v0.3j*/
  short arom_pi_diff;   /* v0.3j*/
  short FORLIM;

  if (n_rings < 1)
    return;
  FORLIM = n_rings;
  /* first, do a very quick check for benzene, pyridine, etc.*/
  for (i = 0; i <= FORLIM - 1; i++) {
    ring_size = ringprop[i].size;
    if (ring_size == 6) {
      memset(testring, 0, sizeof(ringpath_type));
      for (j = 0; j <= ring_size - 1; j++)
	testring[j] = ring[i][j];
      cumul = false;
      n_sb = 0;
      n_db = 0;
      n_ar = 0;
      a_prev = testring[ring_size-1];
      for (j = 1; j <= ring_size; j++) {
	a_ref = testring[j-1];
	if (j < ring_size)
	  a_next = testring[j];
	else
	  a_next = testring[0];
	b_bk = get_bond(a_prev, a_ref);
	b_fw = get_bond(a_ref, a_next);
	bt_bk = bond[b_bk-1].btype;
	bt_fw = bond[b_fw-1].btype;
	if (bt_fw == 'S')
	  n_sb++;
	if (bt_fw == 'D')
	  n_db++;
	if (bt_fw == 'A')
	  n_ar++;
	if (bt_fw != 'A' && bt_bk == bt_fw)
	  cumul = true;
	a_prev = a_ref;
      }
      if (n_ar == 6 || n_sb == 3 && n_db == 3 && cumul == false)
      {  /* this ring is aromatic*/
	a_prev = testring[ring_size-1];
	for (j = 0; j <= ring_size - 1; j++) {
	  a_ref = testring[j];
	  b_bk = get_bond(a_prev, a_ref);
	  bond[b_bk-1].arom = true;
	  a_prev = a_ref;
	}
	ringprop[i].arom = true;
      }
    }
  }
  FORLIM = n_rings;
  for (i = 1; i <= FORLIM; i++) {
    if (ringprop[i-1].arom == false) {
	  /* do the hard work only for those rings which are not yet flagged aromatic*/
	    memset(testring, 0, sizeof(ringpath_type));
      ring_size = ringprop[i-1].size;   /* v0.3j*/
      for (j = 0; j <= ring_size - 1; j++)   /* v0.3j*/
	testring[j] = ring[i-1][j];
      pi_count = 0;
      arom_pi_diff = 0;   /* v0.3j*/
/* p2c: checkmol3l.pas:
 * Note: Eliminated unused assignment statement [338] */
      ko = false;
      a_prev = testring[ring_size-1];
      for (j = 1; j <= ring_size; j++) {
	a_ref = testring[j-1];
	if (j < ring_size)
	  a_next = testring[j];
	else
	  a_next = testring[0];
	b_bk = get_bond(a_prev, a_ref);
	b_fw = get_bond(a_ref, a_next);
	bt_bk = bond[b_bk-1].btype;
	bt_fw = bond[b_fw-1].btype;
	ar_bk = bond[b_bk-1].arom;
	ar_fw = bond[b_fw-1].arom;
	if (bt_bk == 'S' && bt_fw == 'S' && ar_bk == false && ar_fw == false) {
	  /* first, assume the worst case (interrupted conjugation)*/
	  conj_intr = true;
	  /* conjugation can be restored by hetero atoms*/
	  if (!strcmp(atom[a_ref-1].atype, "O3 ") ||
	      !strcmp(atom[a_ref-1].atype, "S3 ") ||
	      !strcmp(atom[a_ref-1].element, "N ") ||
	      !strcmp(atom[a_ref-1].element, "SE")) {
	    conj_intr = false;
	    pi_count += 2;   /* lone pair adds for 2 pi electrons*/
	  }
	  /* conjugation can be restored by a formal charge at a methylene group*/
	  if (!strcmp(atom[a_ref-1].element, "C ") &&
	      atom[a_ref-1].formal_charge != 0) {
	    conj_intr = false;
	    pi_count -= atom[a_ref-1].formal_charge;
		/* neg. charge increases pi_count!*/
	  }
	  /* conjugation can be restored by carbonyl groups etc.*/
	  if (is_oxo_C(a_ref) || is_thioxo_C(a_ref) ||
	      is_exocyclic_imino_C(a_ref, i))
	    conj_intr = false;
	  /* conjugation can be restored by exocyclic C=C double bond,*/
	  /* adds 2 pi electrons to 5-membered rings, not to 7-membered rings (CAUTION!)*/
	  /* apply only to non-aromatic exocyclic C=C bonds*/
	  exo_mC = find_exocyclic_methylene_C(a_ref, i);   /* v0.3j*/
	  if (exo_mC > 0 && (ring_size & 1)) {   /* v0.3j*/
	    b_exo = get_bond(a_ref, exo_mC);   /* v0.3j */
	    ar_exo = bond[b_exo-1].arom;
	    if (((ring_size - 1) & 3) == 0) {
		  /* 5-membered rings and related*/
		    conj_intr = false;
	      pi_count += 2;
	    } else {
	      if (!ar_exo)
		conj_intr = false;
	    }
	  }
	  /* 7-membered rings and related*/
	  /* if conjugation is still interrupted ==> knock-out*/
	  if (conj_intr)
	    ko = true;
	} else {
	  if (bt_bk == 'S' && bt_fw == 'S' && ar_bk == true && ar_fw == true) {
	    if (!strcmp(atom[a_ref-1].atype, "O3 ") ||
		!strcmp(atom[a_ref-1].atype, "S3 ") ||
		!strcmp(atom[a_ref-1].element, "N ") ||
		!strcmp(atom[a_ref-1].element, "SE"))
	      pi_count += 2;   /* lone pair adds for 2 pi electrons*/
	    if (!strcmp(atom[a_ref-1].element, "C ") &&
		atom[a_ref-1].formal_charge != 0)
	      pi_count -= atom[a_ref-1].formal_charge;
		  /* neg. charge increases pi_count!*/
	    exo_mC = find_exocyclic_methylene_C(a_ref, i);   /* v0.3j*/
	    if (exo_mC > 0 && (ring_size & 1)) {   /* v0.3j*/
	      b_exo = get_bond(a_ref, exo_mC);   /* v0.3j*/
/* p2c: checkmol3l.pas:
 * Note: Eliminated unused assignment statement [338] */
	      if (((ring_size - 1) & 3) == 0)
		    /* 5-membered rings and related*/
		      pi_count += 2;
	    }
	  } else {
	    pi_count++;   /* v0.3j; adjustment for bridgehead N: see below*/
	    if (bt_bk == 'S' && bt_fw == 'S' &&
		(ar_bk == true && ar_fw == false ||
		 ar_bk == false && ar_fw == true)) {
	      /* v0.3j; if a bridgehead N were not aromatic, it could */
	      /* contribute 2 pi electrons --> try also this variant*/
	      /* (example: CAS 32278-54-9)*/
	      if (!strcmp(atom[a_ref-1].element, "N ")) {
		arom_pi_diff++;
		/* any other case: increase pi count by one electron*/
	      }
	    }
	  }
	}
	/* last command:*/
	a_prev = a_ref;
      }  /* for j := 1 to ring_size*/
      /* now we can draw our conclusion*/
      /*if not ((ko) or (odd(pi_count))) then*/
      if (!ko)   /* v0.3j; odd pi_count might be compensated by arom_pi_diff*/
      {  /* apply Hueckel's rule*/
	if (abs(ring_size - pi_count) < 2 &&
	    (((pi_count - 2) & 3) == 0 ||
	     ((pi_count + arom_pi_diff - 2) & 3) == 0)) {
	  /* this ring is aromatic*/
	  ringprop[i-1].arom = true;
	  /* now mark _all_ bonds in the ring as aromatic*/
	  a_prev = testring[ring_size-1];
	  for (j = 0; j <= ring_size - 1; j++) {
	    a_ref = testring[j];
	    bond[get_bond(a_prev, a_ref) - 1].arom = true;
	    a_prev = a_ref;
	  }
	}
      }
    }
  }  /* (for i := 1 to n_rings)*/
  FORLIM = n_bonds;
  /* finally, mark all involved atoms as aromatic*/
  for (i = 0; i <= FORLIM - 1; i++) {
    if (bond[i].arom) {
      atom[bond[i].a1 - 1].arom = true;
      atom[bond[i].a2 - 1].arom = true;
    }
  }
  FORLIM = n_rings;
  /* update aromaticity information in ringprop*/
  for (i = 0; i <= FORLIM - 1; i++) {
    memcpy(testring, ring[i], sizeof(ringpath_type));
    /*ring_size := path_length(testring);*/
    ring_size = ringprop[i].size;   /* v0.3j*/
    aromatic = true;
    a_prev = testring[ring_size-1];
    for (j = 0; j <= ring_size - 1; j++) {
      a_ref = testring[j];
      if (!bond[get_bond(a_prev, a_ref) - 1].arom)
	aromatic = false;
      a_prev = a_ref;
    }
    if (aromatic)
      ringprop[i].arom = true;
    else
      ringprop[i].arom = false;
  }
}


Static void write_mol(void)
{
  short i, j;
  ringpath_type testring;
  short ring_size, FORLIM;

  /*aromatic : boolean;*/
  /*a_prev, a_ref : integer;*/
  if (progmode == pmCheckMol)
    printf("Molecule name: %s\n", molname);
  else
    printf("Molecule name (haystack): %s\n", molname);
  printf("atoms: %d  bonds: %d  rings: %d\n", n_atoms, n_bonds, n_rings);
  if (n_atoms < 1)
    return;
  if (n_bonds < 1)
    return;
  FORLIM = n_atoms;
  for (i = 1; i <= FORLIM; i++) {
    if (i < 10)
      putchar(' ');
    if (i < 100)
      putchar(' ');
    if (i < 1000)
      putchar(' ');
    printf("%d %s %s %9.4f %9.4f ",
	   i, atom[i-1].element, atom[i-1].atype, atom[i-1].x, atom[i-1].y);
    printf("%9.4f", atom[i-1].z);
    printf("  (%d heavy-atom neighbors)", atom[i-1].neighbor_count);
    if (atom[i-1].formal_charge != 0)
      printf("  charge: %d", atom[i-1].formal_charge);
    putchar('\n');
  }
  FORLIM = n_bonds;
  for (i = 1; i <= FORLIM; i++) {
    if (i < 10)
      putchar(' ');
    if (i < 100)
      putchar(' ');
    if (i < 1000)
      putchar(' ');
    printf("%d %d %d %c", i, bond[i-1].a1, bond[i-1].a2, bond[i-1].btype);
    if (bond[i-1].ring_count > 0)
      printf(", contained in %d ring(s)", bond[i-1].ring_count);
    if (bond[i-1].arom)
      printf(" (aromatic) ");
    putchar('\n');
  }
  if (n_rings <= 0)
    return;
  FORLIM = n_rings;
  for (i = 0; i <= FORLIM - 1; i++) {
    printf("ring %d: ", i + 1);
    /*aromatic := true;*/
    memset(testring, 0, sizeof(ringpath_type));
    ring_size = ringprop[i].size;   /* v0.3j*/
    /*for j := 1 to max_ringsize do if ring^[i,j] > 0 then testring[j] := ring^[i,j];*/
    for (j = 0; j <= ring_size - 1; j++)   /* v0.3j*/
      testring[j] = ring[i][j];
    /*ring_size := path_length(testring);*/
    /*a_prev := testring[ring_size];*/
    for (j = 0; j <= ring_size - 1; j++) {
      printf("%d ", testring[j]);
      /*a_ref := testring[j];*/
      /*if (not bond^[get_bond(a_prev,a_ref)].arom) then aromatic := false;*/
      /*a_prev := a_ref;*/
    }
    /*if aromatic then write(' (aromatic)');*/
    if (ringprop[i].arom)
      printf(" (aromatic)");
    if (ringprop[i].envelope)
      printf(" (env)");
    putchar('\n');
  }
}


Static void write_needle_mol(void)
{
  short i, j;
  ringpath_type testring;
  short ring_size;
  boolean aromatic;
  short a_prev, a_ref, FORLIM;

  printf("Molecule name (needle): %s\n", ndl_molname);
  printf("atoms: %d  bonds: %d  rings: %d\n",
	 ndl_n_atoms, ndl_n_bonds, ndl_n_rings);
  if (ndl_n_atoms < 1)
    return;
  if (ndl_n_bonds < 1)
    return;
  FORLIM = ndl_n_atoms;
  for (i = 1; i <= FORLIM; i++) {
    if (i < 10)
      putchar(' ');
    if (i < 100)
      putchar(' ');
    if (i < 1000)
      putchar(' ');
    printf("%d %s %s %9.4f %9.4f ",
	   i, ndl_atom[i-1].element, ndl_atom[i-1].atype, ndl_atom[i-1].x,
	   atom[i-1].y);
    printf("%9.4f", ndl_atom[i-1].z);
    printf("  (%d heavy-atom neighbors)", ndl_atom[i-1].neighbor_count);
    if (ndl_atom[i-1].formal_charge != 0)
      printf("  charge: %d", ndl_atom[i-1].formal_charge);
    putchar('\n');
  }
  FORLIM = ndl_n_bonds;
  for (i = 1; i <= FORLIM; i++) {
    if (i < 10)
      putchar(' ');
    if (i < 100)
      putchar(' ');
    if (i < 1000)
      putchar(' ');
    printf("%d %d %d %c",
	   i, ndl_bond[i-1].a1, ndl_bond[i-1].a2, ndl_bond[i-1].btype);
    if (ndl_bond[i-1].ring_count > 0)
      printf(", contained in %d ring(s)", ndl_bond[i-1].ring_count);
    if (ndl_bond[i-1].arom)
      printf(" (aromatic) ");
    putchar('\n');
  }
  if (ndl_n_rings <= 0)
    return;
  FORLIM = ndl_n_rings;
  for (i = 0; i <= FORLIM - 1; i++) {
    aromatic = true;
    memset(testring, 0, sizeof(ringpath_type));
    for (j = 0; j <= max_ringsize - 1; j++) {
      if (ndl_ring[i][j] > 0)
	testring[j] = ndl_ring[i][j];
    }
    ring_size = path_length(testring);
    printf("ring %d: ", i + 1);
    a_prev = testring[ring_size-1];
    for (j = 0; j <= ring_size - 1; j++) {
      printf("%d ", testring[j]);
      a_ref = testring[j];
      if (!ndl_bond[get_ndl_bond(a_prev, a_ref) - 1].arom)   /* v0.3k*/
	aromatic = false;
      a_prev = a_ref;
    }
    if (aromatic)
      printf(" (aromatic)");
    putchar('\n');
  }
}


Static void chk_so2_deriv(short a_ref)
{
  short i;
  neighbor_rec nb;
  str2 nb_el;
  short het_count = 0, o_count = 0, or_count = 0, hal_count = 0, n_count = 0,
	c_count = 0;
  short FORLIM;

  memset(nb, 0, sizeof(neighbor_rec));
  if (strcmp(atom[a_ref-1].atype, "SO2"))
    return;
  get_neighbors(nb, a_ref);
  FORLIM = atom[a_ref-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (bond[get_bond(a_ref, nb[i]) - 1].btype == 'S') {
      strcpy(nb_el, atom[nb[i] - 1].element);
      if (strcmp(nb_el, "C ") && strcmp(nb_el, "H ") && strcmp(nb_el, "DU") &&
	  strcmp(nb_el, "LP"))
	het_count++;
      if (!strcmp(nb_el, "O ")) {
	o_count++;
	if (is_alkoxy(a_ref, nb[i]) || is_aryloxy(a_ref, nb[i]))
	  or_count++;
      }
      if (!strcmp(nb_el, "N "))
	n_count++;
      if (!strcmp(nb_el, "C "))
	c_count++;
      if (!strcmp(nb_el, "F ") || !strcmp(nb_el, "CL") ||
	  !strcmp(nb_el, "BR") || !strcmp(nb_el, "I "))
	hal_count++;
    }
  }
  if (het_count == 2) {   /* sulfuric acid derivative*/
    fg[fg_sulfuric_acid_deriv-1] = true;
    if (o_count == 2) {
      if (or_count == 0)
	fg[fg_sulfuric_acid-1] = true;
      if (or_count == 1)
	fg[fg_sulfuric_acid_monoester-1] = true;
      if (or_count == 2)
	fg[fg_sulfuric_acid_diester-1] = true;
    }
    if (o_count == 1) {
      if (or_count == 1 && n_count == 1)
	fg[fg_sulfuric_acid_amide_ester-1] = true;
      if (or_count == 0 && n_count == 1)
	fg[fg_sulfuric_acid_amide-1] = true;
    }
    if (n_count == 2)
      fg[fg_sulfuric_acid_diamide-1] = true;
    if (hal_count > 0)
      fg[fg_sulfuryl_halide-1] = true;
  }
  if (het_count == 1 && c_count == 1) {   /* sulfonic acid derivative*/
    fg[fg_sulfonic_acid_deriv-1] = true;
    if (o_count == 1 && or_count == 0)
      fg[fg_sulfonic_acid-1] = true;
    if (o_count == 1 && or_count == 1)
      fg[fg_sulfonic_acid_ester-1] = true;
    if (n_count == 1)
      fg[fg_sulfonamide-1] = true;
    if (hal_count == 1)
      fg[fg_sulfonyl_halide-1] = true;
  }
  if (het_count == 0 && c_count == 2)   /* sulfone*/
    fg[fg_sulfone-1] = true;
}


Static void chk_p_deriv(short a_ref)
{
  short i;
  neighbor_rec nb;
  str2 nb_el, dbl_het;
  short het_count;
  short oh_count = 0, or_count = 0, hal_count = 0, n_count = 0, c_count = 0;
  short FORLIM;

  if (strcmp(atom[a_ref-1].element, "P "))
    return;
  memset(nb, 0, sizeof(neighbor_rec));
  get_neighbors(nb, a_ref);
  *dbl_het = '\0';
/* p2c: checkmol3l.pas:
 * Note: Eliminated unused assignment statement [338] */
  FORLIM = atom[a_ref-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (bond[get_bond(a_ref, nb[i]) - 1].btype == 'D')
      strcpy(dbl_het, atom[nb[i] - 1].element);
    if (bond[get_bond(a_ref, nb[i]) - 1].btype == 'S') {
      strcpy(nb_el, atom[nb[i] - 1].element);
      if (!strcmp(nb_el, "C "))
	c_count++;
      if (is_hydroxy(a_ref, nb[i]))
	oh_count++;
      if (is_alkoxy(a_ref, nb[i]) || is_aryloxy(a_ref, nb[i]))
	or_count++;
      if (!strcmp(nb_el, "N "))
	n_count++;
      if (!strcmp(nb_el, "F ") || !strcmp(nb_el, "CL") ||
	  !strcmp(nb_el, "BR") || !strcmp(nb_el, "I "))
	hal_count++;
    }
  }
  het_count = oh_count + or_count + hal_count + n_count;
  if (!strcmp(atom[a_ref-1].atype, "P3D") ||
      !strcmp(atom[a_ref-1].atype, "P4 ")) {
    if (!strcmp(dbl_het, "O ")) {
      if (c_count == 0) {
	fg[fg_phosphoric_acid_deriv-1] = true;
	if (oh_count == 3)
	  fg[fg_phosphoric_acid-1] = true;
	if (or_count > 0)
	  fg[fg_phosphoric_acid_ester-1] = true;
	if (hal_count > 0)
	  fg[fg_phosphoric_acid_halide-1] = true;
	if (n_count > 0)
	  fg[fg_phosphoric_acid_amide-1] = true;
      }
      if (c_count == 1) {
	fg[fg_phosphonic_acid_deriv-1] = true;
	if (oh_count == 2)
	  fg[fg_phosphonic_acid-1] = true;
	if (or_count > 0)
	  fg[fg_phosphonic_acid_ester-1] = true;
	/*if (hal_count > 0)  then fg[fg_phosphonic_acid_halide] := true;            */
	/*if (n_count > 0)    then fg[fg_phosphonic_acid_amide]  := true;*/
      }
      if (c_count == 3)
	fg[fg_phosphinoxide-1] = true;
    }
    if (!strcmp(dbl_het, "S ")) {
      if (c_count == 0) {
	fg[fg_thiophosphoric_acid_deriv-1] = true;
	if (oh_count == 3)
	  fg[fg_thiophosphoric_acid-1] = true;
	if (or_count > 0)
	  fg[fg_thiophosphoric_acid_ester-1] = true;
	if (hal_count > 0)
	  fg[fg_thiophosphoric_acid_halide-1] = true;
	if (n_count > 0)
	  fg[fg_thiophosphoric_acid_amide-1] = true;
      }
    }
  }
  /*  if (atom^[a_ref].atype = 'P4 ') then fg[fg_phosphoric_acid_deriv] := true;*/
  if (strcmp(atom[a_ref-1].atype, "P3 "))   /* changed P3D into P3 in v0.3b*/
    return;
  if (c_count == 3 && het_count == 0)
    fg[fg_phosphine-1] = true;
  if (c_count == 3 && oh_count == 1)
    fg[fg_phosphinoxide-1] = true;
}


Static void chk_b_deriv(short a_ref)
{
  short i;
  neighbor_rec nb;
  str2 nb_el;
  short het_count = 0, oh_count = 0, or_count = 0, hal_count = 0, n_count = 0,
	c_count = 0;
  short FORLIM;

  if (strcmp(atom[a_ref-1].element, "B "))
    return;
  memset(nb, 0, sizeof(neighbor_rec));
  get_neighbors(nb, a_ref);
  FORLIM = atom[a_ref-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (bond[get_bond(a_ref, nb[i]) - 1].btype == 'S') {
      strcpy(nb_el, atom[nb[i] - 1].element);
      if (!strcmp(nb_el, "C "))
	c_count++;
      else if (strcmp(nb_el, "H ") && strcmp(nb_el, "LP"))
	het_count++;
      if (is_hydroxy(a_ref, nb[i]))
	oh_count++;
      if (is_alkoxy(a_ref, nb[i]) || is_aryloxy(a_ref, nb[i]))
	    /* fixed in v0.3b*/
	      or_count++;
      if (!strcmp(nb_el, "N "))
	n_count++;
      if (!strcmp(nb_el, "F ") || !strcmp(nb_el, "CL") ||
	  !strcmp(nb_el, "BR") || !strcmp(nb_el, "I "))
	hal_count++;
    }
  }
  het_count = oh_count + or_count + hal_count + n_count;   /* fixed in v0.3b*/
  if (c_count != 1 || het_count != 2)
    return;
  fg[fg_boronic_acid_deriv-1] = true;
  if (oh_count == 2)
    fg[fg_boronic_acid-1] = true;
  if (or_count > 0)
    fg[fg_boronic_acid_ester-1] = true;
}


Static void chk_ammon(short a_ref)
{
  short i;
  neighbor_rec nb;
  str2 nb_el;
  short het_count = 0, o_count = 0, or_count = 0, r_count = 0;
  Char bt;   /* v0.3k*/
  float bo_sum = 0.0;
  boolean ha;
  short FORLIM;

  memset(nb, 0, sizeof(neighbor_rec));
  if (strcmp(atom[a_ref-1].atype, "N3+") && atom[a_ref-1].formal_charge == 0)
    return;
  if (strcmp(atom[a_ref-1].element, "N "))   /* just to be sure;  v0.3i*/
    return;
  get_neighbors(nb, a_ref);
  FORLIM = atom[a_ref-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    bt = bond[get_bond(a_ref, nb[i]) - 1].btype;   /* v0.3k*/
    strcpy(nb_el, atom[nb[i] - 1].element);   /* v0.3k*/
    ha = atom[nb[i] - 1].heavy;   /* v0.3k*/
    if (bt == 'S') {
      if (ha)
	bo_sum += 1.0;
      if (strcmp(nb_el, "C ") && strcmp(nb_el, "H ") && strcmp(nb_el, "DU")) {
	het_count++;
	if (!strcmp(nb_el, "O ")) {
	  o_count++;
	  if (atom[nb[i] - 1].neighbor_count > 1)
	    or_count++;
	}
      }
      if (is_alkyl(a_ref, nb[i]) || is_aryl(a_ref, nb[i]) ||
	  is_alkenyl(a_ref, nb[i]) || is_alkynyl(a_ref, nb[i]))
	    /* v0.3k*/
	      r_count++;
    }
    if (bt == 'D') {
      if (ha)
	bo_sum += 2.0;
      if (strcmp(nb_el, "C ")) {
	het_count += 2;
	if (!strcmp(nb_el, "O "))
	  o_count += 2;
      }
      if (!strcmp(nb_el, "C "))
	r_count++;
    }
    if (bt == 'A' && ha)
      bo_sum += 1.5;
  }  /* v0.3k: corrected end of "for ..." loop*/
  if (het_count == 0 && r_count == 4)
    fg[fg_quart_ammonium-1] = true;
  if (het_count != 1 || atom[a_ref-1].neighbor_count < 3)
    return;
  if (o_count == 1 && or_count == 0 && bo_sum > 3)
    fg[fg_n_oxide-1] = true;   /* finds only aliphatic N-oxides!*/
  if ((o_count == 1 && or_count == 1 || o_count == 0) &&
      atom[a_ref-1].arom == true)
    fg[fg_quart_ammonium-1] = true;
}


Static void swap_atoms(short *a1, short *a2)
{
  short a_tmp;

  a_tmp = *a1;
  *a1 = *a2;
  *a2 = a_tmp;
}


Static void orient_bond(short *a1, short *a2)
{
  str2 a1_el, a2_el;

  strcpy(a1_el, atom[*a1 - 1].element);
  strcpy(a2_el, atom[*a2 - 1].element);
  if (!strcmp(a1_el, "H ") || !strcmp(a2_el, "H "))
    return;
  if (!strcmp(a2_el, "C ") && strcmp(a1_el, "C "))
    swap_atoms(a1, a2);
  if (!strcmp(a2_el, a1_el)) {
    if (hetbond_count(*a1) > hetbond_count(*a2))
      swap_atoms(a1, a2);
  }
  if (strcmp(a2_el, "C ") && strcmp(a1_el, "C ") && strcmp(a1_el, a2_el)) {
    if (!strcmp(a1_el, "O ") || !strcmp(a2_el, "O ")) {
      if (!strcmp(a1_el, "O "))
	swap_atoms(a1, a2);
    }
  }
  if (strcmp(a2_el, "C ") && strcmp(a1_el, "C ") && !strcmp(a1_el, a2_el)) {
    if (atom[*a2 - 1].neighbor_count - hetbond_count(*a2) >
	atom[*a1 - 1].neighbor_count - hetbond_count(*a1))
      swap_atoms(a1, a2);
  }
}


Static void chk_imine(short a_ref, short a_view)
{
  /* a_ref = C, a_view = N*/
  short i;
  neighbor_rec nb;
  str2 nb_el;
  short a_het, a_c;
  short het_count = 0, c_count = 0, o_count = 0;   /* v0.3k*/
  short FORLIM;

  /* v0.3k*/
  if (atom[a_view-1].neighbor_count == 1) {
    if (atom[a_ref-1].arom == false)
      fg[fg_imine-1] = true;
    return;
  }
  memset(nb, 0, sizeof(neighbor_rec));
  get_neighbors(nb, a_view);
  if (atom[a_view-1].neighbor_count <= 1)
    return;
  FORLIM = atom[a_view-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (nb[i] != a_ref && bond[get_bond(a_view, nb[i]) - 1].btype == 'S') {
      strcpy(nb_el, atom[nb[i] - 1].element);
      if (!strcmp(nb_el, "C ")) {
	a_c = nb[i];
	c_count++;
      }
      if (!strcmp(nb_el, "O ") || !strcmp(nb_el, "N ")) {
	a_het = nb[i];
	het_count++;
      }
      if (!strcmp(nb_el, "O ") && atom[nb[i] - 1].neighbor_count == 1 &&
	  bond[get_bond(a_view, nb[i]) - 1].arom == false)
	    /* v0.3k*/
	      o_count++;
    }
    if (nb[i] != a_ref && bond[get_bond(a_view, nb[i]) - 1].btype == 'D')
    {  /* v0.3k; make sure we do not count nitro groups in "azi" form etc.*/
      strcpy(nb_el, atom[nb[i] - 1].element);
      if (!strcmp(nb_el, "O ") || !strcmp(nb_el, "N ") || !strcmp(nb_el, "S "))
	het_count++;
      if (!strcmp(nb_el, "O ") && atom[nb[i] - 1].neighbor_count == 1 &&
	  bond[get_bond(a_view, nb[i]) - 1].arom == false)
	    /* v0.3k*/
	      o_count++;
    }
  }
  if (c_count == 1) {
    if ((is_alkyl(a_view, a_c) || is_aryl(a_view, a_c) ||
	 is_alkenyl(a_view, a_c) || is_alkynyl(a_view, a_c)) &&
	atom[a_ref-1].arom == false && het_count == 0)
	  /* v0.3k*/
	    fg[fg_imine-1] = true;
  }
  if (het_count == 1) {
    strcpy(nb_el, atom[a_het-1].element);
    if (!strcmp(nb_el, "O ")) {
      if (is_hydroxy(a_view, a_het))
	fg[fg_oxime-1] = true;
      if (is_alkoxy(a_view, a_het) || is_aryloxy(a_view, a_het) ||
	  is_alkenyloxy(a_view, a_het) || is_alkynyloxy(a_view, a_het))
	fg[fg_oxime_ether-1] = true;
    }
    if (!strcmp(nb_el, "N ")) {
      if (is_amino(a_view, a_het) || is_alkylamino(a_view, a_het) ||
	  is_dialkylamino(a_view, a_het) ||
	  is_alkylarylamino(a_view, a_het) || is_arylamino(a_view, a_het) ||
	  is_diarylamino(a_view, a_het))
	fg[fg_hydrazone-1] = true;
      else {
	memset(nb, 0, sizeof(neighbor_rec));
	get_neighbors(nb, a_het);
	if (atom[a_het-1].neighbor_count > 1) {
	  FORLIM = atom[a_het-1].neighbor_count;
	  for (i = 0; i <= FORLIM - 1; i++) {
	    if (nb[i] != a_view) {
	      if (is_carbamoyl(a_het, nb[i]))
		fg[fg_semicarbazone-1] = true;
	      if (is_thiocarbamoyl(a_het, nb[i]))
		fg[fg_thiosemicarbazone-1] = true;
	    }
	  }
	}
      }
    }
  }  /* v0.3k: nitro groups in "azi" form*/
  /* check for semicarbazone or thiosemicarbazone*/
  if (het_count == 2 && o_count == 2)
    fg[fg_nitro_compound-1] = true;
}


Static void chk_carbonyl_deriv(short a_view, short a_ref)
{
  /* a_view = C*/
  short i;
  neighbor_rec nb;
  str2 nb_el;
  short c_count = 0, cn_count = 0;
  Char bt;   /* new in v0.3b*/
  short n_db = 0;   /* new in v0.3b*/
  short FORLIM;

  memset(nb, 0, sizeof(neighbor_rec));
  get_neighbors(nb, a_view);
  FORLIM = atom[a_view-1].neighbor_count;
  /* new in v0.3b*/
  for (i = 0; i <= FORLIM - 1; i++) {
    bt = bond[get_bond(a_view, nb[i]) - 1].btype;
    if (bt == 'S') {
      strcpy(nb_el, atom[nb[i] - 1].element);
      if (!strcmp(nb_el, "C ")) {
	if (is_cyano_c(nb[i]))
	  cn_count++;
	else
	  c_count++;
      }
    } else {
      if (bt == 'D')
	n_db++;
    }
  }
  /* new in v0.3b*/
  if (is_oxo_C(a_view)) {
    fg[fg_carbonyl-1] = true;
    if (c_count + cn_count < 2) {  /* new in v0.3b (detection of ketenes)*/
      if (n_db <= 1)
	fg[fg_aldehyde-1] = true;
      else
	fg[fg_ketene-1] = true;
    }
    if (c_count == 2) {
      if (atom[a_view-1].arom)
	fg[fg_oxohetarene-1] = true;
      else
	fg[fg_ketone-1] = true;
    }
    if (cn_count > 0)
      fg[fg_acyl_cyanide-1] = true;
  }
  if (is_thioxo_C(a_view)) {
    fg[fg_thiocarbonyl-1] = true;
    if (c_count < 2)
      fg[fg_thioaldehyde-1] = true;
    if (c_count == 2) {
      if (atom[a_view-1].arom)
	fg[fg_thioxohetarene-1] = true;
      else
	fg[fg_thioketone-1] = true;
    }
  }
  if (is_imino_C(a_view))
    chk_imine(a_view, a_ref);
}


Static void chk_carboxyl_deriv(short a_view, short a_ref)
{
  short i;
  neighbor_rec nb;
  str2 nb_el;
  short o_count = 0, n_count = 0, s_count = 0;
  short a_o, a_n, a_s, FORLIM;

  memset(nb, 0, sizeof(neighbor_rec));
  get_neighbors(nb, a_view);
  FORLIM = atom[a_view-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (bond[get_bond(a_view, nb[i]) - 1].btype == 'S') {
      strcpy(nb_el, atom[nb[i] - 1].element);
      if (strcmp(nb_el, "C ")) {
	if (!strcmp(nb_el, "O ")) {
	  o_count++;
	  a_o = nb[i];
	}
	if (!strcmp(nb_el, "N ")) {
	  n_count++;
	  a_n = nb[i];
	}
	if (!strcmp(nb_el, "S ")) {
	  s_count++;
	  a_s = nb[i];
	}
      }
    }
  }
  if (is_oxo_C(a_view)) {
    if (o_count == 1) {  /* anhydride is checked somewhere else*/
      if (bond[get_bond(a_view, a_o) - 1].arom == false)
	fg[fg_carboxylic_acid_deriv-1] = true;
      if (is_hydroxy(a_view, a_o)) {
	if (atom[a_o-1].formal_charge == 0)
	  fg[fg_carboxylic_acid-1] = true;
	if (atom[a_o-1].formal_charge == -1)
	  fg[fg_carboxylic_acid_salt-1] = true;
      }
      if (is_alkoxy(a_view, a_o) || is_aryloxy(a_view, a_o) ||
	  is_alkenyloxy(a_view, a_o) || is_alkynyloxy(a_view, a_o)) {
	if (bond[get_bond(a_view, a_o) - 1].arom == false)
	  fg[fg_carboxylic_acid_ester-1] = true;
	if (bond[get_bond(a_view, a_o) - 1].ring_count > 0) {
	  if (bond[get_bond(a_view, a_o) - 1].arom == true) {
	    /*fg[fg_lactone_heteroarom] := true else fg[fg_lactone] := true;*/
	    fg[fg_oxohetarene-1] = true;
	  } else
	    fg[fg_lactone-1] = true;
	}
      }
    }
    if (n_count == 1) {
      if (bond[get_bond(a_view, a_n) - 1].arom == false)
	fg[fg_carboxylic_acid_deriv-1] = true;
      else {
	/*fg[fg_lactam_heteroarom] := true;  { catches also pyridazines, 1,2,3-triazines, etc.*/
	fg[fg_oxohetarene-1] = true;
      }
      if (is_amino(a_view, a_n) || (!strcmp(atom[a_n-1].atype, "NAM") &&
				    atom[a_n-1].neighbor_count == 1)) {
	fg[fg_carboxylic_acid_amide-1] = true;
	fg[fg_carboxylic_acid_prim_amide-1] = true;
      }
      /*if (is_alkylamino(a_view,a_n)) or (is_arylamino(a_view,a_n)) then */
      if (is_C_monosubst_amino(a_view, a_n) &&
	  !is_subst_acylamino(a_view, a_n))
      {   /* v0.3j*/
	if (bond[get_bond(a_view, a_n) - 1].arom == false)
	  fg[fg_carboxylic_acid_amide-1] = true;
	if (bond[get_bond(a_view, a_n) - 1].arom == false)
	  fg[fg_carboxylic_acid_sec_amide-1] = true;
	if (bond[get_bond(a_view, a_n) - 1].ring_count > 0) {
	  if (bond[get_bond(a_view, a_n) - 1].arom == true) {
	    /*fg[fg_lactam_heteroarom]    := true else */
	    fg[fg_oxohetarene-1] = true;
	  } else
	    fg[fg_lactam-1] = true;
	}
      }
      /*if (is_dialkylamino(a_view,a_n)) or (is_alkylarylamino(a_view,a_n)) or*/
      /*   (is_diarylamino(a_view,a_n)) then */
      if (is_C_disubst_amino(a_view, a_n) && !is_subst_acylamino(a_view, a_n))
      {   /* v0.3j*/
	if (bond[get_bond(a_view, a_n) - 1].arom == false)
	  fg[fg_carboxylic_acid_amide-1] = true;
	if (bond[get_bond(a_view, a_n) - 1].arom == false)
	  fg[fg_carboxylic_acid_tert_amide-1] = true;
	if (bond[get_bond(a_view, a_n) - 1].ring_count > 0) {
	  if (bond[get_bond(a_view, a_n) - 1].arom == true) {
	    /*fg[fg_lactam_heteroarom]    := true else */
	    fg[fg_oxohetarene-1] = true;
	  } else
	    fg[fg_lactam-1] = true;
	}
      }
      if (is_hydroxylamino(a_view, a_n))
	fg[fg_hydroxamic_acid-1] = true;
      if (is_hydrazino(a_view, a_n))
	fg[fg_carboxylic_acid_hydrazide-1] = true;
      if (is_azido(a_view, a_n))
	fg[fg_carboxylic_acid_azide-1] = true;
    }
    if (s_count == 1) {  /* anhydride is checked somewhere else*/
      if (bond[get_bond(a_view, a_s) - 1].arom == false)
	fg[fg_thiocarboxylic_acid_deriv-1] = true;
      if (is_sulfanyl(a_view, a_s))
	fg[fg_thiocarboxylic_acid-1] = true;
      if (is_alkylsulfanyl(a_view, a_s) || is_arylsulfanyl(a_view, a_s)) {
	if (bond[get_bond(a_view, a_s) - 1].arom == false)
	  fg[fg_thiocarboxylic_acid_ester-1] = true;
	if (bond[get_bond(a_view, a_s) - 1].ring_count > 0) {
	  if (bond[get_bond(a_view, a_s) - 1].arom == true) {
	    /*fg[fg_thiolactone_heteroarom] := true else fg[fg_thiolactone] := true;*/
	    fg[fg_oxohetarene-1] = true;
	  } else
	    fg[fg_thiolactone-1] = true;
	}
      }
    }
  }  /* end Oxo-C*/
  if (is_thioxo_C(a_view)) {
    /* fg[fg_thiocarboxylic_acid_deriv]  := true;*/
    if (o_count == 1) {  /* anhydride is checked somewhere else*/
      if (bond[get_bond(a_view, a_o) - 1].arom == false)
	fg[fg_thiocarboxylic_acid_deriv-1] = true;
      if (is_hydroxy(a_view, a_o))
	fg[fg_thiocarboxylic_acid-1] = true;   /* fixed in v0.3c*/
      if (is_alkoxy(a_view, a_o) || is_aryloxy(a_view, a_o)) {
	if (bond[get_bond(a_view, a_s) - 1].arom == false)
	  fg[fg_thiocarboxylic_acid_ester-1] = true;
	if (bond[get_bond(a_view, a_o) - 1].ring_count > 0) {
	  if (bond[get_bond(a_view, a_o) - 1].arom == true) {
	    /*fg[fg_thiolactone_heteroarom] := true else fg[fg_thiolactone] := true;*/
	    fg[fg_thioxohetarene-1] = true;
	  } else
	    fg[fg_thiolactone-1] = true;
	}
      }
    }
    if (n_count == 1) {
      if (bond[get_bond(a_view, a_n) - 1].arom == false)
	fg[fg_thiocarboxylic_acid_deriv-1] = true;
      else {
	/*fg[fg_thiolactam_heteroarom] := true;  { catches also pyridazines, 1,2,3-triazines, etc.*/
	fg[fg_thioxohetarene-1] = true;
      }
      /* catches also pyridazines, 1,2,3-triazines, etc.*/
      if (is_amino(a_view, a_n)) {
	fg[fg_thiocarboxylic_acid_amide-1] = true;
	/* fg[fg_thiocarboxylic_acid_prim_amide] := true;*/
      }
      /*if (is_alkylamino(a_view,a_n)) or (is_arylamino(a_view,a_n)) then */
      if (is_C_monosubst_amino(a_view, a_n) &&
	  !is_subst_acylamino(a_view, a_n))
      {   /* v0.3j*/
	if (bond[get_bond(a_view, a_n) - 1].arom == false)
	  fg[fg_thiocarboxylic_acid_amide-1] = true;
	/*fg[fg_thiocarboxylic_acid_sec_amide]  := true;*/
	if (bond[get_bond(a_view, a_n) - 1].ring_count > 0) {
	  if (bond[get_bond(a_view, a_n) - 1].arom == true) {
	    /*fg[fg_thiolactam_heteroarom] := true else fg[fg_thiolactam] := true;*/
	    fg[fg_thioxohetarene-1] = true;
	  } else
	    fg[fg_thiolactam-1] = true;
	}
      }
      /*if (is_dialkylamino(a_view,a_n)) or (is_alkylarylamino(a_view,a_n)) or*/
      /*   (is_diarylamino(a_view,a_n)) then */
      if (is_C_disubst_amino(a_view, a_n) && !is_subst_acylamino(a_view, a_n))
      {   /* v0.3j*/
	if (bond[get_bond(a_view, a_n) - 1].arom == false)
	  fg[fg_thiocarboxylic_acid_amide-1] = true;
	/*fg[fg_thiocarboxylic_acid_tert_amide] := true;*/
	if (bond[get_bond(a_view, a_n) - 1].ring_count > 0) {
	  if (bond[get_bond(a_view, a_n) - 1].arom == true) {
	    /*fg[fg_thiolactam_heteroarom] := true else fg[fg_thiolactam] := true;*/
	    fg[fg_thioxohetarene-1] = true;
	  } else
	    fg[fg_thiolactam-1] = true;
	}
      }
    }
    if (s_count == 1) {  /* anhydride is checked somewhere else*/
      if (bond[get_bond(a_view, a_s) - 1].arom == false)
	fg[fg_thiocarboxylic_acid_deriv-1] = true;
      if (is_sulfanyl(a_view, a_s))
	fg[fg_thiocarboxylic_acid-1] = true;
      if (is_alkylsulfanyl(a_view, a_s) || is_arylsulfanyl(a_view, a_s)) {
	if (bond[get_bond(a_view, a_s) - 1].arom == false)
	  fg[fg_thiocarboxylic_acid_ester-1] = true;
	if (bond[get_bond(a_view, a_s) - 1].ring_count > 0) {
	  if (bond[get_bond(a_view, a_s) - 1].arom == true) {
	    /*fg[fg_thiolactone_heteroarom] := true else fg[fg_thiolactone] := true;*/
	    fg[fg_thioxohetarene-1] = true;
	  } else
	    fg[fg_thiolactone-1] = true;
	}
      }
    }
  }  /* end Thioxo-C*/
  if (is_true_imino_C(a_view)) {
    if (o_count == 1) {
      if (bond[get_bond(a_view, a_o) - 1].arom == false)
	fg[fg_carboxylic_acid_deriv-1] = true;
      if (is_alkoxy(a_view, a_o) || is_aryloxy(a_view, a_o)) {
	if (bond[get_bond(a_view, a_o) - 1].arom == false)
	  fg[fg_imido_ester-1] = true;
      }
    }
    if (n_count == 1 && bond[get_bond(a_view, a_n) - 1].arom == false) {
      if (bond[get_bond(a_view, a_n) - 1].arom == false)
	fg[fg_carboxylic_acid_deriv-1] = true;
      if (is_amino(a_view, a_n) || is_subst_amino(a_view, a_n)) {
	if (bond[get_bond(a_view, a_n) - 1].arom == false)
	  fg[fg_carboxylic_acid_deriv-1] = true;
	fg[fg_carboxylic_acid_amidine-1] = true;
      }
      if (is_hydrazino(a_view, a_n)) {
	if (bond[get_bond(a_view, a_n) - 1].arom == false)
	  fg[fg_carboxylic_acid_amidrazone-1] = true;
      }
    }
    if (n_count == 1 && bond[get_bond(a_view, a_n) - 1].arom == true)
	  /* catches also pyridazines, 1,2,3-triazines, etc.*/
	    fg[fg_iminohetarene-1] = true;
    if (s_count == 1) {
      if (bond[get_bond(a_view, a_s) - 1].arom == false)
	fg[fg_carboxylic_acid_deriv-1] = true;
      if (is_alkylsulfanyl(a_view, a_s) || is_arylsulfanyl(a_view, a_s)) {
	if (bond[get_bond(a_view, a_s) - 1].arom == false)
	  fg[fg_imido_thioester-1] = true;
      }
    }
  }
  if (is_hydroximino_C(a_view)) {
    if (bond[get_bond(a_view, a_n) - 1].arom == false)
      fg[fg_carboxylic_acid_deriv-1] = true;
    if (o_count == 1) {
      if (is_hydroxy(a_view, a_o))
	fg[fg_hydroxamic_acid-1] = true;
    }
  }
  if (!is_hydrazono_C(a_view))
    return;
  if (bond[get_bond(a_view, a_n) - 1].arom == false)
    fg[fg_carboxylic_acid_deriv-1] = true;
  if (n_count == 1) {
    if (is_amino(a_view, a_n) || is_subst_amino(a_view, a_n))
      fg[fg_carboxylic_acid_amidrazone-1] = true;
  }
}


Static void chk_co2_sp2(short a_view, short a_ref)
{
  short i;
  neighbor_rec nb;
  str2 nb_el;
  short o_count = 0, or_count = 0, n_count = 0, nn_count = 0, nnx_count = 0,
	s_count = 0, sr_count = 0;
  short FORLIM;

  memset(nb, 0, sizeof(neighbor_rec));
  get_neighbors(nb, a_view);
  FORLIM = atom[a_view-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (bond[get_bond(a_view, nb[i]) - 1].btype == 'S') {
      strcpy(nb_el, atom[nb[i] - 1].element);
      if (strcmp(nb_el, "C ")) {
	if (!strcmp(nb_el, "O ")) {
	  o_count++;
	  if (is_alkoxy(a_view, nb[i]) || is_alkenyloxy(a_view, nb[i]) ||
	      is_aryloxy(a_view, nb[i]))
		/* v0.3j*/
		  or_count++;
	}
	if (!strcmp(nb_el, "N ")) {
	  n_count++;
	  if (is_hydrazino(a_view, nb[i]))
	    nn_count++;
	  if (is_subst_hydrazino(a_view, nb[i]))   /* more general...*/
	    nnx_count++;
	}
	if (!strcmp(nb_el, "S ")) {
	  s_count++;
	  if (is_alkylsulfanyl(a_view, nb[i]) ||
	      is_arylsulfanyl(a_view, nb[i]))
	    sr_count++;
	}
      }
    }
  }
  if (is_oxo_C(a_view)) {
    if (o_count == 2) {
      fg[fg_carbonic_acid_deriv-1] = true;
      if (or_count == 1)
	fg[fg_carbonic_acid_monoester-1] = true;
      if (or_count == 2)
	fg[fg_carbonic_acid_diester-1] = true;
    }
    if (o_count == 1 && s_count == 1) {
      fg[fg_thiocarbonic_acid_deriv-1] = true;
      if (or_count + sr_count == 1)
	fg[fg_thiocarbonic_acid_monoester-1] = true;
      if (or_count + sr_count == 2)
	fg[fg_thiocarbonic_acid_diester-1] = true;
    }
    if (s_count == 2) {
      fg[fg_thiocarbonic_acid_deriv-1] = true;
      if (sr_count == 1)
	fg[fg_thiocarbonic_acid_monoester-1] = true;
      if (sr_count == 2)
	fg[fg_thiocarbonic_acid_diester-1] = true;
    }
    if (o_count == 1 && n_count == 1) {
      fg[fg_carbamic_acid_deriv-1] = true;
      if (or_count == 0)
	fg[fg_carbamic_acid-1] = true;
      if (or_count == 1)
	fg[fg_carbamic_acid_ester-1] = true;
    }
    if (s_count == 1 && n_count == 1) {
      fg[fg_thiocarbamic_acid_deriv-1] = true;
      if (sr_count == 0)
	fg[fg_thiocarbamic_acid-1] = true;
      if (sr_count == 1)
	fg[fg_thiocarbamic_acid_ester-1] = true;
    }
    if (n_count == 2) {
      if (nn_count == 1)
	fg[fg_semicarbazide-1] = true;
      else {
	if (nnx_count == 0)   /* excludes semicarbazones*/
	  fg[fg_urea-1] = true;
      }
    }
  }  /* end Oxo-C*/
  if (is_thioxo_C(a_view)) {
    if (o_count == 2) {
      fg[fg_thiocarbonic_acid_deriv-1] = true;
      if (or_count == 1)
	fg[fg_thiocarbonic_acid_monoester-1] = true;
      if (or_count == 2)
	fg[fg_thiocarbonic_acid_diester-1] = true;
    }
    if (o_count == 1 && s_count == 1) {
      fg[fg_thiocarbonic_acid_deriv-1] = true;
      if (or_count + sr_count == 1)
	fg[fg_thiocarbonic_acid_monoester-1] = true;
      if (or_count + sr_count == 2)
	fg[fg_thiocarbonic_acid_diester-1] = true;
    }
    if (s_count == 2) {
      fg[fg_thiocarbonic_acid_deriv-1] = true;
      if (sr_count == 1)
	fg[fg_thiocarbonic_acid_monoester-1] = true;
      if (sr_count == 2)
	fg[fg_thiocarbonic_acid_diester-1] = true;
    }
    if (o_count == 1 && n_count == 1) {
      fg[fg_thiocarbamic_acid_deriv-1] = true;
      if (or_count == 0)
	fg[fg_thiocarbamic_acid-1] = true;
      if (or_count == 1)
	fg[fg_thiocarbamic_acid_ester-1] = true;
    }
    if (s_count == 1 && n_count == 1) {
      fg[fg_thiocarbamic_acid_deriv-1] = true;
      if (sr_count == 0)
	fg[fg_thiocarbamic_acid-1] = true;
      if (sr_count == 1)
	fg[fg_thiocarbamic_acid_ester-1] = true;
    }
    if (n_count == 2) {
      if (nn_count == 1)
	fg[fg_thiosemicarbazide-1] = true;
      else {
	if (nnx_count == 0)   /* excludes thiosemicarbazones*/
	  fg[fg_thiourea-1] = true;
      }
    }
  }  /* end Thioxo-C*/
  if (!(is_true_imino_C(a_view) &&
	bond[get_bond(a_view, a_ref) - 1].arom == false)) {
    return;
  }  /* end Imino-C*/
  if (o_count == 1 && n_count == 1)
    fg[fg_isourea-1] = true;
  if (s_count == 1 && n_count == 1)
    fg[fg_isothiourea-1] = true;
  if (n_count == 2)
    fg[fg_guanidine-1] = true;
}


Static void chk_co2_sp(short a_view, short a_ref)
{
  short i;
  neighbor_rec nb;
  str2 nb_el;
  short o_count = 0, n_count = 0, s_count = 0;
  short FORLIM;

  memset(nb, 0, sizeof(neighbor_rec));
  get_neighbors(nb, a_view);
  FORLIM = atom[a_view-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (bond[get_bond(a_view, nb[i]) - 1].btype == 'D') {
      strcpy(nb_el, atom[nb[i] - 1].element);
      if (strcmp(nb_el, "C ")) {
	if (!strcmp(nb_el, "O "))
	  o_count++;
	if (!strcmp(nb_el, "N "))
	  n_count++;
	if (!strcmp(nb_el, "S "))
	  s_count++;
      }
    }
  }
  if (o_count + s_count == 2)   /* new in v0.3b*/
    fg[fg_co2_deriv-1] = true;
  if (o_count == 1 && n_count == 1)
    fg[fg_isocyanate-1] = true;
  if (s_count == 1 && n_count == 1)
    fg[fg_isothiocyanate-1] = true;
  if (n_count == 2)
    fg[fg_carbodiimide-1] = true;
}


Static void chk_triple(short a1, short a2)
{
  str2 a1_el, a2_el;

  strcpy(a1_el, atom[a1-1].element);
  strcpy(a2_el, atom[a2-1].element);
  if (!strcmp(a1_el, "C ") && !strcmp(a2_el, "C ") &&
      bond[get_bond(a1, a2) - 1].arom == false)
    fg[fg_alkyne-1] = true;
  if (is_nitrile(a1, a2))
    fg[fg_nitrile-1] = true;
  if (is_isonitrile(a1, a2))
    fg[fg_isonitrile-1] = true;
  if (is_cyanate(a1, a2))
    fg[fg_cyanate-1] = true;
  if (is_thiocyanate(a1, a2))
    fg[fg_thiocyanate-1] = true;
}


Static void chk_ccx(short a_view, short a_ref)
{
  short i;
  neighbor_rec nb;
  short oh_count = 0, or_count = 0, n_count = 0;
  short FORLIM;

  memset(nb, 0, sizeof(neighbor_rec));
  get_neighbors(nb, a_ref);
  FORLIM = atom[a_ref-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (bond[get_bond(a_ref, nb[i]) - 1].btype == 'S') {
      if (is_hydroxy(a_ref, nb[i]))
	oh_count++;
      if (is_alkoxy(a_ref, nb[i]) || is_aryloxy(a_ref, nb[i]) ||
	  is_siloxy(a_ref, nb[i]))
	or_count++;
      if (!strcmp(atom[nb[i] - 1].atype, "N3 ") ||
	  !strcmp(atom[nb[i] - 1].atype, "NAM"))
	n_count++;
    }
  }
  if (oh_count == 1)
    fg[fg_enol-1] = true;
  if (or_count == 1)
    fg[fg_enolether-1] = true;
  if (n_count == 1)
    fg[fg_enamine-1] = true;
  /* new in v0.2f   (regard anything else as an alkene)*/
  if (oh_count + or_count + n_count == 0)
    fg[fg_alkene-1] = true;
}


Static void chk_xccx(short a_view, short a_ref)
{
  short i;
  neighbor_rec nb;
  short oh_count = 0, or_count = 0, n_count = 0;
  short FORLIM;

  memset(nb, 0, sizeof(neighbor_rec));
  get_neighbors(nb, a_view);
  FORLIM = atom[a_view-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (bond[get_bond(a_view, nb[i]) - 1].btype == 'S') {
      if (is_hydroxy(a_view, nb[i]))
	oh_count++;
      if (is_alkoxy(a_view, nb[i]) || is_aryloxy(a_view, nb[i]) ||
	  is_siloxy(a_view, nb[i]))
	or_count++;
      if (!strcmp(atom[nb[i] - 1].atype, "N3 ") ||
	  !strcmp(atom[nb[i] - 1].atype, "NAM"))
	n_count++;
    }
  }
  memset(nb, 0, sizeof(neighbor_rec));
  get_neighbors(nb, a_ref);
  FORLIM = atom[a_ref-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (bond[get_bond(a_ref, nb[i]) - 1].btype == 'S') {
      if (is_hydroxy(a_ref, nb[i]))
	oh_count++;
      if (is_alkoxy(a_ref, nb[i]) || is_aryloxy(a_ref, nb[i]) ||
	  is_siloxy(a_ref, nb[i]))
	or_count++;
      if (!strcmp(atom[nb[i] - 1].atype, "N3 ") ||
	  !strcmp(atom[nb[i] - 1].atype, "NAM"))
	n_count++;
    }
  }
  if (oh_count == 2)
    fg[fg_enediol-1] = true;
  /* new in v0.2f   (regard anything else as an alkene)*/
  if (oh_count + or_count + n_count == 0)
    fg[fg_alkene-1] = true;
}


Static void chk_n_o_dbl(short a1, short a2)
{
  short i;
  neighbor_rec nb;
  str2 nb_el;
  short or_count = 0, n_count = 0, c_count = 0;
  short b;   /* v0.3j*/
  short het_count = 0;   /* v0.3k*/
  Char bt;   /* v0.3k*/
  float bo_sum = 0.0;   /* v0.3k*/
  short FORLIM;

  memset(nb, 0, sizeof(neighbor_rec));
  get_neighbors(nb, a1);
  FORLIM = atom[a1-1].neighbor_count;
  /* v0.3k*/
  /* v0.3k*/
  for (i = 0; i <= FORLIM - 1; i++) {
    if (nb[i] != a2) {
      b = get_bond(a1, nb[i]);   /* v0.3j*/
      strcpy(nb_el, atom[nb[i] - 1].element);
      bt = bond[b-1].btype;   /* v0.3k*/
      if (strcmp(nb_el, "C ") && strcmp(nb_el, "H ") && strcmp(nb_el, "DU") &&
	  strcmp(nb_el, "LP") && bond[b-1].arom == false)
	    /* v0.3k: ignore hetero atoms*/
	      het_count++;
      /* in aromatic rings like isoxazole */
      if (bt == 'S')
	bo_sum += 1.0;
      if (bt == 'D')
	bo_sum += 2.0;
      if (bt == 'A')
	bo_sum += 1.5;
      if (!strcmp(nb_el, "O "))
	or_count++;
      if (!strcmp(nb_el, "N "))
	n_count++;
      if (!strcmp(nb_el, "C ") && bond[b-1].btype == 'S')   /* v0.3k*/
	c_count++;
      /* if (is_alkyl(a1,nb[i])) or (is_aryl(a1,nb[i])) then inc(c_count);*/
    }
  }
  if (or_count + n_count + c_count == 1 && atom[a1-1].neighbor_count == 2)
  {   /* excludes nitro etc.*/
    if (or_count == 1)
      fg[fg_nitrite-1] = true;
    if (c_count == 1)
      fg[fg_nitroso_compound-1] = true;
    if (n_count == 1)   /* instead of nitrosamine  v0.3j*/
      fg[fg_nitroso_compound-1] = true;
    /*if (n_count = 1) then fg[fg_nitrosamine]   := true;  { still missing*/
  }
  /*if ((c_count > 1) and (or_count = 0) and (n_count = 0)) then*/
  /*  begin*/
  /*    fg[fg_n_oxide] := true;*/
  /*  end;*/
  /* new approach in v0.3k*/
  if (het_count == 0 && bo_sum > 2)   /* =O does not count!*/
    fg[fg_n_oxide-1] = true;
}


Static void chk_sulfoxide(short a1, short a2)
{
  short i;
  neighbor_rec nb;
  str2 nb_el;
  short o_count = 0, c_count = 0;
  short FORLIM;

  memset(nb, 0, sizeof(neighbor_rec));
  get_neighbors(nb, a1);
  FORLIM = atom[a1-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    strcpy(nb_el, atom[nb[i] - 1].element);
    if (!strcmp(nb_el, "O "))
      o_count++;
    if (is_alkyl(a1, nb[i]) || is_aryl(a1, nb[i]))
      c_count++;
  }
  if (o_count == 1 && c_count == 2)
    fg[fg_sulfoxide-1] = true;
}


Static void chk_double(short a1, short a2)
{
  str2 a1_el, a2_el;

  strcpy(a1_el, atom[a1-1].element);
  strcpy(a2_el, atom[a2-1].element);
  if (!strcmp(a1_el, "C ") && strcmp(a2_el, "C ") &&
      bond[get_bond(a1, a2) - 1].arom == false) {
    if (hetbond_count(a1) == 2)
      chk_carbonyl_deriv(a1, a2);
    if (hetbond_count(a1) == 3)
      chk_carboxyl_deriv(a1, a2);
    if (hetbond_count(a1) == 4) {
      if (!strcmp(atom[a1-1].atype, "C2 "))
	chk_co2_sp2(a1, a2);
      if (!strcmp(atom[a1-1].atype, "C1 "))
	chk_co2_sp(a1, a2);
    }
  }  /* end C=X*/
  if (!strcmp(atom[a1-1].atype, "C2 ") && !strcmp(atom[a2-1].atype, "C2 ") &&
      bond[get_bond(a1, a2) - 1].arom == false) {
    if (hetbond_count(a1) == 0 && hetbond_count(a2) == 2)
      fg[fg_ketene_acetal_deriv-1] = true;
    if (hetbond_count(a1) == 0 && hetbond_count(a2) == 1)
      chk_ccx(a1, a2);
    if (hetbond_count(a1) == 1 && hetbond_count(a2) == 1)
      chk_xccx(a1, a2);
    if (hetbond_count(a1) == 0 && hetbond_count(a2) == 0 &&
	atom[a1-1].arom == false && atom[a2-1].arom == false)
      fg[fg_alkene-1] = true;
  }
  if (!strcmp(a1_el, "N ") && !strcmp(a2_el, "N ") &&
      hetbond_count(a1) == 2 && hetbond_count(a2) == 2 &&
      bond[get_bond(a1, a2) - 1].arom == false &&
      atom[a1-1].neighbor_count == 2 && atom[a2-1].neighbor_count == 2)
    fg[fg_azo_compound-1] = true;
  if (!strcmp(a1_el, "N ") && !strcmp(a2_el, "O "))
    chk_n_o_dbl(a1, a2);
  if (!strcmp(a1_el, "S ") && !strcmp(a2_el, "O "))
    chk_sulfoxide(a1, a2);
}


Static void chk_c_hal(short a1, short a2)
{
  str2 a2_el;

  strcpy(a2_el, atom[a2-1].element);
  fg[fg_halogen_deriv-1] = true;
  if (atom[a1-1].arom) {
    fg[fg_aryl_halide-1] = true;
    if (!strcmp(a2_el, "F "))
      fg[fg_aryl_fluoride-1] = true;
    if (!strcmp(a2_el, "CL"))
      fg[fg_aryl_chloride-1] = true;
    if (!strcmp(a2_el, "BR"))
      fg[fg_aryl_bromide-1] = true;
    if (!strcmp(a2_el, "I "))
      fg[fg_aryl_iodide-1] = true;
    return;
  }
  if (!strcmp(atom[a1-1].atype, "C3 ") && hetbond_count(a1) <= 2)
  {  /* alkyl halides*/
    fg[fg_alkyl_halide-1] = true;
    if (!strcmp(a2_el, "F "))
      fg[fg_alkyl_fluoride-1] = true;
    if (!strcmp(a2_el, "CL"))
      fg[fg_alkyl_chloride-1] = true;
    if (!strcmp(a2_el, "BR"))
      fg[fg_alkyl_bromide-1] = true;
    if (!strcmp(a2_el, "I "))
      fg[fg_alkyl_iodide-1] = true;
  }
  if (!strcmp(atom[a1-1].atype, "C2 ") && hetbond_count(a1) == 3)
  {  /* acyl halides and related compounds*/
    if (is_oxo_C(a1)) {
      fg[fg_acyl_halide-1] = true;
      if (!strcmp(a2_el, "F "))
	fg[fg_acyl_fluoride-1] = true;
      if (!strcmp(a2_el, "CL"))
	fg[fg_acyl_chloride-1] = true;
      if (!strcmp(a2_el, "BR"))
	fg[fg_acyl_bromide-1] = true;
      if (!strcmp(a2_el, "I "))
	fg[fg_acyl_iodide-1] = true;
    }
    if (is_thioxo_C(a1))
      fg[fg_thiocarboxylic_acid_deriv-1] = true;
    if (is_imino_C(a1))
      fg[fg_imidoyl_halide-1] = true;
  }
  if (strcmp(atom[a1-1].atype, "C2 ") || hetbond_count(a1) != 4)
	/* chloroformates etc.*/
	  return;
  /* still missing: polyhalogen compounds (-CX2H, -CX3)*/
  fg[fg_co2_deriv-1] = true;
  if (is_oxo_C(a1)) {
    fg[fg_carbonic_acid_deriv-1] = true;
    if (is_alkoxycarbonyl(a2, a1) || is_aryloxycarbonyl(a2, a1))
      fg[fg_carbonic_acid_ester_halide-1] = true;
    if (is_carbamoyl(a2, a1)) {
      fg[fg_carbamic_acid_deriv-1] = true;
      fg[fg_carbamic_acid_halide-1] = true;
    }
  }
  if (!is_thioxo_C(a1))
    return;
  fg[fg_thiocarbonic_acid_deriv-1] = true;
  if (is_alkoxythiocarbonyl(a2, a1) || is_aryloxythiocarbonyl(a2, a1))
    fg[fg_thiocarbonic_acid_ester_halide-1] = true;
  if (is_thiocarbamoyl(a2, a1)) {
    fg[fg_thiocarbamic_acid_deriv-1] = true;
    fg[fg_thiocarbamic_acid_halide-1] = true;
    /* end of non-aromatic halogen compounds*/
  }
}


Static void chk_c_o(short a1, short a2)
{
  /* ignore heteroaromatic rings (like furan, thiophene, etc.)*/
  if (bond[get_bond(a1, a2) - 1].arom == true)
    return;
  if (is_true_alkyl(a2, a1) && is_hydroxy(a1, a2)) {
    fg[fg_hydroxy-1] = true;
    fg[fg_alcohol-1] = true;
    if (atom[a1-1].neighbor_count <= 2)
      fg[fg_prim_alcohol-1] = true;
    if (atom[a1-1].neighbor_count == 3)
      fg[fg_sec_alcohol-1] = true;
    if (atom[a1-1].neighbor_count == 4)
      fg[fg_tert_alcohol-1] = true;
  }
  if (is_aryl(a2, a1) && is_hydroxy(a1, a2)) {
    fg[fg_hydroxy-1] = true;
    fg[fg_phenol-1] = true;
  }
  if (is_true_alkyl(a2, a1) && is_true_alkoxy(a1, a2)) {
    fg[fg_ether-1] = true;
    fg[fg_dialkylether-1] = true;
  }
  if (is_true_alkyl(a2, a1) && is_aryloxy(a1, a2) ||
      is_aryl(a2, a1) && is_true_alkoxy(a1, a2)) {
    fg[fg_ether-1] = true;
    fg[fg_alkylarylether-1] = true;
  }
  if (is_aryl(a2, a1) && is_aryloxy(a1, a2)) {
    fg[fg_ether-1] = true;
    fg[fg_diarylether-1] = true;
  }
  if ((is_true_alkyl(a2, a1) || is_aryl(a2, a1)) && is_alkynyloxy(a1, a2)) {
    fg[fg_ether-1] = true;
    ether_generic = true;
  }
  if (is_alkynyl(a2, a1) && is_hydroxy(a1, a2)) {
    fg[fg_hydroxy-1] = true;
    hydroxy_generic = true;
  }

}


Static void chk_c_s(short a1, short a2)
{
  short i;
  neighbor_rec nb;
  str2 nb_el;
  short o_count = 0, oh_count = 0, or_count = 0, n_count = 0, c_count = 0,
	hal_count = 0;
  short FORLIM;

  /* ignore heteroaromatic rings (like furan, thiophene, etc.)*/
  if (bond[get_bond(a1, a2) - 1].arom == true)
    return;
  if (is_alkyl(a2, a1) && is_sulfanyl(a1, a2)) {
    fg[fg_thiol-1] = true;
    fg[fg_alkylthiol-1] = true;
  }
  if (is_aryl(a2, a1) && is_sulfanyl(a1, a2)) {
    fg[fg_thiol-1] = true;
    fg[fg_arylthiol-1] = true;
  }
  if (is_true_alkyl(a2, a1) && is_true_alkylsulfanyl(a1, a2))
    fg[fg_thioether-1] = true;
  if (is_true_alkyl(a2, a1) && is_arylsulfanyl(a1, a2) ||
      is_aryl(a2, a1) && is_true_alkylsulfanyl(a1, a2))
    fg[fg_thioether-1] = true;
  if (is_aryl(a2, a1) && is_arylsulfanyl(a1, a2))
    fg[fg_thioether-1] = true;
  /* check for sulfinic/sulfenic acid derivatives*/
  memset(nb, 0, sizeof(neighbor_rec));
  get_neighbors(nb, a2);
  FORLIM = atom[a2-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    strcpy(nb_el, atom[nb[i] - 1].element);
    if (is_alkyl(a2, nb[i]) || is_aryl(a2, nb[i]))
      c_count++;
    if (is_hydroxy(a2, nb[i]))
      oh_count++;
    if (is_alkoxy(a2, nb[i]) || is_aryloxy(a2, nb[i]))
      or_count++;
    if (is_amino(a2, nb[i]) || is_subst_amino(a2, nb[i]))
      n_count++;
    if (!strcmp(nb_el, "F ") || !strcmp(nb_el, "CL") ||
	!strcmp(nb_el, "BR") || !strcmp(nb_el, "I "))
      hal_count++;
    if (!strcmp(nb_el, "O "))
      o_count++;
  }
  if (c_count != 1)
    return;
  if (atom[a2-1].neighbor_count == 3 && o_count - oh_count - or_count == 1)
  {   /* sulfinic acid & derivs*/
    fg[fg_sulfinic_acid_deriv-1] = true;
    if (oh_count == 1)
      fg[fg_sulfinic_acid-1] = true;
    if (or_count == 1)
      fg[fg_sulfinic_acid_ester-1] = true;
    if (hal_count == 1)
      fg[fg_sulfinic_acid_halide-1] = true;
    if (n_count == 1)
      fg[fg_sulfinic_acid_amide-1] = true;
  }
  if (atom[a2-1].neighbor_count != 2 || o_count - oh_count - or_count != 0)
	/* sulfenic acid & derivs*/
	  return;

  fg[fg_sulfenic_acid_deriv-1] = true;
  if (oh_count == 1)
    fg[fg_sulfenic_acid-1] = true;
  if (or_count == 1)
    fg[fg_sulfenic_acid_ester-1] = true;
  if (hal_count == 1)
    fg[fg_sulfenic_acid_halide-1] = true;
  if (n_count == 1)
    fg[fg_sulfenic_acid_amide-1] = true;
}


Static void chk_c_n(short a1, short a2)
{
  /* ignore heteroaromatic rings (like furan, thiophene, pyrrol, etc.)*/
  if (atom[a2-1].arom == true)
    return;
  if (is_true_alkyl(a2, a1) && is_amino(a1, a2)) {
    fg[fg_amine-1] = true;
    fg[fg_prim_amine-1] = true;
    fg[fg_prim_aliph_amine-1] = true;
  }
  if (is_aryl(a2, a1) && is_amino(a1, a2)) {
    fg[fg_amine-1] = true;
    fg[fg_prim_amine-1] = true;
    fg[fg_prim_arom_amine-1] = true;
  }
  if (is_true_alkyl(a2, a1) && is_true_alkylamino(a1, a2)) {
    fg[fg_amine-1] = true;
    fg[fg_sec_amine-1] = true;
    fg[fg_sec_aliph_amine-1] = true;
  }
  if (is_aryl(a2, a1) && is_true_alkylamino(a1, a2)) {
    fg[fg_amine-1] = true;
    fg[fg_sec_amine-1] = true;
    fg[fg_sec_mixed_amine-1] = true;
  }
  if (is_aryl(a2, a1) && is_arylamino(a1, a2)) {
    fg[fg_amine-1] = true;
    fg[fg_sec_amine-1] = true;
    fg[fg_sec_arom_amine-1] = true;
  }
  if (is_true_alkyl(a2, a1) && is_true_dialkylamino(a1, a2)) {
    fg[fg_amine-1] = true;
    fg[fg_tert_amine-1] = true;
    fg[fg_tert_aliph_amine-1] = true;
  }
  if (is_true_alkyl(a2, a1) && is_diarylamino(a1, a2) ||
      is_aryl(a2, a1) && is_true_dialkylamino(a1, a2)) {
    fg[fg_amine-1] = true;
    fg[fg_tert_amine-1] = true;
    fg[fg_tert_mixed_amine-1] = true;
  }
  if (is_aryl(a2, a1) && is_diarylamino(a1, a2)) {
    fg[fg_amine-1] = true;
    fg[fg_tert_amine-1] = true;
    fg[fg_tert_arom_amine-1] = true;
  }
  if ((is_alkyl(a2, a1) || is_aryl(a2, a1) || is_alkenyl(a2, a1) ||
       is_alkynyl(a2, a1)) && is_hydroxylamino(a1, a2) &&
      is_acyl_gen(a2, a1) == false)
	/* v0.3k*/
	  fg[fg_hydroxylamine-1] = true;
  /* v0.3k*/
  /* v0.3k */
  if ((is_alkyl(a2, a1) || is_aryl(a2, a1) || is_acyl(a2, a1) ||
       is_alkenyl(a2, a1) || is_alkynyl(a2, a1)) && is_hydrazino(a1, a2))
    fg[fg_hydrazine-1] = true;
  if ((is_alkyl(a2, a1) || is_aryl(a2, a1) || is_alkenyl(a2, a1) ||
       is_alkynyl(a2, a1)) && is_azido(a1, a2))
	/* v0.3k*/
	  fg[fg_azide-1] = true;
  if ((is_alkyl(a2, a1) || is_aryl(a2, a1) || is_alkenyl(a2, a1) ||
       is_alkynyl(a2, a1)) && is_diazonium(a1, a2))
	/* v0.3k*/
	  fg[fg_diazonium_salt-1] = true;
  if ((is_alkyl(a2, a1) || is_aryl(a2, a1) || is_alkenyl(a2, a1) ||
       is_alkynyl(a2, a1)) && is_nitro(a1, a2))
	/* v0.3k*/
	  fg[fg_nitro_compound-1] = true;
  if (is_alkynyl(a2, a1) &&
      (is_amino(a1, a2) || is_C_monosubst_amino(a1, a2) ||
       is_C_disubst_amino(a1, a2) && !is_acylamino(a1, a2))) {
    fg[fg_amine-1] = true;
    amine_generic = true;
  }
}


Static void chk_c_c(short a1, short a2)
{
  short i;
  neighbor_rec nb;
  short oh_count, nhr_count, FORLIM;

  /* ignore aromatic rings*/
  if (atom[a2-1].arom == true)
    return;
  /*check for 1,2-diols and 1,2-aminoalcoholes*/
  if (!strcmp(atom[a1-1].atype, "C3 ") && !strcmp(atom[a2-1].atype, "C3 ")) {
    if (hetbond_count(a1) == 1 && hetbond_count(a2) == 1) {
      oh_count = 0;
      nhr_count = 0;
      memset(nb, 0, sizeof(neighbor_rec));
      get_neighbors(nb, a1);
      FORLIM = atom[a1-1].neighbor_count;
      for (i = 0; i <= FORLIM - 1; i++) {
	if (nb[i] != a2) {
	  if (is_hydroxy(a1, nb[i]))
	    oh_count++;
	  if (is_amino(a1, nb[i]) || is_alkylamino(a1, nb[i]) ||
	      is_arylamino(a1, nb[i]))
	    nhr_count++;
	}
      }
      memset(nb, 0, sizeof(neighbor_rec));
      get_neighbors(nb, a2);
      FORLIM = atom[a2-1].neighbor_count;
      for (i = 0; i <= FORLIM - 1; i++) {
	if (nb[i] != a1) {
	  if (is_hydroxy(a2, nb[i]))
	    oh_count++;
	  if (is_amino(a2, nb[i]) || is_alkylamino(a2, nb[i]) ||
	      is_arylamino(a2, nb[i]))
	    nhr_count++;
	}
      }
      if (oh_count == 2)
	fg[fg_1_2_diol-1] = true;
      if (oh_count == 1 && nhr_count == 1)
	fg[fg_1_2_aminoalcohol-1] = true;
    }
  }
  /* check for alpha-aminoacids and alpha-hydroxyacids*/
  if (strcmp(atom[a1-1].atype, "C3 ") || strcmp(atom[a2-1].atype, "C2 "))
    return;
  if (hetbond_count(a1) != 1 || hetbond_count(a2) != 3)
    return;
  oh_count = 0;
  nhr_count = 0;
  memset(nb, 0, sizeof(neighbor_rec));
  get_neighbors(nb, a1);
  FORLIM = atom[a1-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (nb[i] != a2) {
      if (is_hydroxy(a1, nb[i]))
	oh_count++;
      if (is_amino(a1, nb[i]) || is_alkylamino(a1, nb[i]) ||
	  is_arylamino(a1, nb[i]))
	nhr_count++;
    }
  }
  memset(nb, 0, sizeof(neighbor_rec));
  get_neighbors(nb, a2);
  FORLIM = atom[a2-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (nb[i] != a1) {
      if (is_hydroxy(a2, nb[i]))
	oh_count++;
    }
  }
  if (oh_count == 2 && is_oxo_C(a2))
    fg[fg_alpha_hydroxyacid-1] = true;
  if (oh_count == 1 && nhr_count == 1 && is_oxo_C(a2))
    fg[fg_alpha_aminoacid-1] = true;
}


Static void chk_x_y_single(short a_view, short a_ref)
{
  if (!strcmp(atom[a_view-1].atype, "O3 ") &&
      !strcmp(atom[a_ref-1].atype, "O3 ")) {
    if (is_hydroxy(a_ref, a_view) || is_hydroxy(a_view, a_ref))
      fg[fg_hydroperoxide-1] = true;
    if ((is_alkoxy(a_ref, a_view) || is_aryloxy(a_ref, a_view) ||
	 is_siloxy(a_ref, a_view)) &&
	(is_alkoxy(a_view, a_ref) || is_aryloxy(a_view, a_ref) ||
	 is_siloxy(a_view, a_ref)))
      fg[fg_peroxide-1] = true;
  }  /* still missing: peracid*/
  if (!strcmp(atom[a_view-1].atype, "S3 ") &&
      !strcmp(atom[a_ref-1].atype, "S3 ")) {
    if (atom[a_view-1].neighbor_count == 2 &&
	atom[a_ref-1].neighbor_count == 2)
      fg[fg_disulfide-1] = true;
  }
  if (!strcmp(atom[a_view-1].element, "N ") &&
      !strcmp(atom[a_ref-1].element, "N ") && hetbond_count(a_view) == 1 &&
      hetbond_count(a_ref) == 1) {
    /*if ((is_amino(a_ref,a_view)) or */
    /*    (is_subst_amino(a_ref,a_view)) or*/
    /*    (is_acylamino(a_ref,a_view))) and*/
    /*   ((is_amino(a_view,a_ref)) or */
    /*    (is_subst_amino(a_view,a_ref)) or*/
    /*    (is_acylamino(a_ref,a_view))) then */
    if (bond[get_bond(a_view, a_ref) - 1].arom == false)
      fg[fg_hydrazine-1] = true;
  }
  if (!strcmp(atom[a_view-1].element, "N ") &&
      !strcmp(atom[a_ref-1].atype, "O3 "))
  {  /* bond is in "opposite" direction*/
    if ((is_alkoxy(a_view, a_ref) || is_aryloxy(a_view, a_ref)) &&
	is_nitro(a_ref, a_view))
      fg[fg_nitrate-1] = true;
    if (is_nitro(a_ref, a_view) == false && atom[a_view-1].arom == false &&
	(is_amino(a_ref, a_view) || is_subst_amino(a_ref, a_view)) &&
	is_acylamino(a_ref, a_view) == false)
      fg[fg_hydroxylamine-1] = true;   /* new in v0.3c*/
  }
  if (!strcmp(atom[a_view-1].element, "S ") &&
      !strcmp(atom[a_ref-1].element, "O "))
    chk_sulfoxide(a_view, a_ref);
}


Static void chk_single(short a1, short a2)
{
  str2 a1_el, a2_el;

  strcpy(a1_el, atom[a1-1].element);
  strcpy(a2_el, atom[a2-1].element);
  if (!strcmp(a1_el, "C ") &&
      (!strcmp(a2_el, "F ") || !strcmp(a2_el, "CL") || !strcmp(a2_el, "BR") ||
       !strcmp(a2_el, "I ")))
    chk_c_hal(a1, a2);
  if (!strcmp(a1_el, "C ") && !strcmp(a2_el, "O "))
    chk_c_o(a1, a2);
  if (!strcmp(a1_el, "C ") && !strcmp(a2_el, "S "))
    chk_c_s(a1, a2);
  if (!strcmp(a1_el, "C ") && !strcmp(a2_el, "N "))
    chk_c_n(a1, a2);
  if (!strcmp(a1_el, "C ") && atom[a2-1].metal && is_cyano_c(a1) == false) {
    fg[fg_organometallic-1] = true;
    if (!strcmp(a2_el, "LI"))
      fg[fg_organolithium-1] = true;
    if (!strcmp(a2_el, "MG"))
      fg[fg_organomagnesium-1] = true;
  }
  if (!strcmp(a1_el, "C ") && !strcmp(a2_el, "C "))
    chk_c_c(a1, a2);
  if (strcmp(a1_el, "C ") && strcmp(a2_el, "C "))
    chk_x_y_single(a1, a2);
}


Static void chk_carbonyl_deriv_sp3(short a_ref)
{
  short i;
  neighbor_rec nb;
  short oh_count = 0, or_count = 0, n_count = 0, sh_count = 0, sr_count = 0;
  short FORLIM;

  memset(nb, 0, sizeof(neighbor_rec));
  get_neighbors(nb, a_ref);
  FORLIM = atom[a_ref-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (is_hydroxy(a_ref, nb[i]))
      oh_count++;
    if (is_alkoxy(a_ref, nb[i]) || is_aryloxy(a_ref, nb[i]) ||
	is_alkenyloxy(a_ref, nb[i]) || is_alkynyloxy(a_ref, nb[i]))
      or_count++;
    if (is_sulfanyl(a_ref, nb[i]))
      sh_count++;
    if (is_alkylsulfanyl(a_ref, nb[i]) || is_arylsulfanyl(a_ref, nb[i]) ||
	is_alkenylsulfanyl(a_ref, nb[i]) || is_alkynylsulfanyl(a_ref, nb[i]))
      sr_count++;
    if (!strcmp(atom[nb[i] - 1].atype, "N3 ") ||
	!strcmp(atom[nb[i] - 1].atype, "NAM"))
      n_count++;
  }
  if (oh_count == 2)
    fg[fg_carbonyl_hydrate-1] = true;
  if (oh_count == 1 && or_count == 1)
    fg[fg_hemiacetal-1] = true;
  if (or_count == 2)
    fg[fg_acetal-1] = true;
  if ((oh_count == 1 || or_count == 1) && n_count == 1)
    fg[fg_hemiaminal-1] = true;
  if (n_count == 2)
    fg[fg_aminal-1] = true;
  if ((sh_count == 1 || sr_count == 1) && n_count == 1)
    fg[fg_thiohemiaminal-1] = true;
  if (sr_count == 2 || or_count == 1 && sr_count == 1)
    fg[fg_thioacetal-1] = true;
}


Static void chk_carboxyl_deriv_sp3(short a_ref)
{
  short i;
  neighbor_rec nb;
  short or_count = 0, oh_count = 0, n_count = 0;   /* oh_count new in v0.3c*/
  short electroneg_count = 0;   /* new in v0.3j*/
  short hal_count = 0;
  str2 nb_el;
  short FORLIM;

  memset(nb, 0, sizeof(neighbor_rec));
  get_neighbors(nb, a_ref);
  FORLIM = atom[a_ref-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    strcpy(nb_el, atom[nb[i] - 1].element);   /* v0.3j*/
    if (is_electroneg(nb_el))
      electroneg_count++;
    if (!strcmp(nb_el, "F ") || !strcmp(nb_el, "CL") ||
	!strcmp(nb_el, "BR") || !strcmp(nb_el, "I "))
      hal_count++;
    if (is_alkoxy(a_ref, nb[i]) || is_aryloxy(a_ref, nb[i]) ||
	is_siloxy(a_ref, nb[i]))
      or_count++;
    if (is_hydroxy(a_ref, nb[i]))   /* new in v0.3c   */
      oh_count++;
    if (!strcmp(atom[nb[i] - 1].atype, "N3 ") ||
	!strcmp(atom[nb[i] - 1].atype, "NAM"))
      n_count++;
  }
  /*if (or_count + n_count > 1) then fg[fg_orthocarboxylic_acid_deriv] := true;  { until v0.3i*/
  if (electroneg_count == 3 && hal_count < 3)   /* v0.3j*/
    fg[fg_orthocarboxylic_acid_deriv-1] = true;
  if (or_count == 3)
    fg[fg_carboxylic_acid_orthoester-1] = true;
  if (or_count == 2 && n_count == 1)
    fg[fg_carboxylic_acid_amide_acetal-1] = true;
  if (oh_count > 0 && oh_count + or_count + n_count == 3)   /* new in v0.3c*/
    fg[fg_orthocarboxylic_acid_deriv-1] = true;
}


Static void chk_anhydride(short a_ref)
{
  short i;
  neighbor_rec nb;
  short acyl_count = 0;
  short FORLIM;

  memset(nb, 0, sizeof(neighbor_rec));
  get_neighbors(nb, a_ref);
  FORLIM = atom[a_ref-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (is_acyl(a_ref, nb[i]) || is_carbamoyl(a_ref, nb[i]))
      acyl_count++;
  }
  if (acyl_count == 2 && !strcmp(atom[a_ref-1].atype, "O3 ")) {
    fg[fg_carboxylic_acid_deriv-1] = true;
    fg[fg_carboxylic_acid_anhydride-1] = true;
  }
}


Static void chk_imide(short a_ref)
{
  short i;
  neighbor_rec nb;
  short acyl_count = 0;
  short FORLIM;

  memset(nb, 0, sizeof(neighbor_rec));
  get_neighbors(nb, a_ref);
  FORLIM = atom[a_ref-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (is_acyl_gen(a_ref, nb[i]) || is_carbamoyl(a_ref, nb[i]))   /* v0.3j*/
      acyl_count++;
  }
  if (acyl_count < 2 || strcmp(atom[a_ref-1].element, "N "))
	/* v0.3j: accept also N-acyl-imides*/
	  return;
  fg[fg_carboxylic_acid_deriv-1] = true;
  fg[fg_carboxylic_acid_imide-1] = true;
  if (atom[a_ref-1].neighbor_count == 2)
    fg[fg_carboxylic_acid_unsubst_imide-1] = true;
  if (atom[a_ref-1].neighbor_count == 3)
    fg[fg_carboxylic_acid_subst_imide-1] = true;
}


Static void chk_12diphenol(short a_view, short a_ref)
{
  short i;
  neighbor_rec nb;
  short oh_count = 0;
  short FORLIM;

  memset(nb, 0, sizeof(neighbor_rec));
  get_neighbors(nb, a_view);
  FORLIM = atom[a_view-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (bond[get_bond(a_view, nb[i]) - 1].btype == 'S') {
      if (is_hydroxy(a_view, nb[i]))
	oh_count++;
    }
  }
  memset(nb, 0, sizeof(neighbor_rec));
  get_neighbors(nb, a_ref);
  FORLIM = atom[a_ref-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (bond[get_bond(a_ref, nb[i]) - 1].btype == 'S') {
      if (is_hydroxy(a_ref, nb[i]))
	oh_count++;
    }
  }
  if (oh_count == 2)
    fg[fg_1_2_diphenol-1] = true;
}


Static void chk_arom_fg(short a1, short a2)
{
  if (hetbond_count(a1) == 1 && hetbond_count(a2) == 1)
    chk_12diphenol(a1, a2);
}


Static boolean is_arene(short r_id)
{
  short i, j;
  boolean r = true;
  ringpath_type testring;
  short ring_size, a_prev, a_ref;

/* p2c: checkmol3l.pas:
 * Note: Eliminated unused assignment statement [338] */
  if (r_id < 1 || r_id > n_rings)
    return false;
  memset(testring, 0, sizeof(ringpath_type));
  ring_size = ringprop[r_id-1].size;   /* v0.3j*/
  /*for j := 1 to max_ringsize do if ring^[r_id,j] > 0 then testring[j] := ring^[r_id,j];*/
  for (j = 0; j <= ring_size - 1; j++)   /* v0.3j*/
    testring[j] = ring[r_id-1][j];
  /*ring_size := path_length(testring);*/
  if (ring_size <= 2)
    return false;
  a_prev = testring[ring_size-1];
  for (i = 0; i <= ring_size - 1; i++) {
    a_ref = testring[i];
    if (bond[get_bond(a_prev, a_ref) - 1].arom == false)
      r = false;
    a_prev = a_ref;
  }
  return r;
}


Static boolean is_heterocycle(short r_id)
{
  short i, j;
  boolean r = false;
  ringpath_type testring;
  short ring_size, a_ref;

  if (r_id < 1 || r_id > n_rings)
    return false;
  memset(testring, 0, sizeof(ringpath_type));
  ring_size = ringprop[r_id-1].size;   /* v0.3j*/
  /*for j := 1 to max_ringsize do if ring^[r_id,j] > 0 then testring[j] := ring^[r_id,j];*/
  for (j = 0; j <= ring_size - 1; j++)   /* v0.3j*/
    testring[j] = ring[r_id-1][j];
  /*ring_size := path_length(testring);*/
  if (ring_size <= 2)
    return false;
  for (i = 0; i <= ring_size - 1; i++) {
    a_ref = testring[i];
    if (strcmp(atom[a_ref-1].element, "C "))
      r = true;
  }
  return r;
}


Static void chk_oxo_thioxo_imino_hetarene(short r_id)
{
  short i, j;
  ringpath_type testring;
  short ring_size, a_ref;

  if (r_id < 1 || r_id > n_rings)
    return;
  memset(testring, 0, sizeof(ringpath_type));
  ring_size = ringprop[r_id-1].size;   /* v0.3j*/
  /*for j := 1 to max_ringsize do if ring^[r_id,j] > 0 then testring[j] := ring^[r_id,j];*/
  for (j = 0; j <= ring_size - 1; j++)   /* v0.3j*/
    testring[j] = ring[r_id-1][j];
  /*ring_size := path_length(testring);*/
  /*if (is_arene(r_id)) and (odd(ring_size) = false) then*/
  if (!is_arene(r_id))   /* v0.3j*/
    return;
  for (i = 0; i <= ring_size - 1; i++) {
    a_ref = testring[i];
    if (is_oxo_C(a_ref))
      fg[fg_oxohetarene-1] = true;
    if (is_thioxo_C(a_ref))
      fg[fg_thioxohetarene-1] = true;
    if (is_true_exocyclic_imino_C(a_ref, r_id))   /* v0.3j*/
      fg[fg_iminohetarene-1] = true;
  }
}


Static void chk_ion(short a_ref)
{
  short i;
  neighbor_rec nb;
  short charge, FORLIM;

  memset(nb, 0, sizeof(neighbor_rec));
  get_neighbors(nb, a_ref);
  charge = atom[a_ref-1].formal_charge;
  if (charge == 0)
	/* check if charge is neutralized by an adjacent opposite charge*/
	  return;
  FORLIM = atom[a_ref-1].neighbor_count;
  for (i = 0; i <= FORLIM - 1; i++)
    charge += atom[nb[i] - 1].formal_charge;
  if (charge > 0)
    fg[fg_cation-1] = true;
  if (charge < 0)
    fg[fg_anion-1] = true;
}


Static void chk_functionalgroups(void)
{
  short i, a1, a2;
  Char bt;
  short pos_chg = 0, neg_chg = 0;
  short FORLIM;

  if (n_atoms < 1 || n_bonds < 1)
    return;
  FORLIM = n_atoms;
  for (i = 1; i <= FORLIM; i++)
  {   /* a few groups are best discovered in the atom list*/
    if (!strcmp(atom[i-1].atype, "SO2"))
      chk_so2_deriv(i);
    /*if (atom^[i].atype = 'SO ') then fg[fg_sulfoxide] := true;  { do another check in the bond list!!*/
    if (!strcmp(atom[i-1].element, "P "))
      chk_p_deriv(i);
    if (!strcmp(atom[i-1].element, "B "))
      chk_b_deriv(i);
    if (!strcmp(atom[i-1].atype, "N3+") || atom[i-1].formal_charge > 0)
      chk_ammon(i);
    if (!strcmp(atom[i-1].atype, "C3 ") && hetbond_count(i) == 2)
      chk_carbonyl_deriv_sp3(i);
    if (!strcmp(atom[i-1].atype, "C3 ") && hetbond_count(i) == 3)
      chk_carboxyl_deriv_sp3(i);
    if (!strcmp(atom[i-1].atype, "O3 ") && atom[i-1].neighbor_count == 2)
      chk_anhydride(i);
    if ((!strcmp(atom[i-1].atype, "N3 ") || !strcmp(atom[i-1].atype, "NAM")) &&
	atom[i-1].neighbor_count >= 2)
      chk_imide(i);
    if (atom[i-1].formal_charge > 0)
      pos_chg += atom[i-1].formal_charge;
    if (atom[i-1].formal_charge < 0)
      neg_chg += atom[i-1].formal_charge;
    chk_ion(i);
  }
  FORLIM = n_bonds;
  for (i = 0; i <= FORLIM - 1; i++)
  {   /* most groups are best discovered in the bond list*/
    a1 = bond[i].a1;
    a2 = bond[i].a2;
    bt = bond[i].btype;
    if (atom[a1-1].heavy && atom[a2-1].heavy) {
      orient_bond(&a1, &a2);
      if (bt == 'T')
	chk_triple(a1, a2);
      if (bt == 'D')
	chk_double(a1, a2);
      if (bt == 'S')
	chk_single(a1, a2);
      if (bond[i].arom)
	chk_arom_fg(a1, a2);
    }
  }
  if (n_rings > 0) {
    FORLIM = n_rings;
    for (i = 1; i <= FORLIM; i++) {
      chk_oxo_thioxo_imino_hetarene(i);
      if (is_arene(i))
	fg[fg_aromatic-1] = true;
      if (is_heterocycle(i))
	fg[fg_heterocycle-1] = true;
    }
  }
  if (pos_chg + neg_chg > 0)
    fg[fg_cation-1] = true;
  if (pos_chg + neg_chg < 0)
    fg[fg_anion-1] = true;
}


Static void write_fg_text(void)
{
  if (fg[fg_cation-1])
    printf("cation\n");
  if (fg[fg_anion-1])
    printf("anion\n");
  /*  if fg[fg_carbonyl]                       then writeln('carbonyl compound');*/
  if (fg[fg_aldehyde-1])
    printf("aldehyde\n");
  if (fg[fg_ketone-1])
    printf("ketone\n");
  /*  if fg[fg_thiocarbonyl]                   then writeln('thiocarbonyl compound');*/
  if (fg[fg_thioaldehyde-1])
    printf("thioaldehyde\n");
  if (fg[fg_thioketone-1])
    printf("thioketone\n");
  if (fg[fg_imine-1])
    printf("imine\n");
  if (fg[fg_hydrazone-1])
    printf("hydrazone\n");
  if (fg[fg_semicarbazone-1])
    printf("semicarbazone\n");
  if (fg[fg_thiosemicarbazone-1])
    printf("thiosemicarbazone\n");
  if (fg[fg_oxime-1])
    printf("oxime\n");
  if (fg[fg_oxime_ether-1])
    printf("oxime ether\n");
  if (fg[fg_ketene-1])
    printf("ketene\n");
  if (fg[fg_ketene_acetal_deriv-1])
    printf("ketene acetal or derivative\n");
  if (fg[fg_carbonyl_hydrate-1])
    printf("carbonyl hydrate\n");
  if (fg[fg_hemiacetal-1])
    printf("hemiacetal\n");
  if (fg[fg_acetal-1])
    printf("acetal\n");
  if (fg[fg_hemiaminal-1])
    printf("hemiaminal\n");
  if (fg[fg_aminal-1])
    printf("aminal\n");
  if (fg[fg_thiohemiaminal-1])
    printf("hemithioaminal\n");
  if (fg[fg_thioacetal-1])
    printf("thioacetal\n");
  if (fg[fg_enamine-1])
    printf("enamine\n");
  if (fg[fg_enol-1])
    printf("enol\n");
  if (fg[fg_enolether-1])
    printf("enol ether\n");
  if (fg[fg_hydroxy-1] && hydroxy_generic)
    printf("hydroxy compound\n");
  /*  if fg[fg_alcohol]                        then writeln('alcohol');*/
  if (fg[fg_prim_alcohol-1])
    printf("primary alcohol\n");
  if (fg[fg_sec_alcohol-1])
    printf("secondary alcohol\n");
  if (fg[fg_tert_alcohol-1])
    printf("tertiary alcohol\n");
  if (fg[fg_1_2_diol-1])
    printf("1,2-diol\n");
  if (fg[fg_1_2_aminoalcohol-1])
    printf("1,2-aminoalcohol\n");
  if (fg[fg_phenol-1])
    printf("phenol or hydroxyhetarene\n");
  if (fg[fg_1_2_diphenol-1])
    printf("1,2-diphenol\n");
  if (fg[fg_enediol-1])
    printf("enediol\n");
  if (fg[fg_ether-1] && ether_generic)
    printf("ether\n");
  if (fg[fg_dialkylether-1])
    printf("dialkyl ether\n");
  if (fg[fg_alkylarylether-1])
    printf("alkyl aryl ether \n");
  if (fg[fg_diarylether-1])
    printf("diaryl ether\n");
  if (fg[fg_thioether-1])
    printf("thioether\n");
  if (fg[fg_disulfide-1])
    printf("disulfide\n");
  if (fg[fg_peroxide-1])
    printf("peroxide\n");
  if (fg[fg_hydroperoxide-1])
    printf("hydroperoxide \n");
  if (fg[fg_hydrazine-1])
    printf("hydrazine derivative\n");
  if (fg[fg_hydroxylamine-1])
    printf("hydroxylamine\n");
  if (fg[fg_amine-1] && amine_generic)
    printf("amine\n");
  if (fg[fg_prim_amine-1])
    printf("primary amine\n");
  if (fg[fg_prim_aliph_amine-1])
    printf("primary aliphatic amine (alkylamine)\n");
  if (fg[fg_prim_arom_amine-1])
    printf("primary aromatic amine\n");
  if (fg[fg_sec_amine-1])
    printf("secondary amine\n");
  if (fg[fg_sec_aliph_amine-1])
    printf("secondary aliphatic amine (dialkylamine)\n");
  if (fg[fg_sec_mixed_amine-1])
    printf("secondary aliphatic/aromatic amine (alkylarylamine)\n");
  if (fg[fg_sec_arom_amine-1])
    printf("secondary aromatic amine (diarylamine)\n");
  if (fg[fg_tert_amine-1])
    printf("tertiary amine\n");
  if (fg[fg_tert_aliph_amine-1])
    printf("tertiary aliphatic amine (trialkylamine)\n");
  if (fg[fg_tert_mixed_amine-1])
    printf("tertiary aliphatic/aromatic amine (alkylarylamine)\n");
  if (fg[fg_tert_arom_amine-1])
    printf("tertiary aromatic amine (triarylamine)\n");
  if (fg[fg_quart_ammonium-1])
    printf("quaternary ammonium salt\n");
  if (fg[fg_n_oxide-1])
    printf("N-oxide\n");
  /* new in v0.2f*/
  if (fg[fg_halogen_deriv-1]) {
    if (!fg[fg_alkyl_halide-1] && !fg[fg_aryl_halide-1] &&
	!fg[fg_acyl_halide-1])
      printf("halogen derivative\n");
  }
  /*  if fg[fg_alkyl_halide]                   then writeln('alkyl halide');*/
  if (fg[fg_alkyl_fluoride-1])
    printf("alkyl fluoride\n");
  if (fg[fg_alkyl_chloride-1])
    printf("alkyl chloride\n");
  if (fg[fg_alkyl_bromide-1])
    printf("alkyl bromide\n");
  if (fg[fg_alkyl_iodide-1])
    printf("alkyl iodide\n");
  /*  if fg[fg_aryl_halide]                    then writeln('aryl halide');*/
  if (fg[fg_aryl_fluoride-1])
    printf("aryl fluoride\n");
  if (fg[fg_aryl_chloride-1])
    printf("aryl chloride\n");
  if (fg[fg_aryl_bromide-1])
    printf("aryl bromide\n");
  if (fg[fg_aryl_iodide-1])
    printf("aryl iodide\n");
  if (fg[fg_organometallic-1])
    printf("organometallic compound\n");
  if (fg[fg_organolithium-1])
    printf("organolithium compound\n");
  if (fg[fg_organomagnesium-1])
    printf("organomagnesium compound\n");
  /*  if fg[fg_carboxylic_acid_deriv]          then writeln('carboxylic acid derivative');*/
  if (fg[fg_carboxylic_acid-1])
    printf("carboxylic acid\n");
  if (fg[fg_carboxylic_acid_salt-1])
    printf("carboxylic acid salt\n");
  if (fg[fg_carboxylic_acid_ester-1])
    printf("carboxylic acid ester\n");
  if (fg[fg_lactone-1])
    printf("lactone\n");
  /*  if fg[fg_carboxylic_acid_amide]          then writeln('carboxylic acid amide');*/
  if (fg[fg_carboxylic_acid_prim_amide-1])
    printf("primary carboxylic acid amide\n");
  if (fg[fg_carboxylic_acid_sec_amide-1])
    printf("secondary carboxylic acid amide\n");
  if (fg[fg_carboxylic_acid_tert_amide-1])
    printf("tertiary carboxylic acid amide\n");
  if (fg[fg_lactam-1])
    printf("lactam\n");
  if (fg[fg_carboxylic_acid_hydrazide-1])
    printf("carboxylic acid hydrazide\n");
  if (fg[fg_carboxylic_acid_azide-1])
    printf("carboxylic acid azide\n");
  if (fg[fg_hydroxamic_acid-1])
    printf("hydroxamic acid\n");
  if (fg[fg_carboxylic_acid_amidine-1])
    printf("carboxylic acid amidine\n");
  if (fg[fg_carboxylic_acid_amidrazone-1])
    printf("carboxylic acid amidrazone\n");
  if (fg[fg_nitrile-1])
    printf("carbonitrile\n");
  /*  if fg[fg_acyl_halide]                    then writeln('acyl halide');*/
  if (fg[fg_acyl_fluoride-1])
    printf("acyl fluoride\n");
  if (fg[fg_acyl_chloride-1])
    printf("acyl chloride\n");
  if (fg[fg_acyl_bromide-1])
    printf("acyl bromide\n");
  if (fg[fg_acyl_iodide-1])
    printf("acyl iodide\n");
  if (fg[fg_acyl_cyanide-1])
    printf("acyl cyanide\n");
  if (fg[fg_imido_ester-1])
    printf("imido ester\n");
  if (fg[fg_imidoyl_halide-1])
    printf("imidoyl halide\n");
  /*  if fg[fg_thiocarboxylic_acid_deriv]      then writeln('thiocarboxylic acid derivative');*/
  if (fg[fg_thiocarboxylic_acid-1])
    printf("thiocarboxylic acid\n");
  if (fg[fg_thiocarboxylic_acid_ester-1])
    printf("thiocarboxylic acid ester\n");
  if (fg[fg_thiolactone-1])
    printf("thiolactone\n");
  if (fg[fg_thiocarboxylic_acid_amide-1])
    printf("thiocarboxylic acid amide\n");
  if (fg[fg_thiolactam-1])
    printf("thiolactam\n");
  if (fg[fg_imido_thioester-1])
    printf("imidothioester\n");
  if (fg[fg_oxohetarene-1])
    printf("oxo(het)arene\n");
  if (fg[fg_thioxohetarene-1])
    printf("thioxo(het)arene\n");
  if (fg[fg_iminohetarene-1])
    printf("imino(het)arene\n");
  if (fg[fg_orthocarboxylic_acid_deriv-1])
    printf("orthocarboxylic acid derivative\n");
  if (fg[fg_carboxylic_acid_orthoester-1])
    printf("orthoester\n");
  if (fg[fg_carboxylic_acid_amide_acetal-1])
    printf("amide acetal\n");
  if (fg[fg_carboxylic_acid_anhydride-1])
    printf("carboxylic acid anhydride\n");
  /*  if fg[fg_carboxylic_acid_imide]          then writeln('carboxylic acid imide');*/
  if (fg[fg_carboxylic_acid_unsubst_imide-1])
    printf("carboxylic acid imide, N-unsubstituted\n");
  if (fg[fg_carboxylic_acid_subst_imide-1])
    printf("carboxylic acid imide, N-substituted\n");
  if (fg[fg_co2_deriv-1])
    printf("CO2 derivative (general)\n");
  if (fg[fg_carbonic_acid_deriv-1] &&
      !(fg[fg_carbonic_acid_monoester-1] || fg[fg_carbonic_acid_diester-1] ||
	fg[fg_carbonic_acid_ester_halide-1]))
	/* changed in v0.3c*/
	  printf("carbonic acid derivative\n");
  if (fg[fg_carbonic_acid_monoester-1])
    printf("carbonic acid monoester\n");
  if (fg[fg_carbonic_acid_diester-1])
    printf("carbonic acid diester\n");
  if (fg[fg_carbonic_acid_ester_halide-1])
    printf("carbonic acid ester halide (alkyl/aryl haloformate)\n");
  if (fg[fg_thiocarbonic_acid_deriv-1])
    printf("thiocarbonic acid derivative\n");
  if (fg[fg_thiocarbonic_acid_monoester-1])
    printf("thiocarbonic acid monoester\n");
  if (fg[fg_thiocarbonic_acid_diester-1])
    printf("thiocarbonic acid diester\n");
  if (fg[fg_thiocarbonic_acid_ester_halide-1])
    printf("thiocarbonic acid ester halide (alkyl/aryl halothioformate)\n");
  if (fg[fg_carbamic_acid_deriv-1] &&
      !(fg[fg_carbamic_acid-1] || fg[fg_carbamic_acid_ester-1] ||
	fg[fg_carbamic_acid_halide-1]))
	/* changed in v0.3c*/
	  printf("carbamic acid derivative\n");
  if (fg[fg_carbamic_acid-1])
    printf("carbamic acid\n");
  if (fg[fg_carbamic_acid_ester-1])
    printf("carbamic acid ester (urethane)\n");
  if (fg[fg_carbamic_acid_halide-1])
    printf("carbamic acid halide (haloformic acid amide)\n");
  if (fg[fg_thiocarbamic_acid_deriv-1] &&
      !(fg[fg_thiocarbamic_acid-1] || fg[fg_thiocarbamic_acid_ester-1] ||
	fg[fg_thiocarbamic_acid_halide-1]))
	/* changed in v0.3c*/
	  printf("thiocarbamic acid derivative\n");
  if (fg[fg_thiocarbamic_acid-1])
    printf("thiocarbamic acid\n");
  if (fg[fg_thiocarbamic_acid_ester-1])
    printf("thiocarbamic acid ester\n");
  if (fg[fg_thiocarbamic_acid_halide-1])
    printf("thiocarbamic acid halide (halothioformic acid amide)\n");
  if (fg[fg_urea-1])
    printf("urea\n");
  if (fg[fg_isourea-1])
    printf("isourea\n");
  if (fg[fg_thiourea-1])
    printf("thiourea\n");
  if (fg[fg_isothiourea-1])
    printf("isothiourea\n");
  if (fg[fg_guanidine-1])
    printf("guanidine\n");
  if (fg[fg_semicarbazide-1])
    printf("semicarbazide\n");
  if (fg[fg_thiosemicarbazide-1])
    printf("thiosemicarbazide\n");
  if (fg[fg_azide-1])
    printf("azide\n");
  if (fg[fg_azo_compound-1])
    printf("azo compound\n");
  if (fg[fg_diazonium_salt-1])
    printf("diazonium salt\n");
  if (fg[fg_isonitrile-1])
    printf("isonitrile\n");
  if (fg[fg_cyanate-1])
    printf("cyanate\n");
  if (fg[fg_isocyanate-1])
    printf("isocyanate\n");
  if (fg[fg_thiocyanate-1])
    printf("thiocyanate\n");
  if (fg[fg_isothiocyanate-1])
    printf("isothiocyanate\n");
  if (fg[fg_carbodiimide-1])
    printf("carbodiimide\n");
  if (fg[fg_nitroso_compound-1])
    printf("nitroso compound\n");
  if (fg[fg_nitro_compound-1])
    printf("nitro compound\n");
  if (fg[fg_nitrite-1])
    printf("nitrite\n");
  if (fg[fg_nitrate-1])
    printf("nitrate\n");
  /*  if fg[fg_sulfuric_acid_deriv]            then writeln('sulfuric acid derivative');*/
  if (fg[fg_sulfuric_acid-1])
    printf("sulfuric acid\n");
  if (fg[fg_sulfuric_acid_monoester-1])
    printf("sulfuric acid monoester\n");
  if (fg[fg_sulfuric_acid_diester-1])
    printf("sulfuric acid diester\n");
  if (fg[fg_sulfuric_acid_amide_ester-1])
    printf("sulfuric acid amide ester\n");
  if (fg[fg_sulfuric_acid_amide-1])
    printf("sulfuric acid amide\n");
  if (fg[fg_sulfuric_acid_diamide-1])
    printf("sulfuric acid diamide\n");
  if (fg[fg_sulfuryl_halide-1])
    printf("sulfuryl halide\n");
  /*  if fg[fg_sulfonic_acid_deriv]            then writeln('sulfonic acid derivative ');*/
  if (fg[fg_sulfonic_acid-1])
    printf("sulfonic acid\n");
  if (fg[fg_sulfonic_acid_ester-1])
    printf("sulfonic acid ester\n");
  if (fg[fg_sulfonamide-1])
    printf("sulfonamide\n");
  if (fg[fg_sulfonyl_halide-1])
    printf("sulfonyl halide\n");
  if (fg[fg_sulfone-1])
    printf("sulfone\n");
  if (fg[fg_sulfoxide-1])
    printf("sulfoxide\n");
  /*  if fg[fg_sulfinic_acid_deriv]            then writeln('sulfinic acid derivative');*/
  if (fg[fg_sulfinic_acid-1])
    printf("sulfinic acid\n");
  if (fg[fg_sulfinic_acid_ester-1])
    printf("sulfinic acid ester\n");
  if (fg[fg_sulfinic_acid_halide-1])
    printf("sulfinic acid halide\n");
  if (fg[fg_sulfinic_acid_amide-1])
    printf("sulfinic acid amide\n");
  /*  if fg[fg_sulfenic_acid_deriv]            then writeln('sulfenic acid derivative');*/
  if (fg[fg_sulfenic_acid-1])
    printf("sulfenic acid\n");
  if (fg[fg_sulfenic_acid_ester-1])
    printf("sulfenic acid ester\n");
  if (fg[fg_sulfenic_acid_halide-1])
    printf("sulfenic acid halide\n");
  if (fg[fg_sulfenic_acid_amide-1])
    printf("sulfenic acid amide\n");
  if (fg[fg_thiol-1])
    printf("thiol (sulfanyl compound)\n");
  if (fg[fg_alkylthiol-1])
    printf("alkylthiol\n");
  if (fg[fg_arylthiol-1])
    printf("arylthiol\n");
  /*  if fg[fg_phosphoric_acid_deriv]          then writeln('phosphoric acid derivative');*/
  if (fg[fg_phosphoric_acid-1])
    printf("phosphoric acid\n");
  if (fg[fg_phosphoric_acid_ester-1])
    printf("phosphoric acid ester\n");
  if (fg[fg_phosphoric_acid_halide-1])
    printf("phosphoric acid halide\n");
  if (fg[fg_phosphoric_acid_amide-1])
    printf("phosphoric acid amide\n");
  /*  if fg[fg_thiophosphoric_acid_deriv]      then writeln('thiophosphoric acid derivative');*/
  if (fg[fg_thiophosphoric_acid-1])
    printf("thiophosphoric acid\n");
  if (fg[fg_thiophosphoric_acid_ester-1])
    printf("thiophosphoric acid ester\n");
  if (fg[fg_thiophosphoric_acid_halide-1])
    printf("thiophosphoric acid halide\n");
  if (fg[fg_thiophosphoric_acid_amide-1])
    printf("thiophosphoric acid amide\n");
  if (fg[fg_phosphonic_acid_deriv-1])
    printf("phosphonic acid derivative \n");
  if (fg[fg_phosphonic_acid-1])
    printf("phosphonic acid\n");
  if (fg[fg_phosphonic_acid_ester-1])
    printf("phosphonic acid ester\n");
  if (fg[fg_phosphine-1])
    printf("phosphine\n");
  if (fg[fg_phosphinoxide-1])
    printf("phosphine oxide\n");
  if (fg[fg_boronic_acid_deriv-1])
    printf("boronic acid derivative\n");
  if (fg[fg_boronic_acid-1])
    printf("boronic acid\n");
  if (fg[fg_boronic_acid_ester-1])
    printf("boronic acid ester\n");
  if (fg[fg_alkene-1])
    printf("alkene\n");
  if (fg[fg_alkyne-1])
    printf("alkyne\n");
  if (fg[fg_aromatic-1])
    printf("aromatic compound\n");
  if (fg[fg_heterocycle-1])
    printf("heterocyclic compound\n");
  if (fg[fg_alpha_aminoacid-1])
    printf("alpha-aminoacid\n");
  if (fg[fg_alpha_hydroxyacid-1])
    printf("alpha-hydroxyacid\n");
}


Static void write_fg_text_de(void)
{
  if (fg[fg_cation-1])
    printf("Kation\n");
  if (fg[fg_anion-1])
    printf("Anion\n");
  /*  if fg[fg_carbonyl]                       then writeln('Carbonylverbindung');*/
  if (fg[fg_aldehyde-1])
    printf("Aldehyd\n");
  if (fg[fg_ketone-1])
    printf("Keton\n");
  /*  if fg[fg_thiocarbonyl]                   then writeln('Thiocarbonylverbindung');*/
  if (fg[fg_thioaldehyde-1])
    printf("Thioaldehyd\n");
  if (fg[fg_thioketone-1])
    printf("Thioketon\n");
  if (fg[fg_imine-1])
    printf("Imin\n");
  if (fg[fg_hydrazone-1])
    printf("Hydrazon\n");
  if (fg[fg_semicarbazone-1])
    printf("Semicarbazon\n");
  if (fg[fg_thiosemicarbazone-1])
    printf("Thiosemicarbazon\n");
  if (fg[fg_oxime-1])
    printf("Oxim\n");
  if (fg[fg_oxime_ether-1])
    printf("Oximether\n");
  if (fg[fg_ketene-1])
    printf("Keten\n");
  if (fg[fg_ketene_acetal_deriv-1])
    printf("Keten-Acetal oder Derivat\n");
  if (fg[fg_carbonyl_hydrate-1])
    printf("Carbonyl-Hydrat\n");
  if (fg[fg_hemiacetal-1])
    printf("Halbacetal\n");
  if (fg[fg_acetal-1])
    printf("Acetal\n");
  if (fg[fg_hemiaminal-1])
    printf("Halbaminal\n");
  if (fg[fg_aminal-1])
    printf("Aminal\n");
  if (fg[fg_thiohemiaminal-1])
    printf("Thiohalbaminal\n");
  if (fg[fg_thioacetal-1])
    printf("Thioacetal\n");
  if (fg[fg_enamine-1])
    printf("Enamin\n");
  if (fg[fg_enol-1])
    printf("Enol\n");
  if (fg[fg_enolether-1])
    printf("Enolether\n");
  if (fg[fg_hydroxy-1] && hydroxy_generic)
    printf("Hydroxy-Verbindung\n");
  /*  if fg[fg_alcohol]                        then writeln('Alkohol');*/
  if (fg[fg_prim_alcohol-1])
    printf("prim\344rer Alkohol\n");
/* p2c: checkmol3l.pas, line 6713:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_sec_alcohol-1])
    printf("sekund\344rer Alkohol\n");
/* p2c: checkmol3l.pas, line 6714:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_tert_alcohol-1])
    printf("terti\344rer Alkohol\n");
/* p2c: checkmol3l.pas, line 6715:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_1_2_diol-1])
    printf("1,2-Diol\n");
  if (fg[fg_1_2_aminoalcohol-1])
    printf("1,2-Aminoalkohol\n");
  if (fg[fg_phenol-1])
    printf("Phenol oder Hydroxyhetaren\n");
  if (fg[fg_1_2_diphenol-1])
    printf("1,2-Diphenol\n");
  if (fg[fg_enediol-1])
    printf("Endiol\n");
  if (fg[fg_ether-1] && ether_generic)
    printf("Ether\n");
  if (fg[fg_dialkylether-1])
    printf("Dialkylether\n");
  if (fg[fg_alkylarylether-1])
    printf("Alkylarylether \n");
  if (fg[fg_diarylether-1])
    printf("Diarylether\n");
  if (fg[fg_thioether-1])
    printf("Thioether\n");
  if (fg[fg_disulfide-1])
    printf("Disulfid\n");
  if (fg[fg_peroxide-1])
    printf("Peroxid\n");
  if (fg[fg_hydroperoxide-1])
    printf("Hydroperoxid\n");
  if (fg[fg_hydrazine-1])
    printf("Hydrazin-Derivat\n");
  if (fg[fg_hydroxylamine-1])
    printf("Hydroxylamin\n");
  if (fg[fg_amine-1] && amine_generic)
    printf("Amin\n");
  if (fg[fg_prim_amine-1])
    printf("prim\344res Amin\n");
/* p2c: checkmol3l.pas, line 6732:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_prim_aliph_amine-1])
    printf("prim\344res aliphatisches Amin (Alkylamin)\n");
/* p2c: checkmol3l.pas, line 6733:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_prim_arom_amine-1])
    printf("prim\344res aromatisches Amin\n");
/* p2c: checkmol3l.pas, line 6734:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_sec_amine-1])
    printf("sekund\344res Amin\n");
/* p2c: checkmol3l.pas, line 6735:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_sec_aliph_amine-1])
    printf("sekund\344res aliphatisches Amin (Dialkylamin)\n");
/* p2c: checkmol3l.pas, line 6736:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_sec_mixed_amine-1])
    printf("sekund\344res aliphatisches/aromatisches Amin (Alkylarylamin)\n");
/* p2c: checkmol3l.pas, line 6737:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_sec_arom_amine-1])
    printf("sekund\344res aromatisches Amin (Diarylamin)\n");
/* p2c: checkmol3l.pas, line 6738:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_tert_amine-1])
    printf("terti\344res Amin\n");
/* p2c: checkmol3l.pas, line 6739:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_tert_aliph_amine-1])
    printf("terti\344res aliphatisches Amin (Trialkylamin)\n");
/* p2c: checkmol3l.pas, line 6740:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_tert_mixed_amine-1])
    printf("terti\344res aliphatisches/aromatisches Amin (Alkylarylamin)\n");
/* p2c: checkmol3l.pas, line 6741:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_tert_arom_amine-1])
    printf("terti\344res aromatisches Amin (Triarylamin)\n");
/* p2c: checkmol3l.pas, line 6742:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_quart_ammonium-1])
    printf("quart\344res Ammoniumsalz\n");
/* p2c: checkmol3l.pas, line 6743:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_n_oxide-1])
    printf("N-Oxid\n");
  /* new in v0.2f*/
  if (fg[fg_halogen_deriv-1]) {
    if (!fg[fg_alkyl_halide-1] && !fg[fg_aryl_halide-1] &&
	!fg[fg_acyl_halide-1])
      printf("Halogenverbindung\n");
  }
  /*  if fg[fg_alkyl_halide]                   then writeln('Alkylhalogenid');*/
  if (fg[fg_alkyl_fluoride-1])
    printf("Alkylfluorid\n");
  if (fg[fg_alkyl_chloride-1])
    printf("Alkylchlorid\n");
  if (fg[fg_alkyl_bromide-1])
    printf("Alkylbromid\n");
  if (fg[fg_alkyl_iodide-1])
    printf("Alkyliodid\n");
  /*  if fg[fg_aryl_halide]                    then writeln('Arylhalogenid');*/
  if (fg[fg_aryl_fluoride-1])
    printf("Arylfluorid\n");
  if (fg[fg_aryl_chloride-1])
    printf("Arylchlorid\n");
  if (fg[fg_aryl_bromide-1])
    printf("Arylbromid\n");
  if (fg[fg_aryl_iodide-1])
    printf("Aryliodid\n");
  if (fg[fg_organometallic-1])
    printf("Organometall-Verbindung\n");
  if (fg[fg_organolithium-1])
    printf("Organolithium-Verbindung\n");
  if (fg[fg_organomagnesium-1])
    printf("Organomagnesium-Verbindung\n");
  /*  if fg[fg_carboxylic_acid_deriv]          then writeln('Carbonsure-Derivat');*/
  if (fg[fg_carboxylic_acid-1])
    printf("Carbons\344ure\n");
/* p2c: checkmol3l.pas, line 6765:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_carboxylic_acid_salt-1])
    printf("Carbons\344uresalz\n");
/* p2c: checkmol3l.pas, line 6766:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_carboxylic_acid_ester-1])
    printf("Carbons\344ureester\n");
/* p2c: checkmol3l.pas, line 6767:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_lactone-1])
    printf("Lacton\n");
  /*  if fg[fg_carboxylic_acid_amide]          then writeln('Carbonsureamid');*/
  if (fg[fg_carboxylic_acid_prim_amide-1])
    printf("prim\344res Carbons\344ureamid\n");
/* p2c: checkmol3l.pas, line 6770:
 * Note: Characters >= 128 encountered [281] */
  if (fg[fg_carboxylic_acid_sec_amide-1])
    printf("sekund\344res Carbons\344ureamid\n");
/* p2c: checkmol3l.pas, line 6771:
 * Note: Characters >= 128 encountered [281] */
  if (fg[fg_carboxylic_acid_tert_amide-1])
    printf("terti\344res Carbons\344ureamid\n");
/* p2c: checkmol3l.pas, line 6772:
 * Note: Characters >= 128 encountered [281] */
  if (fg[fg_lactam-1])
    printf("Lactam\n");
  if (fg[fg_carboxylic_acid_hydrazide-1])
    printf("Carbons\344urehydrazid\n");
/* p2c: checkmol3l.pas, line 6774:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_carboxylic_acid_azide-1])
    printf("Carbons\344ureazid\n");
/* p2c: checkmol3l.pas, line 6775:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_hydroxamic_acid-1])
    printf("Hydroxams\344ure\n");
/* p2c: checkmol3l.pas, line 6776:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_carboxylic_acid_amidine-1])
    printf("Carbons\344ureamidin\n");
/* p2c: checkmol3l.pas, line 6777:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_carboxylic_acid_amidrazone-1])
    printf("Carbons\344ureamidrazon\n");
/* p2c: checkmol3l.pas, line 6778:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_nitrile-1])
    printf("Carbonitril\n");
  /*  if fg[fg_acyl_halide]                    then writeln('Acylhalogenid');*/
  if (fg[fg_acyl_fluoride-1])
    printf("Acylfluorid\n");
  if (fg[fg_acyl_chloride-1])
    printf("Acylchlorid\n");
  if (fg[fg_acyl_bromide-1])
    printf("Acylbromid\n");
  if (fg[fg_acyl_iodide-1])
    printf("Acyliodid\n");
  if (fg[fg_acyl_cyanide-1])
    printf("Acylcyanid\n");
  if (fg[fg_imido_ester-1])
    printf("Imidoester\n");
  if (fg[fg_imidoyl_halide-1])
    printf("Imidoylhalogenid\n");
  /*  if fg[fg_thiocarboxylic_acid_deriv]      then writeln('Thiocarbonsure-Derivat');*/
  if (fg[fg_thiocarboxylic_acid-1])
    printf("Thiocarbons\344ure\n");
/* p2c: checkmol3l.pas, line 6789:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_thiocarboxylic_acid_ester-1])
    printf("Thiocarbons\344ureester\n");
/* p2c: checkmol3l.pas, line 6790:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_thiolactone-1])
    printf("Thiolacton\n");
  if (fg[fg_thiocarboxylic_acid_amide-1])
    printf("Thiocarbons\344ureamid\n");
/* p2c: checkmol3l.pas, line 6792:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_thiolactam-1])
    printf("Thiolactam\n");
  if (fg[fg_imido_thioester-1])
    printf("Imidothioester\n");
  if (fg[fg_oxohetarene-1])
    printf("Oxo(het)aren\n");
  if (fg[fg_thioxohetarene-1])
    printf("Thioxo(het)aren\n");
  if (fg[fg_iminohetarene-1])
    printf("Imino(het)aren\n");
  if (fg[fg_orthocarboxylic_acid_deriv-1])
    printf("Orthocarbons\344ure-Derivat\n");
/* p2c: checkmol3l.pas, line 6798:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_carboxylic_acid_orthoester-1])
    printf("Orthoester\n");
  if (fg[fg_carboxylic_acid_amide_acetal-1])
    printf("Amidacetal\n");
  if (fg[fg_carboxylic_acid_anhydride-1])
    printf("Carbons\344ureanhydrid\n");
/* p2c: checkmol3l.pas, line 6801:
 * Note: Character >= 128 encountered [281] */
  /*  if fg[fg_carboxylic_acid_imide]          then writeln('Carbonsureimid');*/
  if (fg[fg_carboxylic_acid_unsubst_imide-1])
    printf("Carbons\344ureimid, N-unsubstituiert\n");
/* p2c: checkmol3l.pas, line 6803:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_carboxylic_acid_subst_imide-1])
    printf("Carbons\344ureimid, N-substituiert\n");
/* p2c: checkmol3l.pas, line 6804:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_co2_deriv-1])
    printf("CO2-Derivat (allgemein)\n");
  if (fg[fg_carbonic_acid_deriv-1] &&
      !(fg[fg_carbonic_acid_monoester-1] || fg[fg_carbonic_acid_diester-1] ||
	fg[fg_carbonic_acid_ester_halide-1]))
	/* changed in v0.3c*/
	  printf("Kohlens\344ure-Dervivat\n");
/* p2c: checkmol3l.pas, line 6809:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_carbonic_acid_monoester-1])
    printf("Kohlens\344uremonoester\n");
/* p2c: checkmol3l.pas, line 6810:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_carbonic_acid_diester-1])
    printf("Kohlens\344urediester\n");
/* p2c: checkmol3l.pas, line 6811:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_carbonic_acid_ester_halide-1])
    printf("Kohlens\344ureesterhalogenid (Alkyl/Aryl-Halogenformiat)\n");
/* p2c: checkmol3l.pas, line 6812:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_thiocarbonic_acid_deriv-1])
    printf("Thiokohlens\344ure-Derivat\n");
/* p2c: checkmol3l.pas, line 6813:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_thiocarbonic_acid_monoester-1])
    printf("Thiokohlens\344uremonoester\n");
/* p2c: checkmol3l.pas, line 6814:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_thiocarbonic_acid_diester-1])
    printf("Thiokohlens\344urediester\n");
/* p2c: checkmol3l.pas, line 6815:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_thiocarbonic_acid_ester_halide-1])
    printf("Thiokohlens\344ureesterhalogenid (Alkyl/Aryl-Halogenthioformiat)\n");
/* p2c: checkmol3l.pas, line 6816:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_carbamic_acid_deriv-1] &&
      !(fg[fg_carbamic_acid-1] || fg[fg_carbamic_acid_ester-1] ||
	fg[fg_carbamic_acid_halide-1]))
	/* changed in v0.3c*/
	  printf("Carbamins\344ure-Derivat\n");
/* p2c: checkmol3l.pas, line 6820:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_carbamic_acid-1])
    printf("Carbamins\344ure\n");
/* p2c: checkmol3l.pas, line 6821:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_carbamic_acid_ester-1])
    printf("Carbamins\344ureester (Urethan)\n");
/* p2c: checkmol3l.pas, line 6822:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_carbamic_acid_halide-1])
    printf("Carbamins\344urehalogenid (Halogenformamid)\n");
/* p2c: checkmol3l.pas, line 6823:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_thiocarbamic_acid_deriv-1] &&
      !(fg[fg_thiocarbamic_acid-1] || fg[fg_thiocarbamic_acid_ester-1] ||
	fg[fg_thiocarbamic_acid_halide-1]))
	/* changed in v0.3c*/
	  printf("Thiocarbamins\344ure-Derivat\n");
/* p2c: checkmol3l.pas, line 6827:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_thiocarbamic_acid-1])
    printf("Thiocarbamins\344ure\n");
/* p2c: checkmol3l.pas, line 6828:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_thiocarbamic_acid_ester-1])
    printf("Thiocarbamins\344ureester\n");
/* p2c: checkmol3l.pas, line 6829:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_thiocarbamic_acid_halide-1])
    printf("Thiocarbamins\344urehalogenid (Halogenthioformamid)\n");
/* p2c: checkmol3l.pas, line 6830:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_urea-1])
    printf("Harnstoff\n");
  if (fg[fg_isourea-1])
    printf("Isoharnstoff\n");
  if (fg[fg_thiourea-1])
    printf("Thioharnstoff\n");
  if (fg[fg_isothiourea-1])
    printf("Isothioharnstoff\n");
  if (fg[fg_guanidine-1])
    printf("Guanidin\n");
  if (fg[fg_semicarbazide-1])
    printf("Semicarbazid\n");
  if (fg[fg_thiosemicarbazide-1])
    printf("Thiosemicarbazid\n");
  if (fg[fg_azide-1])
    printf("Azid\n");
  if (fg[fg_azo_compound-1])
    printf("Azoverbindung\n");
  if (fg[fg_diazonium_salt-1])
    printf("Diazoniumsalz\n");
  if (fg[fg_isonitrile-1])
    printf("Isonitril\n");
  if (fg[fg_cyanate-1])
    printf("Cyanat\n");
  if (fg[fg_isocyanate-1])
    printf("Isocyanat\n");
  if (fg[fg_thiocyanate-1])
    printf("Thiocyanat\n");
  if (fg[fg_isothiocyanate-1])
    printf("Isothiocyanat\n");
  if (fg[fg_carbodiimide-1])
    printf("Carbodiimid\n");
  if (fg[fg_nitroso_compound-1])
    printf("Nitroso-Verbindung\n");
  if (fg[fg_nitro_compound-1])
    printf("Nitro-Verbindung\n");
  if (fg[fg_nitrite-1])
    printf("Nitrit\n");
  if (fg[fg_nitrate-1])
    printf("Nitrat\n");
  /*  if fg[fg_sulfuric_acid_deriv]            then writeln('Schwefelsure-Derivat');*/
  if (fg[fg_sulfuric_acid-1])
    printf("Schwefels\344ure\n");
/* p2c: checkmol3l.pas, line 6852:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_sulfuric_acid_monoester-1])
    printf("Schwefels\344uremonoester\n");
/* p2c: checkmol3l.pas, line 6853:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_sulfuric_acid_diester-1])
    printf("Schwefels\344urediester\n");
/* p2c: checkmol3l.pas, line 6854:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_sulfuric_acid_amide_ester-1])
    printf("Schwefels\344ureamidester\n");
/* p2c: checkmol3l.pas, line 6855:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_sulfuric_acid_amide-1])
    printf("Schwefels\344ureamid\n");
/* p2c: checkmol3l.pas, line 6856:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_sulfuric_acid_diamide-1])
    printf("Schwefels\344urediamid\n");
/* p2c: checkmol3l.pas, line 6857:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_sulfuryl_halide-1])
    printf("Sulfurylhalogenid\n");
  /*  if fg[fg_sulfonic_acid_deriv]            then writeln('Sulfonsure-Derivat ');*/
  if (fg[fg_sulfonic_acid-1])
    printf("Sulfons\344ure\n");
/* p2c: checkmol3l.pas, line 6860:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_sulfonic_acid_ester-1])
    printf("Sulfons\344ureester\n");
/* p2c: checkmol3l.pas, line 6861:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_sulfonamide-1])
    printf("Sulfonamid\n");
  if (fg[fg_sulfonyl_halide-1])
    printf("Sulfonylhalogenid\n");
  if (fg[fg_sulfone-1])
    printf("Sulfon\n");
  if (fg[fg_sulfoxide-1])
    printf("Sulfoxid\n");
  /*  if fg[fg_sulfinic_acid_deriv]            then writeln('Sulfinsure-Derivat');*/
  if (fg[fg_sulfinic_acid-1])
    printf("Sulfins\344ure\n");
/* p2c: checkmol3l.pas, line 6867:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_sulfinic_acid_ester-1])
    printf("Sulfins\344ureester\n");
/* p2c: checkmol3l.pas, line 6868:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_sulfinic_acid_halide-1])
    printf("Sulfins\344urehalogenid\n");
/* p2c: checkmol3l.pas, line 6869:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_sulfinic_acid_amide-1])
    printf("Sulfins\344ureamid\n");
/* p2c: checkmol3l.pas, line 6870:
 * Note: Character >= 128 encountered [281] */
  /*  if fg[fg_sulfenic_acid_deriv]            then writeln('Sulfensure-Derivat');*/
  if (fg[fg_sulfenic_acid-1])
    printf("Sulfens\344ure\n");
/* p2c: checkmol3l.pas, line 6872:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_sulfenic_acid_ester-1])
    printf("Sulfens\344ureester\n");
/* p2c: checkmol3l.pas, line 6873:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_sulfenic_acid_halide-1])
    printf("Sulfens\344urehalogenid\n");
/* p2c: checkmol3l.pas, line 6874:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_sulfenic_acid_amide-1])
    printf("Sulfens\344ureamid\n");
/* p2c: checkmol3l.pas, line 6875:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_thiol-1])
    printf("Thiol (Sulfanyl-Verbindung, Mercaptan)\n");
  if (fg[fg_alkylthiol-1])
    printf("Alkylthiol\n");
  if (fg[fg_arylthiol-1])
    printf("Arylthiol\n");
  /*  if fg[fg_phosphoric_acid_deriv]          then writeln('Phosphorsure-Derivat');*/
  if (fg[fg_phosphoric_acid-1])
    printf("Phosphors\344ure\n");
/* p2c: checkmol3l.pas, line 6880:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_phosphoric_acid_ester-1])
    printf("Phosphors\344ureester\n");
/* p2c: checkmol3l.pas, line 6881:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_phosphoric_acid_halide-1])
    printf("Phosphors\344urehalogenid\n");
/* p2c: checkmol3l.pas, line 6882:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_phosphoric_acid_amide-1])
    printf("Phosphors\344ureamid\n");
/* p2c: checkmol3l.pas, line 6883:
 * Note: Character >= 128 encountered [281] */
  /*  if fg[fg_thiophosphoric_acid_deriv]      then writeln('Thiophosphorsure-Derivat');*/
  if (fg[fg_thiophosphoric_acid-1])
    printf("Thiophosphors\344ure\n");
/* p2c: checkmol3l.pas, line 6885:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_thiophosphoric_acid_ester-1])
    printf("Thiophosphors\344ureester\n");
/* p2c: checkmol3l.pas, line 6886:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_thiophosphoric_acid_halide-1])
    printf("Thiophosphors\344urehalogenid\n");
/* p2c: checkmol3l.pas, line 6887:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_thiophosphoric_acid_amide-1])
    printf("Thiophosphors\344ureamid\n");
/* p2c: checkmol3l.pas, line 6888:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_phosphonic_acid_deriv-1])
    printf("Phosphons\344ure-Derivat \n");
/* p2c: checkmol3l.pas, line 6889:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_phosphonic_acid-1])
    printf("Phosphons\344ure\n");
/* p2c: checkmol3l.pas, line 6890:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_phosphonic_acid_ester-1])
    printf("Phosphons\344ureester\n");
/* p2c: checkmol3l.pas, line 6891:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_phosphine-1])
    printf("Phosphin\n");
  if (fg[fg_phosphinoxide-1])
    printf("Phosphinoxid\n");
  if (fg[fg_boronic_acid_deriv-1])
    printf("Borons\344ure-Derivat\n");
/* p2c: checkmol3l.pas, line 6894:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_boronic_acid-1])
    printf("Borons\344ure\n");
/* p2c: checkmol3l.pas, line 6895:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_boronic_acid_ester-1])
    printf("Borons\344ureester\n");
/* p2c: checkmol3l.pas, line 6896:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_alkene-1])
    printf("Alken\n");
  if (fg[fg_alkyne-1])
    printf("Alkin\n");
  if (fg[fg_aromatic-1])
    printf("aromatische Verbindung\n");
  if (fg[fg_heterocycle-1])
    printf("heterocyclische Verbindung\n");
  if (fg[fg_alpha_aminoacid-1])
    printf("alpha-Aminos\344ure\n");
/* p2c: checkmol3l.pas, line 6901:
 * Note: Character >= 128 encountered [281] */
  if (fg[fg_alpha_hydroxyacid-1])
    printf("alpha-Hydroxys\344ure\n");
/* p2c: checkmol3l.pas, line 6902:
 * Note: Character >= 128 encountered [281] */
}


#define sc              ';'


Static void write_fg_code(void)
{
  if (fg[fg_cation-1])
    printf("000000T2%c", sc);
  if (fg[fg_anion-1])
    printf("000000T1%c", sc);
  /*  if fg[fg_carbonyl]                       then write('C2O10000',sc);*/
  if (fg[fg_aldehyde-1])
    printf("C2O1H000%c", sc);
  if (fg[fg_ketone-1])
    printf("C2O1C000%c", sc);
  /*  if fg[fg_thiocarbonyl]                   then write('C2S10000',sc);*/
  if (fg[fg_thioaldehyde-1])
    printf("C2S1H000%c", sc);
  if (fg[fg_thioketone-1])
    printf("C2S1C000%c", sc);
  if (fg[fg_imine-1])
    printf("C2N10000%c", sc);
  if (fg[fg_hydrazone-1])
    printf("C2N1N000%c", sc);
  if (fg[fg_semicarbazone-1])
    printf("C2NNC4ON%c", sc);
  if (fg[fg_thiosemicarbazone-1])
    printf("C2NNC4SN%c", sc);
  if (fg[fg_oxime-1])
    printf("C2N1OH00%c", sc);
  if (fg[fg_oxime_ether-1])
    printf("C2N1OC00%c", sc);
  if (fg[fg_ketene-1])
    printf("C3OC0000%c", sc);
  if (fg[fg_ketene_acetal_deriv-1])
    printf("C3OCC000%c", sc);
  if (fg[fg_carbonyl_hydrate-1])
    printf("C2O2H200%c", sc);
  if (fg[fg_hemiacetal-1])
    printf("C2O2HC00%c", sc);
  if (fg[fg_acetal-1])
    printf("C2O2CC00%c", sc);
  if (fg[fg_hemiaminal-1])
    printf("C2NOHC10%c", sc);
  if (fg[fg_aminal-1])
    printf("C2N2CC10%c", sc);
  if (fg[fg_thiohemiaminal-1])
    printf("C2NSHC10%c", sc);
  if (fg[fg_thioacetal-1])
    printf("C2S2CC00%c", sc);
  if (fg[fg_enamine-1])
    printf("C2CNH000%c", sc);
  if (fg[fg_enol-1])
    printf("C2COH000%c", sc);
  if (fg[fg_enolether-1])
    printf("C2COC000%c", sc);
  if (fg[fg_hydroxy-1] && hydroxy_generic)
    printf("O1H00000%c", sc);
  /*  if fg[fg_alcohol]                        then write('O1H0C000',sc);*/
  if (fg[fg_prim_alcohol-1])
    printf("O1H1C000%c", sc);
  if (fg[fg_sec_alcohol-1])
    printf("O1H2C000%c", sc);
  if (fg[fg_tert_alcohol-1])
    printf("O1H3C000%c", sc);
  if (fg[fg_1_2_diol-1])
    printf("O1H0CO1H%c", sc);
  if (fg[fg_1_2_aminoalcohol-1])
    printf("O1H0CN1C%c", sc);
  if (fg[fg_phenol-1])
    printf("O1H1A000%c", sc);
  if (fg[fg_1_2_diphenol-1])
    printf("O1H2A000%c", sc);
  if (fg[fg_enediol-1])
    printf("C2COH200%c", sc);
  if (fg[fg_ether-1] && ether_generic)
    printf("O1C00000%c", sc);
  if (fg[fg_dialkylether-1])
    printf("O1C0CC00%c", sc);
  if (fg[fg_alkylarylether-1])
    printf("O1C0CA00%c", sc);
  if (fg[fg_diarylether-1])
    printf("O1C0AA00%c", sc);
  if (fg[fg_thioether-1])
    printf("S1C00000%c", sc);
  if (fg[fg_disulfide-1])
    printf("S1S1C000%c", sc);
  if (fg[fg_peroxide-1])
    printf("O1O1C000%c", sc);
  if (fg[fg_hydroperoxide-1])
    printf("O1O1H000%c", sc);
  if (fg[fg_hydrazine-1])
    printf("N1N10000%c", sc);
  if (fg[fg_hydroxylamine-1])
    printf("N1O1H000%c", sc);
  if (fg[fg_amine-1] && amine_generic)
    printf("N1C00000%c", sc);
  /*  if fg[fg_prim_amine]                     then write('N1C10000',sc);*/
  if (fg[fg_prim_aliph_amine-1])
    printf("N1C1C000%c", sc);
  if (fg[fg_prim_arom_amine-1])
    printf("N1C1A000%c", sc);
  /*  if fg[fg_sec_amine]                      then write('N1C20000',sc);*/
  if (fg[fg_sec_aliph_amine-1])
    printf("N1C2CC00%c", sc);
  if (fg[fg_sec_mixed_amine-1])
    printf("N1C2AC00%c", sc);
  if (fg[fg_sec_arom_amine-1])
    printf("N1C2AA00%c", sc);
  /*  if fg[fg_tert_amine]                     then write('N1C30000',sc);*/
  if (fg[fg_tert_aliph_amine-1])
    printf("N1C3CC00%c", sc);
  if (fg[fg_tert_mixed_amine-1])
    printf("N1C3AC00%c", sc);
  if (fg[fg_tert_arom_amine-1])
    printf("N1C3AA00%c", sc);
  if (fg[fg_quart_ammonium-1])
    printf("N1C400T2%c", sc);
  if (fg[fg_n_oxide-1])
    printf("N0O10000%c", sc);
  /*  if fg[fg_halogen_deriv]                  then write('XX000000',sc);*/
  /* new in v0.2f*/
  if (fg[fg_halogen_deriv-1]) {
    if (!fg[fg_alkyl_halide-1] && !fg[fg_aryl_halide-1] &&
	!fg[fg_acyl_halide-1])
      printf("XX000000%c", sc);
  }
  /*  if fg[fg_alkyl_halide]                   then write('XX00C000',sc);*/
  if (fg[fg_alkyl_fluoride-1])
    printf("XF00C000%c", sc);
  if (fg[fg_alkyl_chloride-1])
    printf("XC00C000%c", sc);
  if (fg[fg_alkyl_bromide-1])
    printf("XB00C000%c", sc);
  if (fg[fg_alkyl_iodide-1])
    printf("XI00C000%c", sc);
  /*  if fg[fg_aryl_halide]                    then write('XX00A000',sc);*/
  if (fg[fg_aryl_fluoride-1])
    printf("XF00A000%c", sc);
  if (fg[fg_aryl_chloride-1])
    printf("XC00A000%c", sc);
  if (fg[fg_aryl_bromide-1])
    printf("XB00A000%c", sc);
  if (fg[fg_aryl_iodide-1])
    printf("XI00A000%c", sc);
  if (fg[fg_organometallic-1])
    printf("000000MX%c", sc);
  if (fg[fg_organolithium-1])
    printf("000000ML%c", sc);
  if (fg[fg_organomagnesium-1])
    printf("000000MM%c", sc);
  /*  if fg[fg_carboxylic_acid_deriv]          then write('C3O20000',sc);*/
  if (fg[fg_carboxylic_acid-1])
    printf("C3O2H000%c", sc);
  if (fg[fg_carboxylic_acid_salt-1])
    printf("C3O200T1%c", sc);
  if (fg[fg_carboxylic_acid_ester-1])
    printf("C3O2C000%c", sc);
  if (fg[fg_lactone-1])
    printf("C3O2CZ00%c", sc);
  /*  if fg[fg_carboxylic_acid_amide]          then write('C3ONC000',sc);*/
  if (fg[fg_carboxylic_acid_prim_amide-1])
    printf("C3ONC100%c", sc);
  if (fg[fg_carboxylic_acid_sec_amide-1])
    printf("C3ONC200%c", sc);
  if (fg[fg_carboxylic_acid_tert_amide-1])
    printf("C3ONC300%c", sc);
  if (fg[fg_lactam-1])
    printf("C3ONCZ00%c", sc);
  if (fg[fg_carboxylic_acid_hydrazide-1])
    printf("C3ONN100%c", sc);
  if (fg[fg_carboxylic_acid_azide-1])
    printf("C3ONN200%c", sc);
  if (fg[fg_hydroxamic_acid-1])
    printf("C3ONOH00%c", sc);
  if (fg[fg_carboxylic_acid_amidine-1])
    printf("C3N2H000%c", sc);
  if (fg[fg_carboxylic_acid_amidrazone-1])
    printf("C3NNN100%c", sc);
  if (fg[fg_nitrile-1])
    printf("C3N00000%c", sc);
  /*  if fg[fg_acyl_halide]                    then write('C3OXX000',sc);*/
  if (fg[fg_acyl_fluoride-1])
    printf("C3OXF000%c", sc);
  if (fg[fg_acyl_chloride-1])
    printf("C3OXC000%c", sc);
  if (fg[fg_acyl_bromide-1])
    printf("C3OXB000%c", sc);
  if (fg[fg_acyl_iodide-1])
    printf("C3OXI000%c", sc);
  if (fg[fg_acyl_cyanide-1])
    printf("C2OC3N00%c", sc);
  if (fg[fg_imido_ester-1])
    printf("C3NOC000%c", sc);
  if (fg[fg_imidoyl_halide-1])
    printf("C3NXX000%c", sc);
  /*  if fg[fg_thiocarboxylic_acid_deriv]      then write('C3SO0000',sc);*/
  if (fg[fg_thiocarboxylic_acid-1])
    printf("C3SOH000%c", sc);
  if (fg[fg_thiocarboxylic_acid_ester-1])
    printf("C3SOC000%c", sc);
  if (fg[fg_thiolactone-1])
    printf("C3SOCZ00%c", sc);
  if (fg[fg_thiocarboxylic_acid_amide-1])
    printf("C3SNH000%c", sc);
  if (fg[fg_thiolactam-1])
    printf("C3SNCZ00%c", sc);
  if (fg[fg_imido_thioester-1])
    printf("C3NSC000%c", sc);
  if (fg[fg_oxohetarene-1])
    printf("C3ONAZ00%c", sc);
  if (fg[fg_thioxohetarene-1])
    printf("C3SNAZ00%c", sc);
  if (fg[fg_iminohetarene-1])
    printf("C3NNAZ00%c", sc);
  if (fg[fg_orthocarboxylic_acid_deriv-1])
    printf("C3O30000%c", sc);
  if (fg[fg_carboxylic_acid_orthoester-1])
    printf("C3O3C000%c", sc);
  if (fg[fg_carboxylic_acid_amide_acetal-1])
    printf("C3O3NC00%c", sc);
  if (fg[fg_carboxylic_acid_anhydride-1])
    printf("C3O2C3O2%c", sc);
  /*  if fg[fg_carboxylic_acid_imide]          then write('C3ONC000',sc);*/
  if (fg[fg_carboxylic_acid_unsubst_imide-1])
    printf("C3ONCH10%c", sc);
  if (fg[fg_carboxylic_acid_subst_imide-1])
    printf("C3ONCC10%c", sc);
  if (fg[fg_co2_deriv-1])
    printf("C4000000%c", sc);
  if (fg[fg_carbonic_acid_deriv-1])
    printf("C4O30000%c", sc);
  if (fg[fg_carbonic_acid_monoester-1])
    printf("C4O3C100%c", sc);
  if (fg[fg_carbonic_acid_diester-1])
    printf("C4O3C200%c", sc);
  if (fg[fg_carbonic_acid_ester_halide-1])
    printf("C4O3CX00%c", sc);
  if (fg[fg_thiocarbonic_acid_deriv-1])
    printf("C4SO0000%c", sc);
  if (fg[fg_thiocarbonic_acid_monoester-1])
    printf("C4SOC100%c", sc);
  if (fg[fg_thiocarbonic_acid_diester-1])
    printf("C4SOC200%c", sc);
  if (fg[fg_thiocarbonic_acid_ester_halide-1])
    printf("C4SOX_00%c", sc);
  if (fg[fg_carbamic_acid_deriv-1])
    printf("C4O2N000%c", sc);
  if (fg[fg_carbamic_acid-1])
    printf("C4O2NH00%c", sc);
  if (fg[fg_carbamic_acid_ester-1])
    printf("C4O2NC00%c", sc);
  if (fg[fg_carbamic_acid_halide-1])
    printf("C4O2NX00%c", sc);
  if (fg[fg_thiocarbamic_acid_deriv-1])
    printf("C4SN0000%c", sc);
  if (fg[fg_thiocarbamic_acid-1])
    printf("C4SNOH00%c", sc);
  if (fg[fg_thiocarbamic_acid_ester-1])
    printf("C4SNOC00%c", sc);
  if (fg[fg_thiocarbamic_acid_halide-1])
    printf("C4SNXX00%c", sc);
  if (fg[fg_urea-1])
    printf("C4O1N200%c", sc);
  if (fg[fg_isourea-1])
    printf("C4N2O100%c", sc);
  if (fg[fg_thiourea-1])
    printf("C4S1N200%c", sc);
  if (fg[fg_isothiourea-1])
    printf("C4N2S100%c", sc);
  if (fg[fg_guanidine-1])
    printf("C4N30000%c", sc);
  if (fg[fg_semicarbazide-1])
    printf("C4ON2N00%c", sc);
  if (fg[fg_thiosemicarbazide-1])
    printf("C4SN2N00%c", sc);
  if (fg[fg_azide-1])
    printf("N4N20000%c", sc);
  if (fg[fg_azo_compound-1])
    printf("N2N10000%c", sc);
  if (fg[fg_diazonium_salt-1])
    printf("N3N100T2%c", sc);
  if (fg[fg_isonitrile-1])
    printf("N3C10000%c", sc);
  if (fg[fg_cyanate-1])
    printf("C4NO1000%c", sc);
  if (fg[fg_isocyanate-1])
    printf("C4NO2000%c", sc);
  if (fg[fg_thiocyanate-1])
    printf("C4NS1000%c", sc);
  if (fg[fg_isothiocyanate-1])
    printf("C4NS2000%c", sc);
  if (fg[fg_carbodiimide-1])
    printf("C4N20000%c", sc);
  if (fg[fg_nitroso_compound-1])
    printf("N2O10000%c", sc);
  if (fg[fg_nitro_compound-1])
    printf("N4O20000%c", sc);
  if (fg[fg_nitrite-1])
    printf("N3O20000%c", sc);
  if (fg[fg_nitrate-1])
    printf("N4O30000%c", sc);
  if (fg[fg_sulfuric_acid_deriv-1])
    printf("S6O00000%c", sc);
  if (fg[fg_sulfuric_acid-1])
    printf("S6O4H000%c", sc);
  if (fg[fg_sulfuric_acid_monoester-1])
    printf("S6O4HC00%c", sc);
  if (fg[fg_sulfuric_acid_diester-1])
    printf("S6O4CC00%c", sc);
  if (fg[fg_sulfuric_acid_amide_ester-1])
    printf("S6O3NC00%c", sc);
  if (fg[fg_sulfuric_acid_amide-1])
    printf("S6O3N100%c", sc);
  if (fg[fg_sulfuric_acid_diamide-1])
    printf("S6O2N200%c", sc);
  if (fg[fg_sulfuryl_halide-1])
    printf("S6O3XX00%c", sc);
  if (fg[fg_sulfonic_acid_deriv-1])
    printf("S5O00000%c", sc);
  if (fg[fg_sulfonic_acid-1])
    printf("S5O3H000%c", sc);
  if (fg[fg_sulfonic_acid_ester-1])
    printf("S5O3C000%c", sc);
  if (fg[fg_sulfonamide-1])
    printf("S5O2N000%c", sc);
  if (fg[fg_sulfonyl_halide-1])
    printf("S5O2XX00%c", sc);
  if (fg[fg_sulfone-1])
    printf("S4O20000%c", sc);
  if (fg[fg_sulfoxide-1])
    printf("S2O10000%c", sc);
  if (fg[fg_sulfinic_acid_deriv-1])
    printf("S3O00000%c", sc);
  if (fg[fg_sulfinic_acid-1])
    printf("S3O2H000%c", sc);
  if (fg[fg_sulfinic_acid_ester-1])
    printf("S3O2C000%c", sc);
  if (fg[fg_sulfinic_acid_halide-1])
    printf("S3O1XX00%c", sc);
  if (fg[fg_sulfinic_acid_amide-1])
    printf("S3O1N000%c", sc);
  if (fg[fg_sulfenic_acid_deriv-1])
    printf("S1O00000%c", sc);
  if (fg[fg_sulfenic_acid-1])
    printf("S1O1H000%c", sc);
  if (fg[fg_sulfenic_acid_ester-1])
    printf("S1O1C000%c", sc);
  if (fg[fg_sulfenic_acid_halide-1])
    printf("S1O0XX00%c", sc);
  if (fg[fg_sulfenic_acid_amide-1])
    printf("S1O0N100%c", sc);
  /*  if fg[fg_thiol]                          then write('S1H10000',sc);*/
  if (fg[fg_alkylthiol-1])
    printf("S1H1C000%c", sc);
  if (fg[fg_arylthiol-1])
    printf("S1H1A000%c", sc);
  if (fg[fg_phosphoric_acid_deriv-1])
    printf("P5O0H000%c", sc);
  if (fg[fg_phosphoric_acid-1])
    printf("P5O4H200%c", sc);
  if (fg[fg_phosphoric_acid_ester-1])
    printf("P5O4HC00%c", sc);
  if (fg[fg_phosphoric_acid_halide-1])
    printf("P5O3HX00%c", sc);
  if (fg[fg_phosphoric_acid_amide-1])
    printf("P5O3HN00%c", sc);
  if (fg[fg_thiophosphoric_acid_deriv-1])
    printf("P5O0S000%c", sc);
  if (fg[fg_thiophosphoric_acid-1])
    printf("P5O3SH00%c", sc);
  if (fg[fg_thiophosphoric_acid_ester-1])
    printf("P5O3SC00%c", sc);
  if (fg[fg_thiophosphoric_acid_halide-1])
    printf("P5O2SX00%c", sc);
  if (fg[fg_thiophosphoric_acid_amide-1])
    printf("P5O2SN00%c", sc);
  if (fg[fg_phosphonic_acid_deriv-1])
    printf("P4O30000%c", sc);
  if (fg[fg_phosphonic_acid-1])
    printf("P4O3H000%c", sc);
  if (fg[fg_phosphonic_acid_ester-1])
    printf("P4O3C000%c", sc);
  if (fg[fg_phosphine-1])
    printf("P3000000%c", sc);
  if (fg[fg_phosphinoxide-1])
    printf("P2O00000%c", sc);
  if (fg[fg_boronic_acid_deriv-1])
    printf("B2O20000%c", sc);
  if (fg[fg_boronic_acid-1])
    printf("B2O2H000%c", sc);
  if (fg[fg_boronic_acid_ester-1])
    printf("B2O2C000%c", sc);
  if (fg[fg_alkene-1])
    printf("000C2C00%c", sc);
  if (fg[fg_alkyne-1])
    printf("000C3C00%c", sc);
  if (fg[fg_aromatic-1])
    printf("0000A000%c", sc);
  if (fg[fg_heterocycle-1])
    printf("0000CZ00%c", sc);
  if (fg[fg_alpha_aminoacid-1])
    printf("C3O2HN1C%c", sc);
  if (fg[fg_alpha_hydroxyacid-1])
    printf("C3O2HO1H%c", sc);
}

#undef sc


Static void write_fg_binary(void)
{
  short i, n;
  Char o;

  for (i = 1; i <= max_fg / 8; i++) {
    n = 0;
    if (fg[i * 8 - 1])
      n++;
    if (fg[i * 8 - 2])
      n += 2;
    if (fg[i * 8 - 3])
      n += 4;
    if (fg[i * 8 - 4])
      n += 8;
    if (fg[i * 8 - 5])
      n += 16;
    if (fg[i * 8 - 6])
      n += 32;
    if (fg[i * 8 - 7])
      n += 64;
    if (fg[i * 8 - 8])
      n += 128;
    o = n;
    putchar(o);
  }
}


Static void write_fg_bitstring(void)
{
  short i;

  for (i = 0; i <= max_fg - 1; i++) {
    if (fg[i])
      putchar('1');
    else
      putchar('0');
  }
}


Static void readinputfile(Char *molfilename)
{
  /* new version in v0.2g*/
  Char rline[256];
  Char *TEMP;

  molbufindex = 0;
  if (!opt_stdin) {
    if (!rfile_is_open) {
      strcpy(rfile_NAME, molfilename);
      if (rfile != NULL)
	rfile = freopen(rfile_NAME, "r", rfile);
      else
	rfile = fopen(rfile_NAME, "r");
      if (rfile == NULL)
	_EscIO2(FileNotFound, rfile_NAME);
      rfile_is_open = true;
    }
    *rline = '\0';
    mol_in_queue = false;
    while (!P_eof(rfile) && strpos2(rline, "$$$$", 1) == 0) {
      fgets(rline, 256, rfile);
      TEMP = strchr(rline, '\n');
      if (TEMP != NULL)
	*TEMP = 0;
      /*mol_in_queue := false;*/
      if (molbufindex >= max_atoms + max_bonds + 64) {
	printf("Not enough memory for molfile! %d\n", molbufindex);
	if (rfile != NULL)
	  fclose(rfile);
	rfile = NULL;
	_Escape(1);
      }
      molbufindex++;
      strcpy(molbuf[molbufindex-1], rline);
      if (strpos2(rline, "$$$$", 1) > 0)
	mol_in_queue = true;
    }
    if (!P_eof(rfile))
      return;
    if (rfile != NULL)
      fclose(rfile);
    rfile = NULL;
    rfile_is_open = false;
    mol_in_queue = false;
    return;
  }
  *rline = '\0';
  mol_in_queue = false;
  while (!P_eof(stdin) && strpos2(rline, "$$$$", 1) == 0) {
    gets(rline);
    if (molbufindex >= max_atoms + max_bonds + 64) {
      printf("Not enough memory!\n");
      _Escape(1);
    }
    molbufindex++;
    strcpy(molbuf[molbufindex-1], rline);
    if (strpos2(rline, "$$$$", 1) > 0) {
      mol_in_queue = true;
      /* read from standard input*/
    }
  }
}


Static void copy_mol_to_needle(void)
{
  short i, j, FORLIM;

  if (n_atoms == 0)
    return;
  ndl_atom = Malloc(n_atoms * sizeof(atom_rec));
  ndl_bond = Malloc(n_bonds * sizeof(bond_rec));
  ndl_ring = Malloc(sizeof(ringlist));
  ndl_ringprop = Malloc(sizeof(ringprop_type));
  ndl_n_atoms = n_atoms;
  ndl_n_bonds = n_bonds;
  ndl_n_rings = n_rings;
  ndl_n_heavyatoms = n_heavyatoms;
  ndl_n_heavybonds = n_heavybonds;
  strcpy(ndl_molname, molname);
  ndl_n_Ctot = n_Ctot;
  ndl_n_Otot = n_Otot;
  ndl_n_Ntot = n_Ntot;
  FORLIM = n_atoms;
  for (i = 0; i <= FORLIM - 1; i++) {
    strcpy(ndl_atom[i].element, atom[i].element);
    strcpy(ndl_atom[i].atype, atom[i].atype);
    ndl_atom[i].x = atom[i].x;
    ndl_atom[i].y = atom[i].y;
    ndl_atom[i].z = atom[i].z;
    ndl_atom[i].formal_charge = atom[i].formal_charge;
    ndl_atom[i].real_charge = atom[i].real_charge;
    ndl_atom[i].Hexp = atom[i].Hexp;
    ndl_atom[i].Htot = atom[i].Htot;
    ndl_atom[i].neighbor_count = atom[i].neighbor_count;
    ndl_atom[i].ring_count = atom[i].ring_count;
    ndl_atom[i].arom = atom[i].arom;
    ndl_atom[i].stereo_care = atom[i].stereo_care;
    ndl_atom[i].heavy = atom[i].heavy;   /* v0.3l*/
    ndl_atom[i].metal = atom[i].metal;   /* v0.3l*/
  }
  if (n_bonds > 0) {
    FORLIM = n_bonds;
    for (i = 0; i <= FORLIM - 1; i++) {
      ndl_bond[i].a1 = bond[i].a1;
      ndl_bond[i].a2 = bond[i].a2;
      ndl_bond[i].btype = bond[i].btype;
      ndl_bond[i].arom = bond[i].arom;
      ndl_bond[i].ring_count = bond[i].ring_count;   /* new in v0.3d*/
      ndl_bond[i].topo = bond[i].topo;   /* new in v0.3d*/
      ndl_bond[i].stereo = bond[i].stereo;   /* new in v0.3d*/
    }
  }
  if (n_rings > 0) {
    FORLIM = n_rings;
    for (i = 0; i <= FORLIM - 1; i++) {
      for (j = 0; j <= max_ringsize - 1; j++)
	ndl_ring[i][j] = ring[i][j];
    }
    for (i = 0; i <= max_rings - 1; i++) {   /* new in v0.3*/
      ndl_ringprop[i].size = ringprop[i].size;
      ndl_ringprop[i].arom = ringprop[i].arom;
      ndl_ringprop[i].envelope = ringprop[i].envelope;
    }
  }
  ndl_molstat.n_QA = molstat.n_QA;
  ndl_molstat.n_QB = molstat.n_QB;
  ndl_molstat.n_chg = molstat.n_chg;
  ndl_molstat.n_C1 = molstat.n_C1;
  ndl_molstat.n_C2 = molstat.n_C2;
  ndl_molstat.n_C = molstat.n_C;
  ndl_molstat.n_CHB1p = molstat.n_CHB1p;
  ndl_molstat.n_CHB2p = molstat.n_CHB2p;
  ndl_molstat.n_CHB3p = molstat.n_CHB3p;
  ndl_molstat.n_CHB4 = molstat.n_CHB4;
  ndl_molstat.n_O2 = molstat.n_O2;
  ndl_molstat.n_O3 = molstat.n_O3;
  ndl_molstat.n_N1 = molstat.n_N1;
  ndl_molstat.n_N2 = molstat.n_N2;
  ndl_molstat.n_N3 = molstat.n_N3;
  ndl_molstat.n_S = molstat.n_S;
  ndl_molstat.n_SeTe = molstat.n_SeTe;
  ndl_molstat.n_F = molstat.n_F;
  ndl_molstat.n_Cl = molstat.n_Cl;
  ndl_molstat.n_Br = molstat.n_Br;
  ndl_molstat.n_I = molstat.n_I;
  ndl_molstat.n_P = molstat.n_P;
  ndl_molstat.n_B = molstat.n_B;
  ndl_molstat.n_Met = molstat.n_Met;
  ndl_molstat.n_X = molstat.n_X;
  ndl_molstat.n_b1 = molstat.n_b1;
  ndl_molstat.n_b2 = molstat.n_b2;
  ndl_molstat.n_b3 = molstat.n_b3;
  ndl_molstat.n_bar = molstat.n_bar;
  ndl_molstat.n_C1O = molstat.n_C1O;
  ndl_molstat.n_C2O = molstat.n_C2O;
  ndl_molstat.n_CN = molstat.n_CN;
  ndl_molstat.n_XY = molstat.n_XY;
  ndl_molstat.n_r3 = molstat.n_r3;
  ndl_molstat.n_r4 = molstat.n_r4;
  ndl_molstat.n_r5 = molstat.n_r5;
  ndl_molstat.n_r6 = molstat.n_r6;
  ndl_molstat.n_r7 = molstat.n_r7;
  ndl_molstat.n_r8 = molstat.n_r8;
  ndl_molstat.n_r9 = molstat.n_r9;
  ndl_molstat.n_r10 = molstat.n_r10;
  ndl_molstat.n_r11 = molstat.n_r11;
  ndl_molstat.n_r12 = molstat.n_r12;
  ndl_molstat.n_r13p = molstat.n_r13p;
  ndl_molstat.n_rN = molstat.n_rN;
  ndl_molstat.n_rN1 = molstat.n_rN1;
  ndl_molstat.n_rN2 = molstat.n_rN2;
  ndl_molstat.n_rN3p = molstat.n_rN3p;
  ndl_molstat.n_rO = molstat.n_rO;
  ndl_molstat.n_rO1 = molstat.n_rO1;
  ndl_molstat.n_rO2p = molstat.n_rO2p;
  ndl_molstat.n_rS = molstat.n_rS;
  ndl_molstat.n_rX = molstat.n_rX;
  ndl_molstat.n_rAr = molstat.n_rAr;
  ndl_molstat.n_rBz = molstat.n_rBz;   /* v0.3l*/
  /* make sure some modes can be switched on only by the query file*/
  /* and not by subsequent haystack file(s)*/
  if (ez_flag)   /* new in v0.3f*/
    ez_search = true;
  if (chir_flag)   /* new in v0.3f*/
    rs_search = true;
}


/* an alternative version (slightly slower with fpc 1.0.11 on Linux):*/
/*
procedure copy_mol_to_needle;
begin
  if (n_atoms = 0) then exit;
  try
    getmem(ndl_atom,n_atoms*sizeof(atom_rec));
    getmem(ndl_bond,n_bonds*sizeof(bond_rec));
    getmem(ndl_ring,sizeof(ringlist));
    getmem(ndl_ringprop,sizeof(ringprop_type));
  except
    on e:Eoutofmemory do
      begin
        writeln('Not enough memory');
        halt(4);
      end;
  end;
  ndl_n_atoms := n_atoms;
  ndl_n_bonds := n_bonds;
  ndl_n_rings := n_rings;
  ndl_n_heavyatoms := n_heavyatoms;
  ndl_n_heavybonds := n_heavybonds;
  ndl_molname := molname;
  ndl_n_Ctot := n_Ctot;
  ndl_n_Otot := n_Otot;
  ndl_n_Ntot := n_Ntot;
  move(atom^,ndl_atom^,n_atoms*sizeof(atom_rec));
  if (n_bonds > 0) then move(bond^,ndl_bond^,n_bonds*sizeof(bond_rec));
  if (n_rings > 0) then
    begin
      move(ring^,ndl_ring^,sizeof(ringlist));
      move(ringprop^,ndl_ringprop^,sizeof(ringprop_type));
    end;
  move(molstat,ndl_molstat,sizeof(molstat_rec));
  { make sure some modes can be switched on only by the query file}
  { and not by subsequent haystack file(s)}
  if ez_flag   then ez_search := true;    { new in v0.3f}
  if chir_flag then rs_search := true;    { new in v0.3f}
end;
*/

Static void get_ringstat(short r_id)
{
  short i, j;
  ringpath_type testring;
  short ring_size, a_ref;
  str2 elem;
  short nN = 0, nO = 0, nS = 0, nX = 0;

  if (r_id < 1 || r_id > n_rings)
    return;
  memset(testring, 0, sizeof(ringpath_type));
  ring_size = ringprop[r_id-1].size;   /* v0.3j*/
  for (j = 0; j <= ring_size - 1; j++)   /* v0.3j*/
    testring[j] = ring[r_id-1][j];
  if (ring_size <= 2)
    return;
  for (i = 0; i <= ring_size - 1; i++) {
    a_ref = testring[i];
    strcpy(elem, atom[a_ref-1].element);
    if (strcmp(elem, "C ") && strcmp(elem, "A ")) {
      nX++;   /* general heteroatom count*/
      if (!strcmp(elem, "N "))
	nN++;
      if (!strcmp(elem, "O "))
	nO++;
      if (!strcmp(elem, "S "))
	nS++;
    }
  }
  if (nN > 0) {
    molstat.n_rN++;
    if (nN == 1)
      molstat.n_rN1++;
    if (nN == 2)
      molstat.n_rN2++;
    if (nN > 2)
      molstat.n_rN3p++;
  }
  if (nO > 0) {
    molstat.n_rO++;
    if (nO == 1)
      molstat.n_rO1++;
    if (nO == 2)
      molstat.n_rO2p++;
  }
  if (nS > 0)
    molstat.n_rS++;
  if (nX > 0)
    molstat.n_rX++;
}


Static void get_molstat(void)
{
  short i;
  str2 elem;
  str3 atype;
  short a1, a2;
  str2 a1el, a2el;
  Char btype;
  short hbc, n_b2formal;   /* new in v0.2e*/
  short FORLIM;

  if (n_atoms == 0)
    return;
  FORLIM = n_atoms;
  for (i = 1; i <= FORLIM; i++) {
    if (atom[i-1].heavy) {
      strcpy(elem, atom[i-1].element);
      strcpy(atype, atom[i-1].atype);
      if (!strcmp(atype, "C1 "))
	molstat.n_C1++;
      if (!strcmp(atype, "C2 ") || !strcmp(atype, "CAR"))
	molstat.n_C2++;
      if (!strcmp(elem, "C "))
	molstat.n_C++;
      if (!strcmp(atype, "O2 "))
	molstat.n_O2++;
      if (!strcmp(atype, "O3 "))
	molstat.n_O3++;
      if (!strcmp(atype, "N1 "))
	molstat.n_N1++;
      if (!strcmp(atype, "N2 ") || !strcmp(atype, "NAR"))
	molstat.n_N2++;
      if (!strcmp(atype, "N3 ") || !strcmp(atype, "NPL") ||
	  !strcmp(atype, "N3+") || !strcmp(atype, "NAM"))
	molstat.n_N3++;
      if (!strcmp(elem, "A "))   /* query atom*/
	molstat.n_QA++;
      if (!strcmp(elem, "Q "))   /* query atom*/
	molstat.n_QA++;
      if (!strcmp(elem, "S "))
	molstat.n_S++;
      if (!strcmp(elem, "SE"))
	molstat.n_SeTe++;
      if (!strcmp(elem, "TE"))
	molstat.n_SeTe++;
      if (!strcmp(elem, "F "))
	molstat.n_F++;
      if (!strcmp(elem, "CL"))
	molstat.n_Cl++;
      if (!strcmp(elem, "BR"))
	molstat.n_Br++;
      if (!strcmp(elem, "I "))
	molstat.n_I++;
      if (!strcmp(elem, "P "))
	molstat.n_P++;
      if (!strcmp(elem, "B "))
	molstat.n_B++;
      /* check for known metals*/
      if (atom[i-1].metal)   /* v0.3l*/
	molstat.n_Met++;
      /* still missing: unknown elements*/

      /* check number of heteroatom bonds per C atom*/
      if (!strcmp(elem, "C ")) {
	hbc = raw_hetbond_count(i);
	    /* new in v0.2j (replaces hetbond_count)*/
	if (hbc >= 1)
	  molstat.n_CHB1p++;
	if (hbc >= 2)
	  molstat.n_CHB2p++;
	if (hbc >= 3)
	  molstat.n_CHB3p++;
	if (hbc == 4)
	  molstat.n_CHB4++;
      }
      if (atom[i-1].formal_charge != 0) {
	molstat.n_chg++;
	n_charges++;
      }
      /* check for "other" elements;  v0.3l*/
      if (!atom[i-1].metal && strcmp(elem, "C ") && strcmp(elem, "N ") &&
	  strcmp(elem, "O ") && strcmp(elem, "F ") && strcmp(elem, "CL") &&
	  strcmp(elem, "BR") && strcmp(elem, "I ") && strcmp(elem, "S ") &&
	  strcmp(elem, "SE") && strcmp(elem, "TE") && strcmp(elem, "P ") &&
	  strcmp(elem, "B ") && strcmp(elem, "A ") && strcmp(elem, "Q "))
	molstat.n_X++;
    }  /* is heavy*/
  }  /* atoms*/
  if (n_bonds > 0) {
    FORLIM = n_bonds;
    for (i = 0; i <= FORLIM - 1; i++) {
      a1 = bond[i].a1;
      a2 = bond[i].a2;
      strcpy(a1el, atom[a1-1].element);
      strcpy(a2el, atom[a2-1].element);
      btype = bond[i].btype;
      if (bond[i].arom)
	molstat.n_bar++;
      else {
	if (btype == 'S')
	  molstat.n_b1++;
	if (btype == 'D')
	  molstat.n_b2++;
	if (btype == 'T')
	  molstat.n_b3++;
      }
      if (!strcmp(a1el, "C ") && !strcmp(a2el, "O ") ||
	  !strcmp(a1el, "O ") && !strcmp(a2el, "C ")) {
	if (btype == 'S')
	  molstat.n_C1O++;
	if (btype == 'D')
	  molstat.n_C2O++;
      }
      if (!strcmp(a1el, "C ") && !strcmp(a2el, "N ") ||
	  !strcmp(a1el, "N ") && !strcmp(a2el, "C "))
	molstat.n_CN++;
      if (strcmp(a1el, "C ") && atom[a1-1].heavy && strcmp(a2el, "C ") &&
	  atom[a2-1].heavy)
	molstat.n_XY++;
    }
  }  /* bonds*/
  if (n_rings <= 0) {
    return;
  }  /* rings*/
  FORLIM = n_rings;
  for (i = 1; i <= FORLIM; i++) {
    if (is_arene(i)) {
      molstat.n_rAr++;
      if (ringprop[i-1].size == 6 && is_heterocycle(i) == false)   /* v0.3l*/
	molstat.n_rBz++;
    }
    get_ringstat(i);
  }
  n_b2formal = molstat.n_rAr;
      /* new in v0.2e; adds 1 formal double bond for each aromatic ring*/
  /* in order to allow an isolated double bond in the needle*/
  /* to be matched as a ring fragment of an aromatic ring*/
  if (n_b2formal > molstat.n_bar / 2)
    n_b2formal = molstat.n_bar / 2;
  molstat.n_b2 += n_b2formal;
}


Static void write_molstat(void)
{
  printf("n_atoms:%d;", n_heavyatoms);
      /* count only non-H atoms (some molfiles contain explicit H's)*/
  if (n_bonds > 0)   /* count only bonds between non-H atoms*/
    printf("n_bonds:%d;", n_heavybonds);
  if (n_rings > 0)
    printf("n_rings:%d;", n_rings);
  /*      if n_QA    > 0 then write('n_QA:',n_QA,';');*/
  /*      if n_QB    > 0 then write('n_QB:',n_QB,';');*/
  if (molstat.n_chg > 0)
    printf("n_chg:%d;", molstat.n_chg);
  if (molstat.n_C1 > 0)
    printf("n_C1:%d;", molstat.n_C1);
  if (molstat.n_C2 > 0)
    printf("n_C2:%d;", molstat.n_C2);
  /* requirement of a given number of sp3 carbons might be too restrictive,*/
  /* so we use the total number of carbons instead  (initially used variable n_C3 is now n_C)*/
  if (molstat.n_C > 0)
    printf("n_C:%d;", molstat.n_C);
  if (molstat.n_CHB1p > 0)
    printf("n_CHB1p:%d;", molstat.n_CHB1p);
  if (molstat.n_CHB2p > 0)
    printf("n_CHB2p:%d;", molstat.n_CHB2p);
  if (molstat.n_CHB3p > 0)
    printf("n_CHB3p:%d;", molstat.n_CHB3p);
  if (molstat.n_CHB4 > 0)
    printf("n_CHB4:%d;", molstat.n_CHB4);
  if (molstat.n_O2 > 0)
    printf("n_O2:%d;", molstat.n_O2);
  if (molstat.n_O3 > 0)
    printf("n_O3:%d;", molstat.n_O3);
  if (molstat.n_N1 > 0)
    printf("n_N1:%d;", molstat.n_N1);
  if (molstat.n_N2 > 0)
    printf("n_N2:%d;", molstat.n_N2);
  if (molstat.n_N3 > 0)
    printf("n_N3:%d;", molstat.n_N3);
  if (molstat.n_S > 0)
    printf("n_S:%d;", molstat.n_S);
  if (molstat.n_SeTe > 0)
    printf("n_SeTe:%d;", molstat.n_SeTe);
  if (molstat.n_F > 0)
    printf("n_F:%d;", molstat.n_F);
  if (molstat.n_Cl > 0)
    printf("n_Cl:%d;", molstat.n_Cl);
  if (molstat.n_Br > 0)
    printf("n_Br:%d;", molstat.n_Br);
  if (molstat.n_I > 0)
    printf("n_I:%d;", molstat.n_I);
  if (molstat.n_P > 0)
    printf("n_P:%d;", molstat.n_P);
  if (molstat.n_B > 0)
    printf("n_B:%d;", molstat.n_B);
  if (molstat.n_Met > 0)
    printf("n_Met:%d;", molstat.n_Met);
  if (molstat.n_X > 0)
    printf("n_X:%d;", molstat.n_X);
  if (molstat.n_b1 > 0)
    printf("n_b1:%d;", molstat.n_b1);
  if (molstat.n_b2 > 0)
    printf("n_b2:%d;", molstat.n_b2);
  if (molstat.n_b3 > 0)
    printf("n_b3:%d;", molstat.n_b3);
  if (molstat.n_bar > 0)
    printf("n_bar:%d;", molstat.n_bar);
  if (molstat.n_C1O > 0)
    printf("n_C1O:%d;", molstat.n_C1O);
  if (molstat.n_C2O > 0)
    printf("n_C2O:%d;", molstat.n_C2O);
  if (molstat.n_CN > 0)
    printf("n_CN:%d;", molstat.n_CN);
  if (molstat.n_XY > 0)
    printf("n_XY:%d;", molstat.n_XY);
  if (molstat.n_r3 > 0)
    printf("n_r3:%d;", molstat.n_r3);
  if (molstat.n_r4 > 0)
    printf("n_r4:%d;", molstat.n_r4);
  if (molstat.n_r5 > 0)
    printf("n_r5:%d;", molstat.n_r5);
  if (molstat.n_r6 > 0)
    printf("n_r6:%d;", molstat.n_r6);
  if (molstat.n_r7 > 0)
    printf("n_r7:%d;", molstat.n_r7);
  if (molstat.n_r8 > 0)
    printf("n_r8:%d;", molstat.n_r8);
  if (molstat.n_r9 > 0)
    printf("n_r9:%d;", molstat.n_r9);
  if (molstat.n_r10 > 0)
    printf("n_r10:%d;", molstat.n_r10);
  if (molstat.n_r11 > 0)
    printf("n_r11:%d;", molstat.n_r11);
  if (molstat.n_r12 > 0)
    printf("n_r12:%d;", molstat.n_r12);
  if (molstat.n_r13p > 0)
    printf("n_r13p:%d;", molstat.n_r13p);
  if (molstat.n_rN > 0)
    printf("n_rN:%d;", molstat.n_rN);
  if (molstat.n_rN1 > 0)
    printf("n_rN1:%d;", molstat.n_rN1);
  if (molstat.n_rN2 > 0)
    printf("n_rN2:%d;", molstat.n_rN2);
  if (molstat.n_rN3p > 0)
    printf("n_rN3p:%d;", molstat.n_rN3p);
  if (molstat.n_rO > 0)
    printf("n_rO:%d;", molstat.n_rO);
  if (molstat.n_rO1 > 0)
    printf("n_rO1:%d;", molstat.n_rO1);
  if (molstat.n_rO2p > 0)
    printf("n_rO2p:%d;", molstat.n_rO2p);
  if (molstat.n_rS > 0)
    printf("n_rS:%d;", molstat.n_rS);
  if (molstat.n_rX > 0)
    printf("n_rX:%d;", molstat.n_rX);
  if (molstat.n_rAr > 0)
    printf("n_rar:%d;", molstat.n_rAr);
  if (molstat.n_rBz > 0)
    printf("n_rbz:%d;", molstat.n_rBz);
  putchar('\n');
}


Static void write_molstat_X(void)
{
  printf("%d,", n_heavyatoms);
  printf("%d,", n_heavybonds);
  printf("%d,", n_rings);
  printf("%d,", molstat.n_QA);
  printf("%d,", molstat.n_QB);
  printf("%d,", molstat.n_chg);
  printf("%d,", molstat.n_C1);
  printf("%d,", molstat.n_C2);
  printf("%d,", molstat.n_C);
  printf("%d,", molstat.n_CHB1p);
  printf("%d,", molstat.n_CHB2p);
  printf("%d,", molstat.n_CHB3p);
  printf("%d,", molstat.n_CHB4);
  printf("%d,", molstat.n_O2);
  printf("%d,", molstat.n_O3);
  printf("%d,", molstat.n_N1);
  printf("%d,", molstat.n_N2);
  printf("%d,", molstat.n_N3);
  printf("%d,", molstat.n_S);
  printf("%d,", molstat.n_SeTe);
  printf("%d,", molstat.n_F);
  printf("%d,", molstat.n_Cl);
  printf("%d,", molstat.n_Br);
  printf("%d,", molstat.n_I);
  printf("%d,", molstat.n_P);
  printf("%d,", molstat.n_B);
  printf("%d,", molstat.n_Met);
  printf("%d,", molstat.n_X);
  printf("%d,", molstat.n_b1);
  printf("%d,", molstat.n_b2);
  printf("%d,", molstat.n_b3);
  printf("%d,", molstat.n_bar);
  printf("%d,", molstat.n_C1O);
  printf("%d,", molstat.n_C2O);
  printf("%d,", molstat.n_CN);
  printf("%d,", molstat.n_XY);
  printf("%d,", molstat.n_r3);
  printf("%d,", molstat.n_r4);
  printf("%d,", molstat.n_r5);
  printf("%d,", molstat.n_r6);
  printf("%d,", molstat.n_r7);
  printf("%d,", molstat.n_r8);
  printf("%d,", molstat.n_r9);
  printf("%d,", molstat.n_r10);
  printf("%d,", molstat.n_r11);
  printf("%d,", molstat.n_r12);
  printf("%d,", molstat.n_r13p);
  printf("%d,", molstat.n_rN);
  printf("%d,", molstat.n_rN1);
  printf("%d,", molstat.n_rN2);
  printf("%d,", molstat.n_rN3p);
  printf("%d,", molstat.n_rO);
  printf("%d,", molstat.n_rO1);
  printf("%d,", molstat.n_rO2p);
  printf("%d,", molstat.n_rS);
  printf("%d,", molstat.n_rX);
  printf("%d", molstat.n_rAr);
  printf(",%d\n", molstat.n_rBz);
}


/* routines for substructure matching*/


Static short find_ndl_ref_atom(void)
{
  short Result, i;
  short score = -1, index = 0;
  short n_nb, n_hc, FORLIM;

  /* finds a characteristic atom in the needle molecule,*/
  /* i.e., one with as many substituents as possible and*/
  /* with as many heteroatom substitutents as possible;*/
  /* added in v0.2d: make sure that reference atom is a heavy atom*/
  /* and not (accidentally) an explicit hydrogen;*/
  /* new in v0.3d: special treatment in case of E/Z geometry search*/
  /* to ensure that the entire A-B=C-D fragment is enclosed in one*/
  /* matchpath, regardless where the recursive search starts;*/
  /* refined in v0.3f: exclude only alkene-C as reference atoms*/
  if (ndl_n_atoms == 0)
    return Result;
  if (ez_search && ndl_n_heavyatoms > 2) {
    FORLIM = ndl_n_atoms;
    for (i = 1; i <= FORLIM; i++) {  /* ignore sp2-carbons if not aromatic*/
      /*if ((ndl_atom^[i].atype <> 'C2 ') or (ndl_atom^[i].arom = true)) then*/
      if (ndl_alkene_C(i) == false) {
	n_nb = ndl_atom[i-1].neighbor_count;
	n_hc = ndl_hetatom_count(i);
	if (n_nb * 11 + n_hc * 7 > score && ndl_atom[i-1].heavy) {
	      /* v0.3j*/
		index = i;
	  score = n_nb * 11 + n_hc * 7;   /* changed in v0.3j*/
	}
      }
    }
  }
  /* it is possible that no suitable reference atom has been found here*/
  /* (e.g., with "pure" polyenes), so we need a fallback option anyway*/
  if (index == 0) {
    ez_search = false;   /* just in case it was true*/
    opt_geom = false;   /* just in case it was true*/
    FORLIM = ndl_n_atoms;
    for (i = 1; i <= FORLIM; i++) {
      n_nb = ndl_atom[i-1].neighbor_count;
      n_hc = ndl_hetatom_count(i);
      if (n_nb * 11 + n_hc * 7 > score && ndl_atom[i-1].heavy) {   /* v0.3j*/
	index = i;
	score = n_nb * 11 + n_hc * 7;   /* changed in v0.3j*/
      }
    }
  }
  /* now index must be > 0 in any case (except for H2)*/
  if (index == 0)   /* just to be sure...*/
    index++;
  return index;
}


Static void cv_init(void)
{
  short i, FORLIM;

  if (cv == NULL)
    return;
  memset(cv, 0, sizeof(connval_type));
  FORLIM = ndl_n_atoms;
  for (i = 0; i <= FORLIM - 1; i++)
    cv[i].def = ndl_atom[i].neighbor_count;
}


Static void cv_iterate(void)
{
  short i, j;
  neighbor_rec nb;
  short nnb, nsum, FORLIM;

  if (cv == NULL || ndl_n_atoms == 0)
    return;
  FORLIM = ndl_n_atoms;
  /* update the connection values (Morgan algorithm)*/
  for (i = 1; i <= FORLIM; i++) {
    get_ndl_neighbors(nb, i);
    nnb = ndl_atom[i-1].neighbor_count;
    nsum = nnb;
    if (nnb > 0) {
      for (j = 0; j <= nnb - 1; j++)
	nsum += cv[nb[j] - 1].def;
    }
    cv[i-1].tmp = nsum;
  }
  FORLIM = ndl_n_atoms;
  for (i = 0; i <= FORLIM - 1; i++)
    cv[i].def = cv[i].tmp;
}


Static short cv_count(void)
{
  short i, j;
  short res = 1;
  short cvlist[max_atoms];
  short cvdef;
  boolean isnew;
  short entries = 0;
  short FORLIM;

  if (cv == NULL)
    return 0;
  memset(cvlist, 0, sizeof(short) * sizeof(short) * 512);
  FORLIM = ndl_n_atoms;
  for (i = 0; i <= FORLIM - 1; i++) {
    cvdef = cv[i].def;
    isnew = true;
    if (entries > 0) {
      for (j = 0; j <= entries - 1; j++) {
	if (cvlist[j] == cvdef)
	  isnew = false;
      }
    }
    if (isnew) {
      entries++;
      cvlist[entries-1] = cvdef;
    }
    /* now we have a list of unique connection values*/
  }
  res = entries;
  return res;
}


Static short find_ndl_ref_atom_cv(void)
{
  /* new in v0.3j*/
  short Result, i;
  short res = 1, it = 0;
  short n_cv;
  short n_cv_prev = 0;
  boolean finished = false;
  short extraloops = 0, cvmax = 0;
  short FORLIM;

  if (ndl_n_atoms == 0)
    return 0;
  cv = Malloc(sizeof(connval_type));
  cv_init();
  do {
    it++;
    cv_iterate();
    n_cv = cv_count();
    if (n_cv == n_cv_prev)
      finished = true;
    n_cv_prev = n_cv;
    if (finished)
      extraloops++;
  } while (!(finished && extraloops == 3 || it > 10000));
  FORLIM = ndl_n_atoms;
  /* now that we have canonical connection values (Morgan algorithm),*/
  /* pick the atom with the highest value*/
  for (i = 1; i <= FORLIM; i++) {
    /*writeln('cv for atom ',i,': ',cv^[i].def);*/
    if (cv[i-1].def > cvmax &&
	(ndl_alkene_C(i) == false || ez_search == false)) {
      cvmax = cv[i-1].def;
      res = i;
    }
  }
  Result = res;
  if (cv != NULL) {
    Free(cv);
    cv = NULL;
  }
  return Result;
}


Static boolean atomtypes_OK_strict(short ndl_a, short hst_a)
{
  /* new in v0.2f*/
  str2 ndl_el;
  str3 ndl_atype;
  str2 hst_el;
  str3 hst_atype;
  short ndl_nbc, hst_nbc, ndl_Hexp, hst_Htot;
  boolean res = false;

  strcpy(ndl_el, ndl_atom[ndl_a-1].element);
  strcpy(ndl_atype, ndl_atom[ndl_a-1].atype);
  ndl_nbc = ndl_atom[ndl_a-1].neighbor_count;
  ndl_Hexp = ndl_atom[ndl_a-1].Hexp;
  strcpy(hst_el, atom[hst_a-1].element);
  strcpy(hst_atype, atom[hst_a-1].atype);
  hst_nbc = atom[hst_a-1].neighbor_count;
  hst_Htot = atom[hst_a-1].Htot;
  if (!strcmp(ndl_atype, hst_atype))
    res = true;
  else {
    if (!strcmp(ndl_el, hst_el) && ndl_atom[ndl_a-1].arom &&
	atom[hst_a-1].arom)
      res = true;
  }
  if (!strcmp(ndl_el, "A ") && atom[hst_a-1].heavy)
    res = true;
  if (!strcmp(ndl_el, "Q ")) {
    if (atom[hst_a-1].heavy && strcmp(hst_el, "C "))
      res = true;
  }
  if (!strcmp(ndl_el, "X ")) {
    if (!strcmp(hst_el, "F ") || !strcmp(hst_el, "CL") ||
	!strcmp(hst_el, "BR") || !strcmp(hst_el, "I "))
      res = true;
  }
  /* if needle atom has more substituents than haystack atom ==> no match*/
  if (ndl_nbc > hst_nbc)
    res = false;
  /* check for explicit hydrogens*/
  if (ndl_Hexp > hst_Htot)
    res = false;
  /*{$IFDEF debug
  if res then debugoutput('atom types OK ('+inttostr(ndl_a)+'/'+inttostr(hst_a)+')')
      else debugoutput('atom types not OK ('+inttostr(ndl_a)+':'+ndl_atype+'/'+inttostr(hst_a)+':'+hst_atype+')');
  $ENDIF*/
  return res;
}


Static boolean atomtypes_OK(short ndl_a, short hst_a)
{
  str2 ndl_el, hst_el;
  short ndl_nbc, hst_nbc, ndl_Hexp, hst_Htot;
  boolean res = false;

  if (ndl_a < 1 || ndl_a > ndl_n_atoms || hst_a < 1 || hst_a > n_atoms)
    return false;
  /* check for opposite charges;  v0.3l*/
  if (ndl_atom[ndl_a-1].formal_charge * atom[hst_a-1].formal_charge < 0)
    return false;
  if (opt_strict)   /* new in v0.2f*/
    return (atomtypes_OK_strict(ndl_a, hst_a));
  strcpy(ndl_el, ndl_atom[ndl_a-1].element);
  ndl_nbc = ndl_atom[ndl_a-1].neighbor_count;
  ndl_Hexp = ndl_atom[ndl_a-1].Hexp;
  strcpy(hst_el, atom[hst_a-1].element);
  hst_nbc = atom[hst_a-1].neighbor_count;
  hst_Htot = atom[hst_a-1].Htot;
  if (!strcmp(ndl_el, hst_el))   /* very simplified...*/
    res = true;
  if (!strcmp(ndl_el, "A ") && atom[hst_a-1].heavy)
    res = true;
  if (!strcmp(ndl_el, "Q ")) {
    if (atom[hst_a-1].heavy && strcmp(hst_el, "C "))
      res = true;
  }
  if (!strcmp(ndl_el, "X ")) {
    if (!strcmp(hst_el, "F ") || !strcmp(hst_el, "CL") ||
	!strcmp(hst_el, "BR") || !strcmp(hst_el, "I "))
      res = true;
  }
  /* if needle atom has more substituents than haystack atom ==> no match*/
  if (ndl_nbc > hst_nbc)
    res = false;
  /* check for explicit hydrogens*/
  if (ndl_Hexp > hst_Htot)
    res = false;
  /*{$IFDEF debug
  if res then debugoutput('atom types OK ('+inttostr(ndl_a)+'/'+inttostr(hst_a)+')')
      else debugoutput('atom types not OK ('+inttostr(ndl_a)+'/'+inttostr(hst_a)+')');
  $ENDIF*/
  return res;
}


Static boolean bondtypes_OK_strict(short ndl_b, short hst_b)
{
  boolean ndl_arom, hst_arom;
  Char ndl_btype, hst_btype;
  short ndl_rc;   /* new in v0.3d*/
  short hst_rc;   /* new in v0.3d*/
  schar ndl_btopo;   /* new in v0.3d*/
  boolean res = false;

  /*{$IFDEF debug
  na, ha    : string;
  tstr : string;
  $ENDIF*/
  /*{$IFDEF debug
  tstr      := '';  (* for debugging purposes only *)
  $ENDIF*/
  ndl_arom = ndl_bond[ndl_b-1].arom;
  ndl_btype = ndl_bond[ndl_b-1].btype;
  ndl_rc = ndl_bond[ndl_b-1].ring_count;
  ndl_btopo = ndl_bond[ndl_b-1].topo;
  hst_arom = bond[hst_b-1].arom;
  hst_btype = bond[hst_b-1].btype;
  hst_rc = bond[hst_b-1].ring_count;
  /*{$IFDEF debug
  if ndl_arom then na := '(ar)' else na := '';
  if hst_arom then ha := '(ar)' else ha := '';
  $ENDIF*/
  if (ndl_arom == true && hst_arom == true)
    res = true;
  if (ndl_arom == false && hst_arom == false) {
    if (ndl_btype == hst_btype)
      res = true;
    if (ndl_btype == 'l' && (hst_btype == 'S' || hst_btype == 'D'))
      res = true;
    if (ndl_btype == 's' && hst_btype == 'S')
      res = true;
    if (ndl_btype == 'd' && hst_btype == 'D')
      res = true;
  }
  /* a little exception:*/
  if (ndl_arom == false && hst_arom == true) {
    if (ndl_btype == 'A')
      res = true;
    if (ndl_btype == 's' || ndl_btype == 'd')
      res = true;
  }
  if (ndl_btype == 'a')
    res = true;
  /* new in v0.3d: strict comparison of topology (and even ring_count!)*/
  if (ndl_btopo < btopo_always_any || ndl_btopo == btopo_exact_rc) {
    if (ndl_rc != hst_rc) {
      res = false;   /* this excludes further ring annulations as well as*/
      /*{$IFDEF debug                    open-chains query structures to be found in rings
      tstr := ' ringcount mismatch';
      $ENDIF*/
    }
  } else {
    if (ndl_btopo == btopo_excess_rc && hst_rc <= ndl_rc) {
      res = false;
      /*{$IFDEF debug
      tstr := ' ringcount mismatch';
      {$ENDIF*/
    }
  }
  /*{$IFDEF debug
  if res then debugoutput('bond types OK ('+inttostr(ndl_b)+':'+ndl_btype+na+'/'+inttostr(hst_b)+':'+hst_btype+ha+')') else
    debugoutput('bond types not OK ('+inttostr(ndl_b)+':'+ndl_btype+na+'/'+inttostr(hst_b)+':'+hst_btype+ha+tstr+')');
  {$ENDIF*/
  return res;
}


Static boolean bondtypes_OK(short ndl_b, short hst_b)
{
  boolean ndl_arom, hst_arom;
  Char ndl_btype, hst_btype;
  short ndl_rc;   /* new in v0.3d*/
  short hst_rc;   /* new in v0.3d*/
  schar ndl_btopo;   /* new in v0.3d*/
  boolean res = false;
  /*{$IFDEF debug
  na, ha : string;
  tstr : string;
  {$ENDIF*/
  short a1, a2;
  str2 a1_el, a2_el;

  if (ndl_b < 1 || ndl_b > ndl_n_bonds || hst_b < 1 || hst_b > n_bonds)
    return false;
  if (opt_strict)   /* new in v0.2f*/
    return (bondtypes_OK_strict(ndl_b, hst_b));
  /*{$IFDEF debug
  tstr := '';  (* for debug purposes only *)
  {$ENDIF*/
  ndl_arom = ndl_bond[ndl_b-1].arom;
  ndl_btype = ndl_bond[ndl_b-1].btype;
  hst_arom = bond[hst_b-1].arom;
  hst_btype = bond[hst_b-1].btype;
  ndl_rc = ndl_bond[ndl_b-1].ring_count;
  hst_rc = bond[hst_b-1].ring_count;
  ndl_btopo = ndl_bond[ndl_b-1].topo;
  /*{$IFDEF debug
  if ndl_arom then na := '(ar)' else na := '';
  if hst_arom then ha := '(ar)' else ha := '';
  {$ENDIF*/
  if (ndl_arom == true && hst_arom == true)
    res = true;
  if (ndl_arom == false && hst_arom == false) {
    if (ndl_btype == hst_btype)
      res = true;
    if (ndl_btype == 'l' && (hst_btype == 'S' || hst_btype == 'D'))
      res = true;
    if (ndl_btype == 's' && hst_btype == 'S')
      res = true;
    if (ndl_btype == 'd' && hst_btype == 'D')
      res = true;
  }
  /* a little exception:*/
  if (ndl_arom == false && hst_arom == true) {
    if (ndl_btype == 'A')
      res = true;
    if (ndl_btype == 's' || ndl_btype == 'd')
      res = true;
    if (ndl_btype == 'D')
    {   /* added in 0.2d: do not accept C=O etc. as C-O/arom*/
      a1 = ndl_bond[ndl_b-1].a1;
      a2 = ndl_bond[ndl_b-1].a2;
      strcpy(a1_el, ndl_atom[a1-1].element);
      strcpy(a2_el, ndl_atom[a2-1].element);
      if (strcmp(a1_el, "O ") && strcmp(a2_el, "O ") && strcmp(a1_el, "S ") &&
	  strcmp(a2_el, "S ") && strcmp(a1_el, "SE") && strcmp(a2_el, "SE") &&
	  strcmp(a1_el, "TE") && strcmp(a2_el, "TE"))
	res = true;
    }
  }
  if (ndl_btype == 'a')
    res = true;
  /* new in v0.3d: obey topology requirements in query structure*/
  if (ndl_btopo == btopo_any || ndl_btopo == btopo_always_any)
    return res;
  if (ndl_btopo == btopo_ring && hst_rc == 0)
    res = false;
  if (ndl_btopo == btopo_chain && hst_rc > 0)
    res = false;
  if (ndl_btopo == btopo_excess_rc && hst_rc <= ndl_rc)
    res = false;
  if (ndl_btopo == btopo_exact_rc && hst_rc != ndl_rc)
    res = false;
  /*{$IFDEF debug
  if res = false then tstr := ' bond topology mismatch';
  {$ENDIF*/
  /*{$IFDEF debug
  if res then debugoutput('bond types OK ('+inttostr(ndl_b)+':'+ndl_btype+na+'/'+inttostr(hst_b)+':'+hst_btype+ha+')') else
    debugoutput('bond types not OK ('+inttostr(ndl_b)+':'+ndl_btype+na+'/'+inttostr(hst_b)+':'+hst_btype+ha+tstr+')');
  {$ENDIF*/
  return res;
}


Static boolean matrix_OK(boolean (*m)[max_neighbors], short ndl_dim,
			 short hst_dim)
{
  /* new, recursive version in v0.2i: can handle up to max_neighbors substituents*/
  boolean mr = false;
  matchmatrix lm;
  short i, ii, j, lndl_dim, lhst_dim;

  if (ndl_dim < 1 || ndl_dim > max_neighbors || hst_dim < 1 ||
      hst_dim > max_neighbors || ndl_dim > hst_dim)
    return false;
  if (ndl_dim == 1) {
    for (i = 0; i <= hst_dim - 1; i++) {
      if (m[0][i])
	mr = true;
    }
    return mr;
  }
  for (i = 1; i <= hst_dim; i++) {
    if (m[0][i-1]) {
	  /* write remaining fields into a new matchmatrix which is smaller by 1x1*/
	    memset(lm, false, sizeof(matchmatrix));
      for (j = 2; j <= ndl_dim; j++) {
	lhst_dim = 0;
	for (ii = 1; ii <= hst_dim; ii++) {
	  if (ii != i) {
	    lhst_dim++;
	    lm[j-2][lhst_dim-1] = m[j-1][ii-1];
	  }
	}
      }
      lndl_dim = ndl_dim - 1;
      if (matrix_OK(lm, lndl_dim, lhst_dim)) {
	    /* recursive call to matrix_OK*/
	      return true;
	/* stop any further work immediately*/
      }
    }
  }
  return false;
}


Static boolean is_flat(double angle_deg)
{
  /* new in v0.3j*/
  if (fabs(angle_deg) > 5 && fabs(angle_deg) < 175)
    return false;
  else
    return true;
}


Static boolean chirality_OK(short *ndl_cp, short *hst_cp)
{
  boolean res = true;
  double ndl_ct, hst_ct, ndl_ct_deg, hst_ct_deg;
  p_3d np1, np2, np3, np4, hp1, hp2, hp3, hp4;
  short level = 0;
  short i;
  boolean up = false, down = false, updown = false;
  short ta1, ta2, ta3, ta4, ba1, ba2, FORLIM;

  /* fill temporary atom variables*/
  ta1 = ndl_cp[0];   /* this is the central atom*/
  ta2 = ndl_cp[1];
  ta3 = ndl_cp[2];
  ta4 = ndl_cp[3];
  /* first, get the central atom of the needle*/
  np2.x = ndl_atom[ta1-1].x;
  np2.y = ndl_atom[ta1-1].y;
  np2.z = ndl_atom[ta1-1].z;
  /* next, do the same for all 3 substituent atoms*/
  np1.x = ndl_atom[ta2-1].x;
  np1.y = ndl_atom[ta2-1].y;
  np1.z = ndl_atom[ta2-1].z;
  np3.x = ndl_atom[ta3-1].x;
  np3.y = ndl_atom[ta3-1].y;
  np3.z = ndl_atom[ta3-1].z;
  np4.x = ndl_atom[ta4-1].x;
  np4.y = ndl_atom[ta4-1].y;
  np4.z = ndl_atom[ta4-1].z;
  /* now check all needle bonds if we should care about up/down bonds*/
  if (ndl_n_bonds > 0) {
    FORLIM = ndl_n_bonds;
    for (i = 0; i <= FORLIM - 1; i++) {
      if (ndl_bond[i].stereo == bstereo_up ||
	  ndl_bond[i].stereo == bstereo_down) {
	ba1 = ndl_bond[i].a1;
	ba2 = ndl_bond[i].a2;
	if (ba1 == ta1 && ndl_bond[i].stereo == bstereo_up) {
	  up = true;
	  if (ba2 == ta2 || ba2 == ta3 || ba2 == ta4) {
	    updown = true;
	    if (ba2 == ta2)
	      np1.z += 0.8;
	    if (ba2 == ta3)
	      np3.z += 0.8;
	    if (ba2 == ta4)
	      np4.z += 0.8;
	  } else
	    level++;
	}
	if (ba1 == ta1 && ndl_bond[i].stereo == bstereo_down) {
	  down = true;
	  if (ba2 == ta2 || ba2 == ta3 || ba2 == ta4) {
	    updown = true;
	    if (ba2 == ta2)
	      np1.z -= 0.8;
	    if (ba2 == ta3)
	      np3.z -= 0.8;
	    if (ba2 == ta4)
	      np4.z -= 0.8;
	  } else
	    level--;
	}
	if (ba2 == ta1 && ndl_bond[i].stereo == bstereo_up) {
	  down = true;
	  if (ba1 == ta2 || ba1 == ta3 || ba1 == ta4) {
	    updown = true;
	    if (ba1 == ta2)
	      np1.z -= 0.8;
	    if (ba1 == ta3)
	      np3.z -= 0.8;
	    if (ba1 == ta4)
	      np4.z -= 0.8;
	  } else
	    level--;
	}
	if (ba2 == ta1 && ndl_bond[i].stereo == bstereo_down) {
	  up = true;
	  if (ba1 == ta2 || ba1 == ta3 || ba1 == ta4) {
	    updown = true;
	    if (ba1 == ta2)
	      np1.z += 0.8;
	    if (ba1 == ta3)
	      np3.z += 0.8;
	    if (ba1 == ta4)
	      np4.z += 0.8;
	  } else
	    level++;
	}
      }
    }  /* for i ...*/
    if (updown == false && level != 0) {
      if (level > 0)
	np2.z += 0.3;
      if (level < 0)
	np2.z -= 0.3;
    } else {
      if (up)
	np2.z += 0.1;
      if (down)
	np2.z -= 0.1;
    }
  }
  /* fill temporary atom variables again*/
  ta1 = hst_cp[0];
  ta2 = hst_cp[1];
  ta3 = hst_cp[2];
  ta4 = hst_cp[3];
  /* then, get the central atom of the haystack*/
  hp2.x = atom[ta1-1].x;
  hp2.y = atom[ta1-1].y;
  hp2.z = atom[ta1-1].z;
  /* next, do the same for all 3 substituent atoms*/
  hp1.x = atom[ta2-1].x;
  hp1.y = atom[ta2-1].y;
  hp1.z = atom[ta2-1].z;
  hp3.x = atom[ta3-1].x;
  hp3.y = atom[ta3-1].y;
  hp3.z = atom[ta3-1].z;
  hp4.x = atom[ta4-1].x;
  hp4.y = atom[ta4-1].y;
  hp4.z = atom[ta4-1].z;
  /* now check all haystack bonds if we should care about up/down bonds*/
  level = 0;
  updown = false;
  up = false;
  down = false;
  if (n_bonds > 0) {
    FORLIM = n_bonds;
    for (i = 0; i <= FORLIM - 1; i++) {
      if (bond[i].stereo == bstereo_up || bond[i].stereo == bstereo_down) {
	ba1 = bond[i].a1;
	ba2 = bond[i].a2;
	if (ba1 == ta1 && bond[i].stereo == bstereo_up) {
	  up = true;
	  if (ba2 == ta2 || ba2 == ta3 || ba2 == ta4) {
	    updown = true;
	    if (ba2 == ta2)
	      hp1.z += 0.8;
	    if (ba2 == ta3)
	      hp3.z += 0.8;
	    if (ba2 == ta4)
	      hp4.z += 0.8;
	  } else
	    level++;
	}
	if (ba1 == ta1 && bond[i].stereo == bstereo_down) {
	  down = true;
	  if (ba2 == ta2 || ba2 == ta3 || ba2 == ta4) {
	    updown = true;
	    if (ba2 == ta2)
	      hp1.z -= 0.8;
	    if (ba2 == ta3)
	      hp3.z -= 0.8;
	    if (ba2 == ta4)
	      hp4.z -= 0.8;
	  } else
	    level--;
	}
	if (ba2 == ta1 && bond[i].stereo == bstereo_up) {
	  down = true;
	  if (ba1 == ta2 || ba1 == ta3 || ba1 == ta4) {
	    updown = true;
	    if (ba1 == ta2)
	      hp1.z -= 0.8;
	    if (ba1 == ta3)
	      hp3.z -= 0.8;
	    if (ba1 == ta4)
	      hp4.z -= 0.8;
	  } else
	    level--;
	}
	if (ba2 == ta1 && bond[i].stereo == bstereo_down) {
	  up = true;
	  if (ba1 == ta2 || ba1 == ta3 || ba1 == ta4) {
	    updown = true;
	    if (ba1 == ta2)
	      hp1.z += 0.8;
	    if (ba1 == ta3)
	      hp3.z += 0.8;
	    if (ba1 == ta4)
	      hp4.z += 0.8;
	  } else
	    level++;
	}
      }
    }  /* for i ...*/
    if (updown == false && level != 0) {
      if (level > 0)
	hp2.z += 0.3;
      if (level < 0)
	hp2.z -= 0.3;
    } else {
      if (up)
	hp2.z += 0.1;
      if (down)
	hp2.z -= 0.1;
    }
  }
  /* get the pseudo-torsion angles*/
  ndl_ct = ctorsion(np1, np2, np3, np4);
  hst_ct = ctorsion(hp1, hp2, hp3, hp4);
  /*ndl_ct_deg := radtodeg(ndl_ct);
  hst_ct_deg := radtodeg(hst_ct); FIXME*/
  /* now do a plausibility check and finally check the sense*/
  /* (clockwise or counterclockwise)*/
  /*
  if (abs(ndl_ct_deg) > 5) and (abs(ndl_ct_deg) < 175) and
     (abs(hst_ct_deg) > 5) and (abs(hst_ct_deg) < 175) and
     (ndl_ct_deg * hst_ct_deg < 0) then res := false;
  */
  if (!is_flat(ndl_ct_deg) && !is_flat(hst_ct_deg) &&
      ndl_ct_deg * hst_ct_deg < 0)
    res = false;
  if (rs_strict) {
    if (is_flat(ndl_ct_deg) && !is_flat(hst_ct_deg) ||
	is_flat(hst_ct_deg) && !is_flat(ndl_ct_deg) ||
	ndl_ct_deg * hst_ct_deg < 0)
      res = false;
  }
  return res;
}


Static boolean ndl_maybe_chiral(short na)
{
  /* new in v0.3h*/
  boolean res = false;
  str2 el;
  str3 at;
  short n_nb;

  strcpy(el, ndl_atom[na-1].element);
  strcpy(at, ndl_atom[na-1].atype);
  n_nb = ndl_atom[na-1].neighbor_count;
  if (!strcmp(at, "C3 ") && n_nb > 2)
    res = true;
  if (!strcmp(el, "N ")) {
    if (!strcmp(at, "N3+") && n_nb == 4)
      res = true;
  }
  if (!strcmp(el, "S ")) {  /* sulfoxide*/
    if (n_nb == 3 && ndl_hetatom_count(na) == 1)
      res = true;
  }
  if (!strcmp(el, "P ") || !strcmp(el, "AS")) {   /* "As" added in v0.3j*/
    if (n_nb > 3)   /* are we missing something here?*/
      res = true;
  }
  return res;
}


Static boolean is_matching(short *ndl_xmp, short *hst_xmp)
{
  short i, j, k, l, m, ndl_n_nb, n_nb, ndl_a, hst_a;
  short ndl_b = 0, hst_b = 0, prev_ndl_a = 0, prev_hst_a = 0;
  short next_ndl_a, next_hst_a;
  neighbor_rec ndl_nb, hst_nb;
  matchmatrix mm;
  short ndl_mp_len, hst_mp_len;
  matchpath_type ndl_mp, hst_mp;
  boolean emptyline, res, ndl_cis, hst_cis;
  short na1, na2, na3, na4;   /* v0.3d*/
  short ha1, ha2, ha3, ha4;   /* atom variables for E/Z check*/
  short prev_ndl_b;   /**/
  short prev_hst_b;   /**/
  p_3d p1, p2, p3, p4;
  /*hst_torsion, ndl_torsion : double;*/
  chirpath_type ncp, hcp;
  short n_hits, n_singlehits;

  /*{$IFDEF debug
  tmpstr : string;
  {$ENDIF*/
  /* initialize local matchpath variables*/
  memset(ndl_mp, 0, sizeof(matchpath_type));
  memset(hst_mp, 0, sizeof(matchpath_type));
  /* copy content of external variables into local ones*/
  for (i = 0; i <= max_matchpath_length - 1; i++) {
    ndl_mp[i] = ndl_xmp[i];
    hst_mp[i] = hst_xmp[i];
  }
  ndl_mp_len = matchpath_length(ndl_mp);
  hst_mp_len = matchpath_length(hst_mp);
  if (ndl_mp_len != hst_mp_len) {
    /* this should never happen....*/
    /*{$IFDEF debug
    debugoutput('needle and haystack matchpaths are of different length');
    {$ENDIF*/
    return false;
  }
  ndl_a = ndl_mp[ndl_mp_len-1];
  hst_a = hst_mp[hst_mp_len-1];
  if (ndl_mp_len > 1) {
    prev_ndl_a = ndl_mp[ndl_mp_len-2];
    prev_hst_a = hst_mp[hst_mp_len-2];
  }
  /* if geometry checking is on, check it here*/
  if (ez_search == true && ndl_mp_len > 3) {
    na1 = ndl_mp[ndl_mp_len-1];
    na2 = ndl_mp[ndl_mp_len-2];
    na3 = ndl_mp[ndl_mp_len-3];
    na4 = ndl_mp[ndl_mp_len-4];
    ha1 = hst_mp[hst_mp_len-1];
    ha2 = hst_mp[hst_mp_len-2];
    ha3 = hst_mp[hst_mp_len-3];
    ha4 = hst_mp[hst_mp_len-4];
    prev_ndl_b = get_ndl_bond(na2, na3);
    prev_hst_b = get_bond(ha2, ha3);
    if (ndl_bond[prev_ndl_b-1].btype == 'D' &&
	bond[prev_hst_b-1].arom == false &&
	(!strcmp(atom[ha2-1].element, "C ") ||
	 !strcmp(atom[ha2-1].element, "N ")) &&
	(!strcmp(atom[ha3-1].element, "C ") ||
	 !strcmp(atom[ha3-1].element, "N ")))
    {   /* v0.3g; check C=C, C=N, N=N bonds*/
      p1.x = atom[ha1-1].x;
      p1.y = atom[ha1-1].y;
      p1.z = atom[ha1-1].z;
      p2.x = atom[ha2-1].x;
      p2.y = atom[ha2-1].y;
      p2.z = atom[ha2-1].z;
      p3.x = atom[ha3-1].x;
      p3.y = atom[ha3-1].y;
      p3.z = atom[ha3-1].z;
      p4.x = atom[ha4-1].x;
      p4.y = atom[ha4-1].y;
      p4.z = atom[ha4-1].z;
      hst_cis = is_cis(p1, p2, p3, p4);
      /*hst_torsion := torsion(p1,p2,p3,p4);*/
      p1.x = ndl_atom[na1-1].x;
      p1.y = ndl_atom[na1-1].y;
      p1.z = ndl_atom[na1-1].z;
      p2.x = ndl_atom[na2-1].x;
      p2.y = ndl_atom[na2-1].y;
      p2.z = ndl_atom[na2-1].z;
      p3.x = ndl_atom[na3-1].x;
      p3.y = ndl_atom[na3-1].y;
      p3.z = ndl_atom[na3-1].z;
      p4.x = ndl_atom[na4-1].x;
      p4.y = ndl_atom[na4-1].y;
      p4.z = ndl_atom[na4-1].z;
      /*ndl_torsion := torsion(p1,p2,p3,p4);*/
      ndl_cis = is_cis(p1, p2, p3, p4);
      if (ndl_cis != hst_cis) {
	/*{$IFDEF debug
	debugoutput('E/Z geometry mismatch');
	{$ENDIF*/
	return false;
      }
    }
  }  /* end of E/Z geometry check*/
  /* check whatever can be checked as early as now:*/
  /* e.g. different elements or more substituents on needle atom than on haystack*/
  if (!atomtypes_OK(ndl_a, hst_a))
    return false;
  /* positive scenarios:*/
  ndl_b = get_ndl_bond(prev_ndl_a, ndl_a);
  hst_b = get_bond(prev_hst_a, hst_a);
  /*{$IFDEF debug
  debugoutput('Now checking atoms '+inttostr(ndl_a)+'/'+inttostr(hst_a)+', bonds '+inttostr(ndl_b)+'/'+inttostr(hst_b));
  {$ENDIF*/
  if (ndl_b > 0 && hst_b > 0) {
    /* do a quick check if bond types match*/
    if (!bondtypes_OK(ndl_b, hst_b)) {
      /*{$IFDEF debug
      debugoutput('  failed match of bonds '+inttostr(ndl_b)+'/'+inttostr(hst_b));
      {$ENDIF*/
      return false;
    }
  }
  /* a) we reached the end of our needle fragment (and atom/bond types match)*/
  if (ndl_atom[ndl_a-1].neighbor_count == 1 && atomtypes_OK(ndl_a, hst_a) &&
      bondtypes_OK(ndl_b, hst_b)) {
    return true;
    /*{$IFDEF debug
    debugoutput('  ==> end of needle fragment at atom '+inttostr(ndl_a)+' (match)');
    {$ENDIF*/
  }
  /* b) a ring is formed (ndl_a is already in the path) and atom/bond types match*/
  if (matchpath_pos(ndl_a, ndl_mp) > 0 &&
      matchpath_pos(ndl_a, ndl_mp) < matchpath_length(ndl_mp)) {
    if (matchpath_pos(ndl_a, ndl_mp) == matchpath_pos(hst_a, hst_mp) &&
	atomtypes_OK(ndl_a, hst_a) && bondtypes_OK(ndl_b, hst_b)) {
      /* 1st chirality check*/
      if (!(matchpath_pos(ndl_a, ndl_mp) > 1 &&
	    (rs_search || ndl_atom[ndl_a-1].stereo_care) &&
	    ndl_maybe_chiral(ndl_a)))
      {   /* new in v0.3h*/
	return true;
      }  /* end of 1st chirality check*/
      na1 = ndl_a;   /* the (potential) chiral center (v0.3f)*/
      na2 = ndl_mp[matchpath_pos(ndl_a, ndl_mp) - 2];
      na3 = ndl_mp[matchpath_pos(ndl_a, ndl_mp)];
      na4 = ndl_mp[matchpath_length(ndl_mp) - 2];
      ha1 = hst_a;
      ha2 = hst_mp[matchpath_pos(hst_a, hst_mp) - 2];
      ha3 = hst_mp[matchpath_pos(hst_a, hst_mp)];
      ha4 = hst_mp[matchpath_length(hst_mp) - 2];
      memset(ncp, 0, sizeof(chirpath_type));
      memset(hcp, 0, sizeof(chirpath_type));
      ncp[0] = na1;
      ncp[1] = na2;
      ncp[2] = na3;
      ncp[3] = na4;
      hcp[0] = ha1;
      hcp[1] = ha2;
      hcp[2] = ha3;
      hcp[3] = ha4;
      if (!chirality_OK(ncp, hcp)) {
	/*{$IFDEF debug
	debugoutput('chirality check failed at ring junction');
	{$ENDIF*/
	return false;
      }
      /*{$IFDEF debug
      debugoutput('chirality check succeeded at ring junction');
      {$ENDIF*/
      return true;
      /*{$IFDEF debug
      debugoutput('matchpath forms ring at: '+inttostr(ndl_a)+' (match)');
      {$ENDIF*/
    } else {
      return false;
      /*{$IFDEF debug
      debugoutput('matchpath forms ring at: '+inttostr(ndl_a)+' (no match)');
      {$ENDIF*/
    }
  }
  /* in all other cases, do the hard work:*/
  /* first, get all heavy-atom neighbors of needle and haystack;*/
  /* at the beginning of the search, this means all neighbors, then it means*/
  /* all but the previous atom (where we came from)*/
  memset(ndl_nb, 0, sizeof(neighbor_rec));
  memset(hst_nb, 0, sizeof(neighbor_rec));
  if (matchpath_length(ndl_mp) == 1) {
    ndl_n_nb = ndl_atom[ndl_a-1].neighbor_count;
    n_nb = atom[hst_a-1].neighbor_count;
    get_ndl_neighbors(ndl_nb, ndl_a);
    get_neighbors(hst_nb, hst_a);
  } else {
    ndl_n_nb = ndl_atom[ndl_a-1].neighbor_count - 1;
    n_nb = atom[hst_a-1].neighbor_count - 1;
    get_ndl_nextneighbors(ndl_nb, ndl_a, prev_ndl_a);
    get_nextneighbors(hst_nb, hst_a, prev_hst_a);
  }
  /* now that the neighbor-arrays are filled, get all*/
  /* combinations of matches recursively;*/
  /* first, initialize the match matrix*/
  memset(mm, false, sizeof(matchmatrix));   /* new in v0.2i*/
  /* make sure there are not too many neighbors (max. max_neighbors)  */
  if (ndl_n_nb > max_neighbors || n_nb > max_neighbors) {
	/* updated in v0.2i*/
	  /*{$IFDEF debug
	  debugoutput('too many neighbors - exiting');
	  {$ENDIF*/
	  return false;
  }
  /* check if matchpath is not already filled up*/
  if (matchpath_length(ndl_mp) == max_matchpath_length) {
    /*{$IFDEF debug
    debugoutput('matchpath too long - exiting');
    {$ENDIF*/
    return false;
  }
  /* next, check which chain of the needle matches which chain of the haystack */
  for (i = 0; i <= ndl_n_nb - 1; i++) {
    emptyline = true;
    next_ndl_a = ndl_nb[i];
    for (j = 0; j <= n_nb - 1; j++) {
      next_hst_a = hst_nb[j];
      ndl_mp[ndl_mp_len] = next_ndl_a;
      hst_mp[hst_mp_len] = next_hst_a;
      if (is_matching(ndl_mp, hst_mp)) {
	mm[i][j] = true;
	emptyline = false;
      }
    }
    /* if a needle substituent does not match any of the haystack substituents,*/
    /* stop any further work immediately*/
    if (emptyline)
      return false;
  }
  /* finally, check the content of the matrix*/
  res = matrix_OK(mm, ndl_n_nb, n_nb);
  /* optional: chirality check*/
  if (!(res && (rs_search || ndl_atom[ndl_a-1].stereo_care) &&
	ndl_maybe_chiral(ndl_a)))
    return res;
  /* first, we have to clean up the match matrix in order to remove*/
  /* "impossible" multiple matches (new in v0.3h)*/
  for (i = 1; i <= 3; i++) {
    for (j = 1; j <= max_neighbors; j++) {   /* haystack dimension*/
      n_hits = 0;
      l = 0;
      for (k = 1; k <= max_neighbors; k++) {   /* needle dimension*/
	if (mm[k-1][j-1]) {
	  n_hits++;
	  l = k;
	}
      }
      if (n_hits == 1)
      {   /* a unique match ==> kick out any other match at this pos.*/
	for (m = 1; m <= max_neighbors; m++) {
	  if (m != j)
	    mm[l-1][m-1] = false;
	}
      }
    }
  }
  /* end of match matrix clean-up*/
  if (prev_ndl_a > 0) {
    n_singlehits = 1;
    ncp[1] = prev_ndl_a;
    hcp[1] = prev_hst_a;
  } else
    n_singlehits = 0;
  ncp[0] = ndl_a;
  hcp[0] = hst_a;
  i = 0;
  l = 0;
  while (n_singlehits < 3 && i < 4) {
    i++;
    n_hits = 0;
    for (k = 1; k <= n_nb; k++) {
      if (mm[i-1][k-1]) {
	n_hits++;
	l = k;
      }
    }
    if (n_hits == 1) {
      n_singlehits++;
      ncp[n_singlehits] = ndl_nb[i-1];
      hcp[n_singlehits] = hst_nb[l-1];
    }
  }
  if (n_singlehits == 3) {
    if (!chirality_OK(ncp, hcp)) {
      /*{$IFDEF debug
      debugoutput('chirality check failed');
      {$ENDIF*/
      res = false;
    }
  }
  /*{$IFDEF debug
  debugoutput('chirality check OK');
  {$ENDIF*/
  return res;
  /*{$IFDEF debug
  if res then tmpstr := ' MATCH' else tmpstr := ' NO MATCH';
  debugoutput('result for atoms '+inttostr(ndl_a)+'/'+inttostr(hst_a)+', bonds '+inttostr(ndl_b)+'/'+inttostr(hst_b)+':'+tmpstr);
  {$ENDIF*/
}


Static boolean quick_match(void)
{
  /* added in v0.2c*/
  boolean res = true;
  short i;
  str3 ndl_atype;
  str2 ndl_el;   /* v0.3l*/
  short ndl_chg;   /* v0.3l*/
  short FORLIM;

  if (ez_search || rs_search)   /* v0.3f*/
    return false;
  if (ndl_n_atoms < 1 || n_atoms < 1 || ndl_n_atoms > n_atoms ||
      ndl_n_bonds > n_bonds)
  {  /* just to be sure...*/
    return false;
    /*{$IFDEF debug
    debugoutput(' ==> quick_match failed');
    {$ENDIF*/
  }
  FORLIM = ndl_n_atoms;
  for (i = 0; i <= FORLIM - 1; i++) {
    /*if atom^[i].atype <> ndl_atom^[i].atype then res := false;    { changed in*/
    if (strcmp(atom[i].element, ndl_atom[i].element))   /* v0.2k*/
      res = false;
  }
  /*{$IFDEF debug
  if res then debugoutput(' ==> quick_match: atoms OK') else debugoutput(' ==> quick_match: atoms not OK');
  {$ENDIF*/
  if (ndl_n_bonds > 0) {
    FORLIM = ndl_n_bonds;
    for (i = 0; i <= FORLIM - 1; i++) {
      if (ndl_bond[i].a1 != bond[i].a1 || ndl_bond[i].a2 != bond[i].a2 ||
	  ndl_bond[i].btype != bond[i].btype)
	res = false;
    }
  }
  /* added in v0.2d: special case: needle contains only one heavy atom; refined in v0.3l*/
  if (ndl_n_heavyatoms != 1)
    return res;
  FORLIM = ndl_n_atoms;
  /* first, find out the element and atom type of the only heavy atom      */
  for (i = 0; i <= FORLIM - 1; i++) {
    if (ndl_atom[i].heavy) {
      strcpy(ndl_atype, ndl_atom[i].atype);
      strcpy(ndl_el, ndl_atom[i].element);   /* v0.3l*/
      ndl_chg = ndl_atom[i].formal_charge;   /* v0.3l*/
    }
  }
  FORLIM = n_atoms;
  for (i = 0; i <= FORLIM - 1; i++) {   /* v0.3l*/
    if (!strcmp(atom[i].atype, ndl_atype) &&
	!strcmp(atom[i].element, ndl_el) &&
	ndl_chg * atom[i].formal_charge >= 0)
      res = true;
  }
  /*{$IFDEF debug
  if res then debugoutput(' ==> quick_match succeeded') else debugoutput(' ==> quick_match failed (2)');
  {$ENDIF*/
  return res;
}


Static void perform_match(void)
{
  short i = 0;
  short j;
  /*ndl_ref_atom : integer;  { since v0.3j as a global variable*/
  short ndl_n_nb, ndl_n_hc, n_nb, n_hc;
  boolean qm;   /* v0.3l*/

  /* check for NoStruct (0 atoms);  v0.3l*/
  if (n_atoms == 0 || ndl_n_atoms == 0) {
    matchresult = false;
    /*{$IFDEF debug
    debugoutput('NoStruct encountered - aborted match routine');
    {$ENDIF*/
    return;
  }
  /* if we perform an exact match, needle and haystack must have*/
  /* the same number of atoms, bonds, and rings*/
  if (opt_exact) {
    if (n_heavyatoms != ndl_n_heavyatoms || n_heavybonds != ndl_n_heavybonds) {
      matchresult = false;
      /*{$IFDEF debug
      debugoutput('different number of heavy atoms and/or bonds');
      {$ENDIF*/
      return;
    }
  }
  /* have a quick look if needle and haystack are identical molfiles*/
  qm = quick_match();   /* v0.3l*/
  if (qm) {
    matchresult = true;
    return;
  }
  /* if we have only one heavy atom and quick_match fails, return "false";  v0.3l*/
  if (ndl_n_heavyatoms == 1) {
    matchresult = false;
    return;
  }
  /* first, look for a characteristic atom in the needle*/
  /*ndl_ref_atom := find_ndl_ref_atom;  */
  /*{$IFDEF debug
  debugoutput('needle reference atom: '+inttostr(ndl_ref_atom)+' ('+ndl_atom^[ndl_ref_atom].atype+')');
  {$ENDIF*/
  ndl_n_nb = ndl_atom[ndl_ref_atom-1].neighbor_count;
  ndl_n_hc = ndl_hetatom_count(ndl_ref_atom);
  /*{$IFDEF debug
  debugoutput('neighbor atoms: '+inttostr(ndl_n_nb)+'  heteroatom neighbors: '+inttostr(ndl_n_hc));
  {$ENDIF*/
  matchresult = false;
  for (j = 0; j <= max_matchpath_length - 1; j++) {
    ndl_matchpath[j] = 0;
    hst_matchpath[j] = 0;
  }
  ndl_matchpath[0] = ndl_ref_atom;
  while (i < n_atoms && matchresult == false) {
    i++;
    n_nb = atom[i-1].neighbor_count;
    n_hc = hetatom_count(i);
    if (n_nb >= ndl_n_nb && n_hc >= ndl_n_hc) {
      /*{$IFDEF debug
      debugoutput('trying atom '+inttostr(i)+'; neighbor atoms: '+inttostr(n_nb)+' heteroatom neighbors: '+inttostr(n_hc));
      {$ENDIF*/
      hst_matchpath[0] = i;
      matchresult = is_matching(ndl_matchpath, hst_matchpath);
      /*{$IFDEF debug
      if matchresult then debugoutput('matching atom in haystack: '+inttostr(i)+' ('+atom^[i].atype+')');
      {$ENDIF*/
    }
  }
}


Static void clear_rings(void)
{
  short i, FORLIM;

  n_rings = 0;
  memset(ring, 0, sizeof(ringlist));
  for (i = 0; i <= max_rings - 1; i++) {   /* new in v0.3*/
    ringprop[i].size = 0;
    ringprop[i].arom = false;
    ringprop[i].envelope = false;
  }
  if (n_atoms > 0) {
    FORLIM = n_atoms;
    for (i = 0; i <= FORLIM - 1; i++)
      atom[i].ring_count = 0;
  }
  if (n_bonds > 0) {
    FORLIM = n_bonds;
    for (i = 0; i <= FORLIM - 1; i++)
      bond[i].ring_count = 0;
  }
}


Static short ring_lastpos(short *s)
{
  short i, rc;
  short rlp = 0;
  short FORLIM;

  if (n_rings <= 0)
    return rlp;
  FORLIM = n_rings;
  for (i = 1; i <= FORLIM; i++) {
    rc = ringcompare(s, ring[i-1]);
    if (rc_identical(rc))
      rlp = i;
  }
  return rlp;
}


Static void remove_redundant_rings(void)
{
  short i, j, k, rlp;
  ringpath_type tmp_path;
  short FORLIM, FORLIM1;

  if (n_rings < 2)
    return;
  FORLIM = n_rings;
  for (i = 1; i <= FORLIM - 1; i++) {
    memcpy(tmp_path, ring[i-1], sizeof(ringpath_type));
    rlp = ring_lastpos(tmp_path);
    while (rlp > i) {
      FORLIM1 = n_rings;
      /*{$IFDEF debug
      debugoutput('removing redundant ring: '+inttostr(rlp)+' (identical to ring '+inttostr(i)+')');
      {$ENDIF*/
      for (j = rlp; j <= FORLIM1 - 1; j++) {
	memcpy(ring[j-1], ring[j], sizeof(ringpath_type));
	ringprop[j-1].size = ringprop[j].size;   /* new in v0.3*/
	ringprop[j-1].arom = ringprop[j].arom;
	ringprop[j-1].envelope = ringprop[j].envelope;
      }
      for (k = 0; k <= max_ringsize - 1; k++)
	ring[n_rings-1][k] = 0;
      n_rings--;
      rlp = ring_lastpos(tmp_path);
    }
  }
}


Static short count_aromatic_rings(void)
{
  short i;
  short n = 0;
  short FORLIM;

  if (n_rings <= 0)
    return n;
  FORLIM = n_rings;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (ringprop[i].arom)
      n++;
  }
  return n;
}


Static void chk_envelopes(void)
{
  /* new in v0.3d*/
  /* checks if a ring completely contains one or more other rings*/
  short a, i, j, k, l, pl, pli;
  boolean found_atom, found_all_atoms, found_ring;
  short FORLIM;

  if (n_rings < 2)
    return;
  FORLIM = n_rings;
  for (i = 1; i <= FORLIM - 1; i++) {
    found_ring = false;
    j = 0;
    pli = ringprop[i].size;   /* path_length(ring^[i]);*/
    while (j < i && found_ring == false) {
      j++;
      found_all_atoms = true;
      pl = ringprop[j-1].size;   /* path_length(ring^[j]);*/
      for (k = 0; k <= pl - 1; k++) {
	found_atom = false;
	a = ring[j-1][k];
	for (l = 0; l <= pli - 1; l++) {
	  if (ring[i][l] == a)
	    found_atom = true;
	}
	if (found_atom == false)
	  found_all_atoms = false;
      }
      if (found_all_atoms)
	found_ring = true;
    }
    if (found_ring)
      ringprop[i].envelope = true;
  }
}


Static void update_ringcount(void)
{
  short i, j, a1, a2, b, pl, FORLIM;

  if (n_rings <= 0)
    return;
  chk_envelopes();
  FORLIM = n_rings;
  for (i = 0; i <= FORLIM - 1; i++) {
    if (ringprop[i].envelope == false) {
      pl = ringprop[i].size;   /* path_length(ring^[i]);  { v0.3d*/
      a2 = ring[i][pl-1];
      for (j = 0; j <= pl - 1; j++) {
	a1 = ring[i][j];
	atom[a1-1].ring_count++;
	b = get_bond(a1, a2);
	bond[b-1].ring_count++;
	a2 = a1;
      }
    }
  }
}


Static void normalize_ionic_bonds(void)
{
  /* v0.3k*/
  short i, a1, a2, fc1, fc2;
  Char bt;
  short FORLIM;

  if (n_bonds == 0)
    return;
  FORLIM = n_bonds;
  for (i = 0; i <= FORLIM - 1; i++) {
    a1 = bond[i].a1;
    a2 = bond[i].a2;
    bt = bond[i].btype;
    fc1 = atom[a1-1].formal_charge;
    fc2 = atom[a2-1].formal_charge;
    if (fc1 * fc2 == -1 && (bt == 'S' || bt == 'D')) {
      atom[a1-1].formal_charge = 0;
      atom[a2-1].formal_charge = 0;
      if (bt == 'D')
	bond[i].btype = 'T';
      if (bt == 'S')
	bond[i].btype = 'D';
    }
  }
}


main(int argc, Char *argv[])
{  /* main routine*/
  Char STR1[256], STR6[256];
  short FORLIM;

  PASCAL_MAIN(argc, argv);
  /* progmode = pmMatchMol*/
  rfile = NULL;
  sprintf(STR1, "%c", toupper(*progname));
  /*progname := extractfilename(paramstr(0)); FIXME*/
  if (strpos2(STR1, "MATCHMOL", 1) > 0)
    progmode = pmMatchMol;
  else {
    sprintf(STR6, "%c", toupper(*progname));
    if (strpos2(STR6, "CHECKMOL", 1) <= 0) {
      printf("THOU SHALLST NOT RENAME ME!\n");
      _Escape(9);
    }
    progmode = pmCheckMol;
  }
  if (P_argc == 1) {
    show_usage();
    _Escape(1);
  }
  init_globals();
  init_molstat(&molstat);
  parse_args();
  if (ringsearch_mode == rs_sar)
    max_vringsize = max_ringsize;
  else
    max_vringsize = 10;
  /*if opt_verbose then writeln(progname+' v',version,'  N. Haider 2003-2005');*/
  if (progmode == pmMatchMol) {
    left_trim(ndl_molfilename);
    left_trim(molfilename);
    if ((*molfilename == '\0' || *ndl_molfilename == '\0' || P_argc < 3) &&
	!opt_stdin) {
      show_usage();
      _Escape(2);   /* new in v0.2k*/
    }
    if ((~fileexists(ndl_molfilename)) & (!opt_stdin)) {
/* p2c: checkmol3l.pas, line 9022:
 * Warning: Symbol 'FILEEXISTS' is not defined [221] */
      if (strlen(ndl_molfilename) > 1 && ndl_molfilename[0] == '-')
	show_usage();
      else
	printf("file %s not found!\n", ndl_molfilename);
      /* new in v0.2k*/
      _Escape(2);
    }
  }
  if ((~fileexists(molfilename)) & (!opt_stdin)) {
/* p2c: checkmol3l.pas, line 9029:
 * Warning: Symbol 'FILEEXISTS' is not defined [221] */
    if (strlen(molfilename) > 1 && molfilename[0] == '-') {
      /*writeln('  you entered this molfilename: ',molfilename);*/
      show_usage();
    } else
      printf("file %s not found!\n", molfilename);
    /* new in v0.2k*/
    _Escape(2);
  }
  /* read the first molecule and process it; if we are in "matchmol" mode,*/
  /* this is the "needle"*/
  if (progmode == pmMatchMol)
    readinputfile(ndl_molfilename);
  else
    readinputfile(molfilename);
  li = 1;   /* initialize line pointer for input buffer*/
  get_filetype(filetype, ndl_molfilename);
  if (!strcmp(filetype, "unknown")) {
    printf("unknown query file format!\n");
    if (!opt_verbose)
      _Escape(3);
    printf("===========================================\n");
    FORLIM = molbufindex;
    for (i = 1; i <= FORLIM; i++)
      puts(molbuf[i-1]);
    _Escape(3);
  }
  mol_OK = true;   /* added in v0.2i*/
  if (!strcmp(filetype, "alchemy"))
    read_molfile(ndl_molfilename);
  if (!strcmp(filetype, "sybyl"))
    read_mol2file(ndl_molfilename);
  if (!strcmp(filetype, "mdl"))
    read_MDLmolfile(ndl_molfilename);
  count_neighbors();
  if (!mol_OK || n_atoms < 1)
  {   /* v0.3g; check if this is a valid query structure*/
    printf("invalid molecule\n");
    _Escape(3);
  }
  if (!found_arominfo || progmode == pmCheckMol) {   /* added in v0.2b/0.2c*/
    /*{$IFDEF debug
    if (not found_arominfo) then debugoutput('no aromaticity information found - checking myself...')
      else debugoutput('performing full aromaticity check');   (* new in v0.3d*)
    {$ENDIF*/
    chk_ringbonds();
    if (ringsearch_mode == rs_ssr)
      remove_redundant_rings();
    if (n_rings == max_rings) {
      if (opt_verbose)
	printf("warning: max. number of rings exceeded, reverting to SSR search\n");
      ringsearch_mode = rs_ssr;
      clear_rings();
      max_vringsize = 10;
      chk_ringbonds();
      remove_redundant_rings();
    }
    update_ringcount();
    /* new in v0.3k: if output is a molfile, leave the original*/
    /* representation of N-oxides, S-oxides, nitro groups, etc.*/
    /* unchanged (ionic or non-ionic), in any other case make covalent bonds*/
    if (!opt_xmdlout)   /* v0.3k*/
      normalize_ionic_bonds();
    update_atypes();
    update_Htotal();   /* added in v0.3*/
    chk_arom();
    if (ringsearch_mode == rs_ssr) {   /* new in v0.3*/
      do {
	prev_n_ar = count_aromatic_rings();
	chk_arom();
	n_ar = count_aromatic_rings();
      } while (prev_n_ar - n_ar != 0);
    }
  } else {
    /*{$IFDEF debug
      debugoutput('found aromaticity information in input file');
      {$ENDIF*/
    if (!opt_xmdlout)   /* v0.3k*/
      normalize_ionic_bonds();
    update_atypes();   /* added in v0.2f*/
    update_Htotal();   /* end v0.2b snippet*/
  }
  if (progmode == pmCheckMol) {
    if (opt_verbose)
      write_mol();
    get_molstat();
    if (opt_molstat) {
      if (opt_molstat_X)
	write_molstat_X();
      else
	write_molstat();
    } else {
      if (found_querymol) {
	printf("input structure contains query atom or query bond!\n");
	_Escape(1);
      }
      chk_functionalgroups();
      if (opt_none)
	opt_text = true;
      if (opt_text)
	write_fg_text();
      if (opt_text_de)
	write_fg_text_de();
      if (opt_code)
	write_fg_code();
      if (opt_bin)
	write_fg_binary();
      if (opt_bitstring)
	write_fg_bitstring();
      if (opt_xmdlout)
	write_MDLmolfile();
    }
    /*if opt_verbose   then write_mol;*/
    zap_molecule();
  } else {
    /* now transfer all data to the "needle" set of variables*/
    copy_mol_to_needle();
    if (opt_verbose)
      write_needle_mol();
    mol_count = 0;
    if (rs_strict)   /* v0.3j*/
      ndl_ref_atom = find_ndl_ref_atom_cv();
    else
      ndl_ref_atom = find_ndl_ref_atom();
    /* next, read the "haystack" file and process it*/
    li = 1;
    do {
      /* new in v0.3i: reset ringsearch_mode to its initial value*/
      /* for each new molecule*/
      ringsearch_mode = opt_rs;
      if (ringsearch_mode == rs_sar)
	max_vringsize = max_ringsize;
      else
	max_vringsize = 10;
      readinputfile(molfilename);
      li = 1;
      get_filetype(filetype, molfilename);
      if (strcmp(filetype, "unknown")) {
	found_arominfo = false;   /* added in v0.2b*/
	mol_OK = true;   /* added in v0.2i*/
	if (!strcmp(filetype, "alchemy"))
	  read_molfile(molfilename);
	if (!strcmp(filetype, "sybyl"))
	  read_mol2file(molfilename);
	if (!strcmp(filetype, "mdl"))
	  read_MDLmolfile(molfilename);
	mol_count++;
	count_neighbors();
	/*if (not mol_OK) or (n_atoms < 1) then writeln(mol_count,':no valid structure found') else*/
	if (!mol_OK || n_atoms < 1)
	  printf("%ld:F\n", mol_count);
	else {
	  if (opt_exact && (n_Ctot != ndl_n_Ctot || n_Otot != ndl_n_Otot ||
			    n_Ntot != ndl_n_Ntot))
	  {   /* new in v0.3g*/
	    if (!opt_molout)
	      printf("%ld:F\n", mol_count);
	  } else {
	    if (!found_arominfo) {
	      /*{$IFDEF debug
	      debugoutput('no aromaticity information found - checking myself...');
	      {$ENDIF*/
	      chk_ringbonds();
	      if (ringsearch_mode == rs_ssr)
		remove_redundant_rings();
	      if (n_rings == max_rings) {
		if (opt_verbose)
		  printf(
		    "Warning: max. number of rings reached, reverting to SSR search\n");
		ringsearch_mode = rs_ssr;
		clear_rings();
		max_vringsize = 10;
		chk_ringbonds();
		remove_redundant_rings();
	      }
	      update_ringcount();
	      update_atypes();
	      update_Htotal();   /* added in v0.3*/
	      chk_arom();
	      if (ringsearch_mode == rs_ssr) {   /* new in v0.3*/
		do {
		  prev_n_ar = count_aromatic_rings();
		  chk_arom();
		  n_ar = count_aromatic_rings();
		} while (prev_n_ar - n_ar != 0);
	      }
	    } else {
	      /*{$IFDEF debug
	      debugoutput('found aromaticity information in input file');
	      {$ENDIF*/
	      if (opt_strict)   /* added in v0.2f*/
		update_atypes();
	      update_Htotal();
	    }
	    init_molstat(&ndl_molstat);
	    if (opt_verbose)
	      write_mol();
	    normalize_ionic_bonds();   /* new in v0.3k*/
	    /* now that we have both molecules, perform the comparison*/
	    perform_match();
	    if (matchresult == true) {
	      if (opt_molout) {
		FORLIM = molbufindex;
		for (i = 1; i <= FORLIM; i++)
		  puts(molbuf[i-1]);
	      } else
		printf("%ld:T\n", inttostr(mol_count));
	    } else {
/* p2c: checkmol3l.pas, line 9217:
 * Warning: Symbol 'INTTOSTR' is not defined [221] */
	      if (!opt_molout)
		printf("%ld:F\n", inttostr(mol_count));
/* p2c: checkmol3l.pas, line 9220:
 * Warning: Symbol 'INTTOSTR' is not defined [221] */
	    }
	    zap_molecule();
	    molbufindex = 0;
	  }
	}
      } else {
	/* v0.3l*/
	/* mol_OK*/
	printf("%ld:unknown file format\n", mol_count);
      }
    } while (mol_in_queue != false);
    /* if filetype <> 'unknown'*/
    zap_needle();
    if (rfile_is_open) {   /* new in v0.2g*/
      if (rfile != NULL)
	fclose(rfile);
      rfile = NULL;
    }
  }
  if (rfile != NULL)
    fclose(rfile);
  exit(EXIT_SUCCESS);
}



/* End. */
